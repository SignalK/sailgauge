/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!**********************!*\
  !*** ./sailgauge.js ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	Bacon = __webpack_require__(/*! baconjs */ 1);
	d3 = __webpack_require__(/*! d3 */ 5);
	
	SailGauge = __webpack_require__(/*! ./lib/sailgauge.js */ 6);
	__webpack_require__(/*! ./lib/baconslidingtimewindow.js */ 13);
	navi = __webpack_require__(/*! ./lib/naviutils.js */ 11);
	WebSocket = __webpack_require__(/*! ws */ 14);
	SignalK = __webpack_require__(/*! signalk-client */ 15);
	


/***/ },
/* 1 */
/*!*********************************!*\
  !*** ./~/baconjs/dist/Bacon.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {(function() {
	  var Bacon, BufferingSource, Bus, CompositeUnsubscribe, ConsumingSource, Desc, Dispatcher, End, Error, Event, EventStream, Exception, Initial, Next, None, Observable, Property, PropertyDispatcher, Some, Source, UpdateBarrier, _, addPropertyInitValueToStream, assert, assertArray, assertEventStream, assertFunction, assertNoArguments, assertObservable, assertObservableIsProperty, assertString, cloneArray, constantToFunction, containsDuplicateDeps, convertArgsToFunction, describe, endEvent, eventIdCounter, eventMethods, findDeps, findHandlerMethods, flatMap_, former, idCounter, initialEvent, isArray, isFieldKey, isObservable, latter, liftCallback, makeFunction, makeFunctionArgs, makeFunction_, makeObservable, makeSpawner, nextEvent, nop, partiallyApplied, recursionDepth, ref, registerObs, spys, toCombinator, toEvent, toFieldExtractor, toFieldKey, toOption, toSimpleExtractor, valueAndEnd, withDescription, withMethodCallSupport,
	    hasProp = {}.hasOwnProperty,
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    slice = [].slice,
	    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  Bacon = {
	    toString: function() {
	      return "Bacon";
	    }
	  };
	
	  Bacon.version = '0.7.60';
	
	  Exception = (typeof global !== "undefined" && global !== null ? global : this).Error;
	
	  nop = function() {};
	
	  latter = function(_, x) {
	    return x;
	  };
	
	  former = function(x, _) {
	    return x;
	  };
	
	  cloneArray = function(xs) {
	    return xs.slice(0);
	  };
	
	  assert = function(message, condition) {
	    if (!condition) {
	      throw new Exception(message);
	    }
	  };
	
	  assertObservableIsProperty = function(x) {
	    if (x instanceof Observable && !(x instanceof Property)) {
	      throw new Exception("Observable is not a Property : " + x);
	    }
	  };
	
	  assertEventStream = function(event) {
	    if (!(event instanceof EventStream)) {
	      throw new Exception("not an EventStream : " + event);
	    }
	  };
	
	  assertObservable = function(event) {
	    if (!(event instanceof Observable)) {
	      throw new Exception("not an Observable : " + event);
	    }
	  };
	
	  assertFunction = function(f) {
	    return assert("not a function : " + f, _.isFunction(f));
	  };
	
	  isArray = function(xs) {
	    return xs instanceof Array;
	  };
	
	  isObservable = function(x) {
	    return x instanceof Observable;
	  };
	
	  assertArray = function(xs) {
	    if (!isArray(xs)) {
	      throw new Exception("not an array : " + xs);
	    }
	  };
	
	  assertNoArguments = function(args) {
	    return assert("no arguments supported", args.length === 0);
	  };
	
	  assertString = function(x) {
	    if (typeof x !== "string") {
	      throw new Exception("not a string : " + x);
	    }
	  };
	
	  _ = {
	    indexOf: Array.prototype.indexOf ? function(xs, x) {
	      return xs.indexOf(x);
	    } : function(xs, x) {
	      var i, j, len1, y;
	      for (i = j = 0, len1 = xs.length; j < len1; i = ++j) {
	        y = xs[i];
	        if (x === y) {
	          return i;
	        }
	      }
	      return -1;
	    },
	    indexWhere: function(xs, f) {
	      var i, j, len1, y;
	      for (i = j = 0, len1 = xs.length; j < len1; i = ++j) {
	        y = xs[i];
	        if (f(y)) {
	          return i;
	        }
	      }
	      return -1;
	    },
	    head: function(xs) {
	      return xs[0];
	    },
	    always: function(x) {
	      return function() {
	        return x;
	      };
	    },
	    negate: function(f) {
	      return function(x) {
	        return !f(x);
	      };
	    },
	    empty: function(xs) {
	      return xs.length === 0;
	    },
	    tail: function(xs) {
	      return xs.slice(1, xs.length);
	    },
	    filter: function(f, xs) {
	      var filtered, j, len1, x;
	      filtered = [];
	      for (j = 0, len1 = xs.length; j < len1; j++) {
	        x = xs[j];
	        if (f(x)) {
	          filtered.push(x);
	        }
	      }
	      return filtered;
	    },
	    map: function(f, xs) {
	      var j, len1, results, x;
	      results = [];
	      for (j = 0, len1 = xs.length; j < len1; j++) {
	        x = xs[j];
	        results.push(f(x));
	      }
	      return results;
	    },
	    each: function(xs, f) {
	      var key, value;
	      for (key in xs) {
	        value = xs[key];
	        f(key, value);
	      }
	      return void 0;
	    },
	    toArray: function(xs) {
	      if (isArray(xs)) {
	        return xs;
	      } else {
	        return [xs];
	      }
	    },
	    contains: function(xs, x) {
	      return _.indexOf(xs, x) !== -1;
	    },
	    id: function(x) {
	      return x;
	    },
	    last: function(xs) {
	      return xs[xs.length - 1];
	    },
	    all: function(xs, f) {
	      var j, len1, x;
	      if (f == null) {
	        f = _.id;
	      }
	      for (j = 0, len1 = xs.length; j < len1; j++) {
	        x = xs[j];
	        if (!f(x)) {
	          return false;
	        }
	      }
	      return true;
	    },
	    any: function(xs, f) {
	      var j, len1, x;
	      if (f == null) {
	        f = _.id;
	      }
	      for (j = 0, len1 = xs.length; j < len1; j++) {
	        x = xs[j];
	        if (f(x)) {
	          return true;
	        }
	      }
	      return false;
	    },
	    without: function(x, xs) {
	      return _.filter((function(y) {
	        return y !== x;
	      }), xs);
	    },
	    remove: function(x, xs) {
	      var i;
	      i = _.indexOf(xs, x);
	      if (i >= 0) {
	        return xs.splice(i, 1);
	      }
	    },
	    fold: function(xs, seed, f) {
	      var j, len1, x;
	      for (j = 0, len1 = xs.length; j < len1; j++) {
	        x = xs[j];
	        seed = f(seed, x);
	      }
	      return seed;
	    },
	    flatMap: function(f, xs) {
	      return _.fold(xs, [], (function(ys, x) {
	        return ys.concat(f(x));
	      }));
	    },
	    cached: function(f) {
	      var value;
	      value = None;
	      return function() {
	        if (value === None) {
	          value = f();
	          f = void 0;
	        }
	        return value;
	      };
	    },
	    isFunction: function(f) {
	      return typeof f === "function";
	    },
	    toString: function(obj) {
	      var ex, internals, key, value;
	      try {
	        recursionDepth++;
	        if (obj == null) {
	          return "undefined";
	        } else if (_.isFunction(obj)) {
	          return "function";
	        } else if (isArray(obj)) {
	          if (recursionDepth > 5) {
	            return "[..]";
	          }
	          return "[" + _.map(_.toString, obj).toString() + "]";
	        } else if (((obj != null ? obj.toString : void 0) != null) && obj.toString !== Object.prototype.toString) {
	          return obj.toString();
	        } else if (typeof obj === "object") {
	          if (recursionDepth > 5) {
	            return "{..}";
	          }
	          internals = (function() {
	            var results;
	            results = [];
	            for (key in obj) {
	              if (!hasProp.call(obj, key)) continue;
	              value = (function() {
	                try {
	                  return obj[key];
	                } catch (_error) {
	                  ex = _error;
	                  return ex;
	                }
	              })();
	              results.push(_.toString(key) + ":" + _.toString(value));
	            }
	            return results;
	          })();
	          return "{" + internals + "}";
	        } else {
	          return obj;
	        }
	      } finally {
	        recursionDepth--;
	      }
	    }
	  };
	
	  recursionDepth = 0;
	
	  Bacon._ = _;
	
	  UpdateBarrier = Bacon.UpdateBarrier = (function() {
	    var afterTransaction, afters, aftersIndex, currentEventId, flush, flushDepsOf, flushWaiters, hasWaiters, inTransaction, rootEvent, waiterObs, waiters, whenDoneWith, wrappedSubscribe;
	    rootEvent = void 0;
	    waiterObs = [];
	    waiters = {};
	    afters = [];
	    aftersIndex = 0;
	    afterTransaction = function(f) {
	      if (rootEvent) {
	        return afters.push(f);
	      } else {
	        return f();
	      }
	    };
	    whenDoneWith = function(obs, f) {
	      var obsWaiters;
	      if (rootEvent) {
	        obsWaiters = waiters[obs.id];
	        if (obsWaiters == null) {
	          obsWaiters = waiters[obs.id] = [f];
	          return waiterObs.push(obs);
	        } else {
	          return obsWaiters.push(f);
	        }
	      } else {
	        return f();
	      }
	    };
	    flush = function() {
	      while (waiterObs.length > 0) {
	        flushWaiters(0);
	      }
	      return void 0;
	    };
	    flushWaiters = function(index) {
	      var f, j, len1, obs, obsId, obsWaiters;
	      obs = waiterObs[index];
	      obsId = obs.id;
	      obsWaiters = waiters[obsId];
	      waiterObs.splice(index, 1);
	      delete waiters[obsId];
	      flushDepsOf(obs);
	      for (j = 0, len1 = obsWaiters.length; j < len1; j++) {
	        f = obsWaiters[j];
	        f();
	      }
	      return void 0;
	    };
	    flushDepsOf = function(obs) {
	      var dep, deps, index, j, len1;
	      deps = obs.internalDeps();
	      for (j = 0, len1 = deps.length; j < len1; j++) {
	        dep = deps[j];
	        flushDepsOf(dep);
	        if (waiters[dep.id]) {
	          index = _.indexOf(waiterObs, dep);
	          flushWaiters(index);
	        }
	      }
	      return void 0;
	    };
	    inTransaction = function(event, context, f, args) {
	      var after, result;
	      if (rootEvent) {
	        return f.apply(context, args);
	      } else {
	        rootEvent = event;
	        try {
	          result = f.apply(context, args);
	          flush();
	        } finally {
	          rootEvent = void 0;
	          while (aftersIndex < afters.length) {
	            after = afters[aftersIndex];
	            aftersIndex++;
	            after();
	          }
	          aftersIndex = 0;
	          afters = [];
	        }
	        return result;
	      }
	    };
	    currentEventId = function() {
	      if (rootEvent) {
	        return rootEvent.id;
	      } else {
	        return void 0;
	      }
	    };
	    wrappedSubscribe = function(obs, sink) {
	      var doUnsub, shouldUnsub, unsub, unsubd;
	      unsubd = false;
	      shouldUnsub = false;
	      doUnsub = function() {
	        return shouldUnsub = true;
	      };
	      unsub = function() {
	        unsubd = true;
	        return doUnsub();
	      };
	      doUnsub = obs.dispatcher.subscribe(function(event) {
	        return afterTransaction(function() {
	          var reply;
	          if (!unsubd) {
	            reply = sink(event);
	            if (reply === Bacon.noMore) {
	              return unsub();
	            }
	          }
	        });
	      });
	      if (shouldUnsub) {
	        doUnsub();
	      }
	      return unsub;
	    };
	    hasWaiters = function() {
	      return waiterObs.length > 0;
	    };
	    return {
	      whenDoneWith: whenDoneWith,
	      hasWaiters: hasWaiters,
	      inTransaction: inTransaction,
	      currentEventId: currentEventId,
	      wrappedSubscribe: wrappedSubscribe,
	      afterTransaction: afterTransaction
	    };
	  })();
	
	  Source = (function() {
	    function Source(obs1, sync, lazy1) {
	      this.obs = obs1;
	      this.sync = sync;
	      this.lazy = lazy1 != null ? lazy1 : false;
	      this.queue = [];
	    }
	
	    Source.prototype.subscribe = function(sink) {
	      return this.obs.dispatcher.subscribe(sink);
	    };
	
	    Source.prototype.toString = function() {
	      return this.obs.toString();
	    };
	
	    Source.prototype.markEnded = function() {
	      return this.ended = true;
	    };
	
	    Source.prototype.consume = function() {
	      if (this.lazy) {
	        return {
	          value: _.always(this.queue[0])
	        };
	      } else {
	        return this.queue[0];
	      }
	    };
	
	    Source.prototype.push = function(x) {
	      return this.queue = [x];
	    };
	
	    Source.prototype.mayHave = function() {
	      return true;
	    };
	
	    Source.prototype.hasAtLeast = function() {
	      return this.queue.length;
	    };
	
	    Source.prototype.flatten = true;
	
	    return Source;
	
	  })();
	
	  ConsumingSource = (function(superClass) {
	    extend(ConsumingSource, superClass);
	
	    function ConsumingSource() {
	      return ConsumingSource.__super__.constructor.apply(this, arguments);
	    }
	
	    ConsumingSource.prototype.consume = function() {
	      return this.queue.shift();
	    };
	
	    ConsumingSource.prototype.push = function(x) {
	      return this.queue.push(x);
	    };
	
	    ConsumingSource.prototype.mayHave = function(c) {
	      return !this.ended || this.queue.length >= c;
	    };
	
	    ConsumingSource.prototype.hasAtLeast = function(c) {
	      return this.queue.length >= c;
	    };
	
	    ConsumingSource.prototype.flatten = false;
	
	    return ConsumingSource;
	
	  })(Source);
	
	  BufferingSource = (function(superClass) {
	    extend(BufferingSource, superClass);
	
	    function BufferingSource(obs) {
	      BufferingSource.__super__.constructor.call(this, obs, true);
	    }
	
	    BufferingSource.prototype.consume = function() {
	      var values;
	      values = this.queue;
	      this.queue = [];
	      return {
	        value: function() {
	          return values;
	        }
	      };
	    };
	
	    BufferingSource.prototype.push = function(x) {
	      return this.queue.push(x.value());
	    };
	
	    BufferingSource.prototype.hasAtLeast = function() {
	      return true;
	    };
	
	    return BufferingSource;
	
	  })(Source);
	
	  Source.isTrigger = function(s) {
	    if (s instanceof Source) {
	      return s.sync;
	    } else {
	      return s instanceof EventStream;
	    }
	  };
	
	  Source.fromObservable = function(s) {
	    if (s instanceof Source) {
	      return s;
	    } else if (s instanceof Property) {
	      return new Source(s, false);
	    } else {
	      return new ConsumingSource(s, true);
	    }
	  };
	
	  Desc = (function() {
	    function Desc(context1, method1, args1) {
	      this.context = context1;
	      this.method = method1;
	      this.args = args1;
	      this.cached = void 0;
	    }
	
	    Desc.prototype.deps = function() {
	      return this.cached || (this.cached = findDeps([this.context].concat(this.args)));
	    };
	
	    Desc.prototype.apply = function(obs) {
	      obs.desc = this;
	      return obs;
	    };
	
	    Desc.prototype.toString = function() {
	      return _.toString(this.context) + "." + _.toString(this.method) + "(" + _.map(_.toString, this.args) + ")";
	    };
	
	    return Desc;
	
	  })();
	
	  describe = function() {
	    var args, context, method;
	    context = arguments[0], method = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
	    if ((context || method) instanceof Desc) {
	      return context || method;
	    } else {
	      return new Desc(context, method, args);
	    }
	  };
	
	  withDescription = function() {
	    var desc, j, obs;
	    desc = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), obs = arguments[j++];
	    return describe.apply(null, desc).apply(obs);
	  };
	
	  findDeps = function(x) {
	    if (isArray(x)) {
	      return _.flatMap(findDeps, x);
	    } else if (isObservable(x)) {
	      return [x];
	    } else if (x instanceof Source) {
	      return [x.obs];
	    } else {
	      return [];
	    }
	  };
	
	  withMethodCallSupport = function(wrapped) {
	    return function() {
	      var args, context, f, methodName;
	      f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	      if (typeof f === "object" && args.length) {
	        context = f;
	        methodName = args[0];
	        f = function() {
	          return context[methodName].apply(context, arguments);
	        };
	        args = args.slice(1);
	      }
	      return wrapped.apply(null, [f].concat(slice.call(args)));
	    };
	  };
	
	  makeFunctionArgs = function(args) {
	    args = Array.prototype.slice.call(args);
	    return makeFunction_.apply(null, args);
	  };
	
	  partiallyApplied = function(f, applied) {
	    return function() {
	      var args;
	      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	      return f.apply(null, applied.concat(args));
	    };
	  };
	
	  toSimpleExtractor = function(args) {
	    return function(key) {
	      return function(value) {
	        var fieldValue;
	        if (value == null) {
	          return void 0;
	        } else {
	          fieldValue = value[key];
	          if (_.isFunction(fieldValue)) {
	            return fieldValue.apply(value, args);
	          } else {
	            return fieldValue;
	          }
	        }
	      };
	    };
	  };
	
	  toFieldExtractor = function(f, args) {
	    var partFuncs, parts;
	    parts = f.slice(1).split(".");
	    partFuncs = _.map(toSimpleExtractor(args), parts);
	    return function(value) {
	      var j, len1;
	      for (j = 0, len1 = partFuncs.length; j < len1; j++) {
	        f = partFuncs[j];
	        value = f(value);
	      }
	      return value;
	    };
	  };
	
	  isFieldKey = function(f) {
	    return (typeof f === "string") && f.length > 1 && f.charAt(0) === ".";
	  };
	
	  makeFunction_ = withMethodCallSupport(function() {
	    var args, f;
	    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (_.isFunction(f)) {
	      if (args.length) {
	        return partiallyApplied(f, args);
	      } else {
	        return f;
	      }
	    } else if (isFieldKey(f)) {
	      return toFieldExtractor(f, args);
	    } else {
	      return _.always(f);
	    }
	  });
	
	  makeFunction = function(f, args) {
	    return makeFunction_.apply(null, [f].concat(slice.call(args)));
	  };
	
	  convertArgsToFunction = function(obs, f, args, method) {
	    var sampled;
	    if (f instanceof Property) {
	      sampled = f.sampledBy(obs, function(p, s) {
	        return [p, s];
	      });
	      return method.call(sampled, function(arg) {
	        var p, s;
	        p = arg[0], s = arg[1];
	        return p;
	      }).map(function(arg) {
	        var p, s;
	        p = arg[0], s = arg[1];
	        return s;
	      });
	    } else {
	      f = makeFunction(f, args);
	      return method.call(obs, f);
	    }
	  };
	
	  toCombinator = function(f) {
	    var key;
	    if (_.isFunction(f)) {
	      return f;
	    } else if (isFieldKey(f)) {
	      key = toFieldKey(f);
	      return function(left, right) {
	        return left[key](right);
	      };
	    } else {
	      throw new Exception("not a function or a field key: " + f);
	    }
	  };
	
	  toFieldKey = function(f) {
	    return f.slice(1);
	  };
	
	  Some = (function() {
	    function Some(value1) {
	      this.value = value1;
	    }
	
	    Some.prototype.getOrElse = function() {
	      return this.value;
	    };
	
	    Some.prototype.get = function() {
	      return this.value;
	    };
	
	    Some.prototype.filter = function(f) {
	      if (f(this.value)) {
	        return new Some(this.value);
	      } else {
	        return None;
	      }
	    };
	
	    Some.prototype.map = function(f) {
	      return new Some(f(this.value));
	    };
	
	    Some.prototype.forEach = function(f) {
	      return f(this.value);
	    };
	
	    Some.prototype.isDefined = true;
	
	    Some.prototype.toArray = function() {
	      return [this.value];
	    };
	
	    Some.prototype.inspect = function() {
	      return "Some(" + this.value + ")";
	    };
	
	    Some.prototype.toString = function() {
	      return this.inspect();
	    };
	
	    return Some;
	
	  })();
	
	  None = {
	    getOrElse: function(value) {
	      return value;
	    },
	    filter: function() {
	      return None;
	    },
	    map: function() {
	      return None;
	    },
	    forEach: function() {},
	    isDefined: false,
	    toArray: function() {
	      return [];
	    },
	    inspect: function() {
	      return "None";
	    },
	    toString: function() {
	      return this.inspect();
	    }
	  };
	
	  toOption = function(v) {
	    if (v instanceof Some || v === None) {
	      return v;
	    } else {
	      return new Some(v);
	    }
	  };
	
	  Bacon.noMore = ["<no-more>"];
	
	  Bacon.more = ["<more>"];
	
	  eventIdCounter = 0;
	
	  Event = (function() {
	    function Event() {
	      this.id = ++eventIdCounter;
	    }
	
	    Event.prototype.isEvent = function() {
	      return true;
	    };
	
	    Event.prototype.isEnd = function() {
	      return false;
	    };
	
	    Event.prototype.isInitial = function() {
	      return false;
	    };
	
	    Event.prototype.isNext = function() {
	      return false;
	    };
	
	    Event.prototype.isError = function() {
	      return false;
	    };
	
	    Event.prototype.hasValue = function() {
	      return false;
	    };
	
	    Event.prototype.filter = function() {
	      return true;
	    };
	
	    Event.prototype.inspect = function() {
	      return this.toString();
	    };
	
	    Event.prototype.log = function() {
	      return this.toString();
	    };
	
	    return Event;
	
	  })();
	
	  Next = (function(superClass) {
	    extend(Next, superClass);
	
	    function Next(valueF, eager) {
	      Next.__super__.constructor.call(this);
	      if (!eager && _.isFunction(valueF) || valueF instanceof Next) {
	        this.valueF = valueF;
	        this.valueInternal = void 0;
	      } else {
	        this.valueF = void 0;
	        this.valueInternal = valueF;
	      }
	    }
	
	    Next.prototype.isNext = function() {
	      return true;
	    };
	
	    Next.prototype.hasValue = function() {
	      return true;
	    };
	
	    Next.prototype.value = function() {
	      if (this.valueF instanceof Next) {
	        this.valueInternal = this.valueF.value();
	        this.valueF = void 0;
	      } else if (this.valueF) {
	        this.valueInternal = this.valueF();
	        this.valueF = void 0;
	      }
	      return this.valueInternal;
	    };
	
	    Next.prototype.fmap = function(f) {
	      var event, value;
	      if (this.valueInternal) {
	        value = this.valueInternal;
	        return this.apply(function() {
	          return f(value);
	        });
	      } else {
	        event = this;
	        return this.apply(function() {
	          return f(event.value());
	        });
	      }
	    };
	
	    Next.prototype.apply = function(value) {
	      return new Next(value);
	    };
	
	    Next.prototype.filter = function(f) {
	      return f(this.value());
	    };
	
	    Next.prototype.toString = function() {
	      return _.toString(this.value());
	    };
	
	    Next.prototype.log = function() {
	      return this.value();
	    };
	
	    return Next;
	
	  })(Event);
	
	  Initial = (function(superClass) {
	    extend(Initial, superClass);
	
	    function Initial() {
	      return Initial.__super__.constructor.apply(this, arguments);
	    }
	
	    Initial.prototype.isInitial = function() {
	      return true;
	    };
	
	    Initial.prototype.isNext = function() {
	      return false;
	    };
	
	    Initial.prototype.apply = function(value) {
	      return new Initial(value);
	    };
	
	    Initial.prototype.toNext = function() {
	      return new Next(this);
	    };
	
	    return Initial;
	
	  })(Next);
	
	  End = (function(superClass) {
	    extend(End, superClass);
	
	    function End() {
	      return End.__super__.constructor.apply(this, arguments);
	    }
	
	    End.prototype.isEnd = function() {
	      return true;
	    };
	
	    End.prototype.fmap = function() {
	      return this;
	    };
	
	    End.prototype.apply = function() {
	      return this;
	    };
	
	    End.prototype.toString = function() {
	      return "<end>";
	    };
	
	    return End;
	
	  })(Event);
	
	  Error = (function(superClass) {
	    extend(Error, superClass);
	
	    function Error(error1) {
	      this.error = error1;
	    }
	
	    Error.prototype.isError = function() {
	      return true;
	    };
	
	    Error.prototype.fmap = function() {
	      return this;
	    };
	
	    Error.prototype.apply = function() {
	      return this;
	    };
	
	    Error.prototype.toString = function() {
	      return "<error> " + _.toString(this.error);
	    };
	
	    return Error;
	
	  })(Event);
	
	  Bacon.Event = Event;
	
	  Bacon.Initial = Initial;
	
	  Bacon.Next = Next;
	
	  Bacon.End = End;
	
	  Bacon.Error = Error;
	
	  initialEvent = function(value) {
	    return new Initial(value, true);
	  };
	
	  nextEvent = function(value) {
	    return new Next(value, true);
	  };
	
	  endEvent = function() {
	    return new End();
	  };
	
	  toEvent = function(x) {
	    if (x instanceof Event) {
	      return x;
	    } else {
	      return nextEvent(x);
	    }
	  };
	
	  idCounter = 0;
	
	  registerObs = function() {};
	
	  Observable = (function() {
	    function Observable(desc) {
	      this.id = ++idCounter;
	      withDescription(desc, this);
	      this.initialDesc = this.desc;
	    }
	
	    Observable.prototype.subscribe = function(sink) {
	      return UpdateBarrier.wrappedSubscribe(this, sink);
	    };
	
	    Observable.prototype.subscribeInternal = function(sink) {
	      return this.dispatcher.subscribe(sink);
	    };
	
	    Observable.prototype.onValue = function() {
	      var f;
	      f = makeFunctionArgs(arguments);
	      return this.subscribe(function(event) {
	        if (event.hasValue()) {
	          return f(event.value());
	        }
	      });
	    };
	
	    Observable.prototype.onValues = function(f) {
	      return this.onValue(function(args) {
	        return f.apply(null, args);
	      });
	    };
	
	    Observable.prototype.onError = function() {
	      var f;
	      f = makeFunctionArgs(arguments);
	      return this.subscribe(function(event) {
	        if (event.isError()) {
	          return f(event.error);
	        }
	      });
	    };
	
	    Observable.prototype.onEnd = function() {
	      var f;
	      f = makeFunctionArgs(arguments);
	      return this.subscribe(function(event) {
	        if (event.isEnd()) {
	          return f();
	        }
	      });
	    };
	
	    Observable.prototype.name = function(name) {
	      this._name = name;
	      return this;
	    };
	
	    Observable.prototype.withDescription = function() {
	      return describe.apply(null, arguments).apply(this);
	    };
	
	    Observable.prototype.toString = function() {
	      if (this._name) {
	        return this._name;
	      } else {
	        return this.desc.toString();
	      }
	    };
	
	    Observable.prototype.internalDeps = function() {
	      return this.initialDesc.deps();
	    };
	
	    return Observable;
	
	  })();
	
	  Observable.prototype.assign = Observable.prototype.onValue;
	
	  Observable.prototype.forEach = Observable.prototype.onValue;
	
	  Observable.prototype.inspect = Observable.prototype.toString;
	
	  Bacon.Observable = Observable;
	
	  CompositeUnsubscribe = (function() {
	    function CompositeUnsubscribe(ss) {
	      var j, len1, s;
	      if (ss == null) {
	        ss = [];
	      }
	      this.unsubscribe = bind(this.unsubscribe, this);
	      this.unsubscribed = false;
	      this.subscriptions = [];
	      this.starting = [];
	      for (j = 0, len1 = ss.length; j < len1; j++) {
	        s = ss[j];
	        this.add(s);
	      }
	    }
	
	    CompositeUnsubscribe.prototype.add = function(subscription) {
	      var ended, unsub, unsubMe;
	      if (this.unsubscribed) {
	        return;
	      }
	      ended = false;
	      unsub = nop;
	      this.starting.push(subscription);
	      unsubMe = (function(_this) {
	        return function() {
	          if (_this.unsubscribed) {
	            return;
	          }
	          ended = true;
	          _this.remove(unsub);
	          return _.remove(subscription, _this.starting);
	        };
	      })(this);
	      unsub = subscription(this.unsubscribe, unsubMe);
	      if (!(this.unsubscribed || ended)) {
	        this.subscriptions.push(unsub);
	      } else {
	        unsub();
	      }
	      _.remove(subscription, this.starting);
	      return unsub;
	    };
	
	    CompositeUnsubscribe.prototype.remove = function(unsub) {
	      if (this.unsubscribed) {
	        return;
	      }
	      if ((_.remove(unsub, this.subscriptions)) !== void 0) {
	        return unsub();
	      }
	    };
	
	    CompositeUnsubscribe.prototype.unsubscribe = function() {
	      var j, len1, ref, s;
	      if (this.unsubscribed) {
	        return;
	      }
	      this.unsubscribed = true;
	      ref = this.subscriptions;
	      for (j = 0, len1 = ref.length; j < len1; j++) {
	        s = ref[j];
	        s();
	      }
	      this.subscriptions = [];
	      return this.starting = [];
	    };
	
	    CompositeUnsubscribe.prototype.count = function() {
	      if (this.unsubscribed) {
	        return 0;
	      }
	      return this.subscriptions.length + this.starting.length;
	    };
	
	    CompositeUnsubscribe.prototype.empty = function() {
	      return this.count() === 0;
	    };
	
	    return CompositeUnsubscribe;
	
	  })();
	
	  Bacon.CompositeUnsubscribe = CompositeUnsubscribe;
	
	  Dispatcher = (function() {
	    function Dispatcher(_subscribe, _handleEvent) {
	      this._subscribe = _subscribe;
	      this._handleEvent = _handleEvent;
	      this.subscribe = bind(this.subscribe, this);
	      this.handleEvent = bind(this.handleEvent, this);
	      this.subscriptions = [];
	      this.queue = [];
	      this.pushing = false;
	      this.ended = false;
	      this.prevError = void 0;
	      this.unsubSrc = void 0;
	    }
	
	    Dispatcher.prototype.hasSubscribers = function() {
	      return this.subscriptions.length > 0;
	    };
	
	    Dispatcher.prototype.removeSub = function(subscription) {
	      return this.subscriptions = _.without(subscription, this.subscriptions);
	    };
	
	    Dispatcher.prototype.push = function(event) {
	      if (event.isEnd()) {
	        this.ended = true;
	      }
	      return UpdateBarrier.inTransaction(event, this, this.pushIt, [event]);
	    };
	
	    Dispatcher.prototype.pushToSubscriptions = function(event) {
	      var e, j, len1, reply, sub, tmp;
	      try {
	        tmp = this.subscriptions;
	        for (j = 0, len1 = tmp.length; j < len1; j++) {
	          sub = tmp[j];
	          reply = sub.sink(event);
	          if (reply === Bacon.noMore || event.isEnd()) {
	            this.removeSub(sub);
	          }
	        }
	        return true;
	      } catch (_error) {
	        e = _error;
	        this.pushing = false;
	        this.queue = [];
	        throw e;
	      }
	    };
	
	    Dispatcher.prototype.pushIt = function(event) {
	      if (!this.pushing) {
	        if (event === this.prevError) {
	          return;
	        }
	        if (event.isError()) {
	          this.prevError = event;
	        }
	        this.pushing = true;
	        this.pushToSubscriptions(event);
	        this.pushing = false;
	        while (this.queue.length) {
	          event = this.queue.shift();
	          this.push(event);
	        }
	        if (this.hasSubscribers()) {
	          return Bacon.more;
	        } else {
	          this.unsubscribeFromSource();
	          return Bacon.noMore;
	        }
	      } else {
	        this.queue.push(event);
	        return Bacon.more;
	      }
	    };
	
	    Dispatcher.prototype.handleEvent = function(event) {
	      if (this._handleEvent) {
	        return this._handleEvent(event);
	      } else {
	        return this.push(event);
	      }
	    };
	
	    Dispatcher.prototype.unsubscribeFromSource = function() {
	      if (this.unsubSrc) {
	        this.unsubSrc();
	      }
	      return this.unsubSrc = void 0;
	    };
	
	    Dispatcher.prototype.subscribe = function(sink) {
	      var subscription;
	      if (this.ended) {
	        sink(endEvent());
	        return nop;
	      } else {
	        assertFunction(sink);
	        subscription = {
	          sink: sink
	        };
	        this.subscriptions.push(subscription);
	        if (this.subscriptions.length === 1) {
	          this.unsubSrc = this._subscribe(this.handleEvent);
	          assertFunction(this.unsubSrc);
	        }
	        return (function(_this) {
	          return function() {
	            _this.removeSub(subscription);
	            if (!_this.hasSubscribers()) {
	              return _this.unsubscribeFromSource();
	            }
	          };
	        })(this);
	      }
	    };
	
	    return Dispatcher;
	
	  })();
	
	  EventStream = (function(superClass) {
	    extend(EventStream, superClass);
	
	    function EventStream(desc, subscribe, handler) {
	      if (_.isFunction(desc)) {
	        handler = subscribe;
	        subscribe = desc;
	        desc = [];
	      }
	      EventStream.__super__.constructor.call(this, desc);
	      assertFunction(subscribe);
	      this.dispatcher = new Dispatcher(subscribe, handler);
	      registerObs(this);
	    }
	
	    EventStream.prototype.toProperty = function(initValue_) {
	      var disp, initValue;
	      initValue = arguments.length === 0 ? None : toOption(function() {
	        return initValue_;
	      });
	      disp = this.dispatcher;
	      return new Property(describe(this, "toProperty", initValue_), function(sink) {
	        var initSent, reply, sendInit, unsub;
	        initSent = false;
	        unsub = nop;
	        reply = Bacon.more;
	        sendInit = function() {
	          if (!initSent) {
	            return initValue.forEach(function(value) {
	              initSent = true;
	              reply = sink(new Initial(value));
	              if (reply === Bacon.noMore) {
	                unsub();
	                return unsub = nop;
	              }
	            });
	          }
	        };
	        unsub = disp.subscribe(function(event) {
	          if (event.hasValue()) {
	            if (initSent && event.isInitial()) {
	              return Bacon.more;
	            } else {
	              if (!event.isInitial()) {
	                sendInit();
	              }
	              initSent = true;
	              initValue = new Some(event);
	              return sink(event);
	            }
	          } else {
	            if (event.isEnd()) {
	              reply = sendInit();
	            }
	            if (reply !== Bacon.noMore) {
	              return sink(event);
	            }
	          }
	        });
	        sendInit();
	        return unsub;
	      });
	    };
	
	    EventStream.prototype.toEventStream = function() {
	      return this;
	    };
	
	    EventStream.prototype.withHandler = function(handler) {
	      return new EventStream(describe(this, "withHandler", handler), this.dispatcher.subscribe, handler);
	    };
	
	    return EventStream;
	
	  })(Observable);
	
	  Bacon.EventStream = EventStream;
	
	  Bacon.never = function() {
	    return new EventStream(describe(Bacon, "never"), function(sink) {
	      sink(endEvent());
	      return nop;
	    });
	  };
	
	  Bacon.when = function() {
	    var f, i, index, ix, j, k, len, len1, len2, needsBarrier, pat, patSources, pats, patterns, ref, resultStream, s, sources, triggerFound, usage;
	    if (arguments.length === 0) {
	      return Bacon.never();
	    }
	    len = arguments.length;
	    usage = "when: expecting arguments in the form (Observable+,function)+";
	    assert(usage, len % 2 === 0);
	    sources = [];
	    pats = [];
	    i = 0;
	    patterns = [];
	    while (i < len) {
	      patterns[i] = arguments[i];
	      patterns[i + 1] = arguments[i + 1];
	      patSources = _.toArray(arguments[i]);
	      f = constantToFunction(arguments[i + 1]);
	      pat = {
	        f: f,
	        ixs: []
	      };
	      triggerFound = false;
	      for (j = 0, len1 = patSources.length; j < len1; j++) {
	        s = patSources[j];
	        index = _.indexOf(sources, s);
	        if (!triggerFound) {
	          triggerFound = Source.isTrigger(s);
	        }
	        if (index < 0) {
	          sources.push(s);
	          index = sources.length - 1;
	        }
	        ref = pat.ixs;
	        for (k = 0, len2 = ref.length; k < len2; k++) {
	          ix = ref[k];
	          if (ix.index === index) {
	            ix.count++;
	          }
	        }
	        pat.ixs.push({
	          index: index,
	          count: 1
	        });
	      }
	      assert("At least one EventStream required", triggerFound || (!patSources.length));
	      if (patSources.length > 0) {
	        pats.push(pat);
	      }
	      i = i + 2;
	    }
	    if (!sources.length) {
	      return Bacon.never();
	    }
	    sources = _.map(Source.fromObservable, sources);
	    needsBarrier = (_.any(sources, function(s) {
	      return s.flatten;
	    })) && (containsDuplicateDeps(_.map((function(s) {
	      return s.obs;
	    }), sources)));
	    return resultStream = new EventStream(describe.apply(null, [Bacon, "when"].concat(slice.call(patterns))), function(sink) {
	      var cannotMatch, cannotSync, ends, match, nonFlattened, part, triggers;
	      triggers = [];
	      ends = false;
	      match = function(p) {
	        var l, len3, ref1;
	        ref1 = p.ixs;
	        for (l = 0, len3 = ref1.length; l < len3; l++) {
	          i = ref1[l];
	          if (!sources[i.index].hasAtLeast(i.count)) {
	            return false;
	          }
	        }
	        return true;
	      };
	      cannotSync = function(source) {
	        return !source.sync || source.ended;
	      };
	      cannotMatch = function(p) {
	        var l, len3, ref1;
	        ref1 = p.ixs;
	        for (l = 0, len3 = ref1.length; l < len3; l++) {
	          i = ref1[l];
	          if (!sources[i.index].mayHave(i.count)) {
	            return true;
	          }
	        }
	      };
	      nonFlattened = function(trigger) {
	        return !trigger.source.flatten;
	      };
	      part = function(source) {
	        return function(unsubAll) {
	          var flush, flushLater, flushWhileTriggers;
	          flushLater = function() {
	            return UpdateBarrier.whenDoneWith(resultStream, flush);
	          };
	          flushWhileTriggers = function() {
	            var events, l, len3, p, reply, trigger;
	            if (triggers.length > 0) {
	              reply = Bacon.more;
	              trigger = triggers.pop();
	              for (l = 0, len3 = pats.length; l < len3; l++) {
	                p = pats[l];
	                if (match(p)) {
	                  events = (function() {
	                    var len4, m, ref1, results;
	                    ref1 = p.ixs;
	                    results = [];
	                    for (m = 0, len4 = ref1.length; m < len4; m++) {
	                      i = ref1[m];
	                      results.push(sources[i.index].consume());
	                    }
	                    return results;
	                  })();
	                  reply = sink(trigger.e.apply(function() {
	                    var event, values;
	                    values = (function() {
	                      var len4, m, results;
	                      results = [];
	                      for (m = 0, len4 = events.length; m < len4; m++) {
	                        event = events[m];
	                        results.push(event.value());
	                      }
	                      return results;
	                    })();
	                    return p.f.apply(p, values);
	                  }));
	                  if (triggers.length) {
	                    triggers = _.filter(nonFlattened, triggers);
	                  }
	                  if (reply === Bacon.noMore) {
	                    return reply;
	                  } else {
	                    return flushWhileTriggers();
	                  }
	                }
	              }
	            } else {
	              return Bacon.more;
	            }
	          };
	          flush = function() {
	            var reply;
	            reply = flushWhileTriggers();
	            if (ends) {
	              ends = false;
	              if (_.all(sources, cannotSync) || _.all(pats, cannotMatch)) {
	                reply = Bacon.noMore;
	                sink(endEvent());
	              }
	            }
	            if (reply === Bacon.noMore) {
	              unsubAll();
	            }
	            return reply;
	          };
	          return source.subscribe(function(e) {
	            var reply;
	            if (e.isEnd()) {
	              ends = true;
	              source.markEnded();
	              flushLater();
	            } else if (e.isError()) {
	              reply = sink(e);
	            } else {
	              source.push(e);
	              if (source.sync) {
	                triggers.push({
	                  source: source,
	                  e: e
	                });
	                if (needsBarrier || UpdateBarrier.hasWaiters()) {
	                  flushLater();
	                } else {
	                  flush();
	                }
	              }
	            }
	            if (reply === Bacon.noMore) {
	              unsubAll();
	            }
	            return reply || Bacon.more;
	          });
	        };
	      };
	      return new Bacon.CompositeUnsubscribe((function() {
	        var l, len3, results;
	        results = [];
	        for (l = 0, len3 = sources.length; l < len3; l++) {
	          s = sources[l];
	          results.push(part(s));
	        }
	        return results;
	      })()).unsubscribe;
	    });
	  };
	
	  containsDuplicateDeps = function(observables, state) {
	    var checkObservable;
	    if (state == null) {
	      state = [];
	    }
	    checkObservable = function(obs) {
	      var deps;
	      if (_.contains(state, obs)) {
	        return true;
	      } else {
	        deps = obs.internalDeps();
	        if (deps.length) {
	          state.push(obs);
	          return _.any(deps, checkObservable);
	        } else {
	          state.push(obs);
	          return false;
	        }
	      }
	    };
	    return _.any(observables, checkObservable);
	  };
	
	  constantToFunction = function(f) {
	    if (_.isFunction(f)) {
	      return f;
	    } else {
	      return _.always(f);
	    }
	  };
	
	  Bacon.groupSimultaneous = function() {
	    var s, sources, streams;
	    streams = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    if (streams.length === 1 && isArray(streams[0])) {
	      streams = streams[0];
	    }
	    sources = (function() {
	      var j, len1, results;
	      results = [];
	      for (j = 0, len1 = streams.length; j < len1; j++) {
	        s = streams[j];
	        results.push(new BufferingSource(s));
	      }
	      return results;
	    })();
	    return withDescription.apply(null, [Bacon, "groupSimultaneous"].concat(slice.call(streams), [Bacon.when(sources, (function() {
	      var xs;
	      xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	      return xs;
	    }))]));
	  };
	
	  PropertyDispatcher = (function(superClass) {
	    extend(PropertyDispatcher, superClass);
	
	    function PropertyDispatcher(property1, subscribe, handleEvent) {
	      this.property = property1;
	      this.subscribe = bind(this.subscribe, this);
	      PropertyDispatcher.__super__.constructor.call(this, subscribe, handleEvent);
	      this.current = None;
	      this.currentValueRootId = void 0;
	      this.propertyEnded = false;
	    }
	
	    PropertyDispatcher.prototype.push = function(event) {
	      if (event.isEnd()) {
	        this.propertyEnded = true;
	      }
	      if (event.hasValue()) {
	        this.current = new Some(event);
	        this.currentValueRootId = UpdateBarrier.currentEventId();
	      }
	      return PropertyDispatcher.__super__.push.call(this, event);
	    };
	
	    PropertyDispatcher.prototype.maybeSubSource = function(sink, reply) {
	      if (reply === Bacon.noMore) {
	        return nop;
	      } else if (this.propertyEnded) {
	        sink(endEvent());
	        return nop;
	      } else {
	        return Dispatcher.prototype.subscribe.call(this, sink);
	      }
	    };
	
	    PropertyDispatcher.prototype.subscribe = function(sink) {
	      var dispatchingId, initSent, reply, valId;
	      initSent = false;
	      reply = Bacon.more;
	      if (this.current.isDefined && (this.hasSubscribers() || this.propertyEnded)) {
	        dispatchingId = UpdateBarrier.currentEventId();
	        valId = this.currentValueRootId;
	        if (!this.propertyEnded && valId && dispatchingId && dispatchingId !== valId) {
	          UpdateBarrier.whenDoneWith(this.property, (function(_this) {
	            return function() {
	              if (_this.currentValueRootId === valId) {
	                return sink(initialEvent(_this.current.get().value()));
	              }
	            };
	          })(this));
	          return this.maybeSubSource(sink, reply);
	        } else {
	          UpdateBarrier.inTransaction(void 0, this, (function() {
	            return reply = sink(initialEvent(this.current.get().value()));
	          }), []);
	          return this.maybeSubSource(sink, reply);
	        }
	      } else {
	        return this.maybeSubSource(sink, reply);
	      }
	    };
	
	    return PropertyDispatcher;
	
	  })(Dispatcher);
	
	  Property = (function(superClass) {
	    extend(Property, superClass);
	
	    function Property(desc, subscribe, handler) {
	      if (_.isFunction(desc)) {
	        handler = subscribe;
	        subscribe = desc;
	        desc = [];
	      }
	      Property.__super__.constructor.call(this, desc);
	      assertFunction(subscribe);
	      this.dispatcher = new PropertyDispatcher(this, subscribe, handler);
	      registerObs(this);
	    }
	
	    Property.prototype.changes = function() {
	      return new EventStream(describe(this, "changes"), (function(_this) {
	        return function(sink) {
	          return _this.dispatcher.subscribe(function(event) {
	            if (!event.isInitial()) {
	              return sink(event);
	            }
	          });
	        };
	      })(this));
	    };
	
	    Property.prototype.withHandler = function(handler) {
	      return new Property(describe(this, "withHandler", handler), this.dispatcher.subscribe, handler);
	    };
	
	    Property.prototype.toProperty = function() {
	      assertNoArguments(arguments);
	      return this;
	    };
	
	    Property.prototype.toEventStream = function() {
	      return new EventStream(describe(this, "toEventStream"), (function(_this) {
	        return function(sink) {
	          return _this.dispatcher.subscribe(function(event) {
	            if (event.isInitial()) {
	              event = event.toNext();
	            }
	            return sink(event);
	          });
	        };
	      })(this));
	    };
	
	    return Property;
	
	  })(Observable);
	
	  Bacon.Property = Property;
	
	  Bacon.constant = function(value) {
	    return new Property(describe(Bacon, "constant", value), function(sink) {
	      sink(initialEvent(value));
	      sink(endEvent());
	      return nop;
	    });
	  };
	
	  Bacon.fromBinder = function(binder, eventTransformer) {
	    if (eventTransformer == null) {
	      eventTransformer = _.id;
	    }
	    return new EventStream(describe(Bacon, "fromBinder", binder, eventTransformer), function(sink) {
	      var shouldUnbind, unbind, unbinder, unbound;
	      unbound = false;
	      shouldUnbind = false;
	      unbind = function() {
	        if (!unbound) {
	          if (typeof unbinder !== "undefined" && unbinder !== null) {
	            unbinder();
	            return unbound = true;
	          } else {
	            return shouldUnbind = true;
	          }
	        }
	      };
	      unbinder = binder(function() {
	        var args, event, j, len1, reply, value;
	        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	        value = eventTransformer.apply(this, args);
	        if (!(isArray(value) && _.last(value) instanceof Event)) {
	          value = [value];
	        }
	        reply = Bacon.more;
	        for (j = 0, len1 = value.length; j < len1; j++) {
	          event = value[j];
	          reply = sink(event = toEvent(event));
	          if (reply === Bacon.noMore || event.isEnd()) {
	            unbind();
	            return reply;
	          }
	        }
	        return reply;
	      });
	      if (shouldUnbind) {
	        unbind();
	      }
	      return unbind;
	    });
	  };
	
	  eventMethods = [["addEventListener", "removeEventListener"], ["addListener", "removeListener"], ["on", "off"], ["bind", "unbind"]];
	
	  findHandlerMethods = function(target) {
	    var j, len1, methodPair, pair;
	    for (j = 0, len1 = eventMethods.length; j < len1; j++) {
	      pair = eventMethods[j];
	      methodPair = [target[pair[0]], target[pair[1]]];
	      if (methodPair[0] && methodPair[1]) {
	        return methodPair;
	      }
	    }
	    throw new Error("No suitable event methods in " + target);
	  };
	
	  Bacon.fromEventTarget = function(target, eventName, eventTransformer) {
	    var ref, sub, unsub;
	    ref = findHandlerMethods(target), sub = ref[0], unsub = ref[1];
	    return withDescription(Bacon, "fromEvent", target, eventName, Bacon.fromBinder(function(handler) {
	      sub.call(target, eventName, handler);
	      return function() {
	        return unsub.call(target, eventName, handler);
	      };
	    }, eventTransformer));
	  };
	
	  Bacon.fromEvent = Bacon.fromEventTarget;
	
	  Bacon.Observable.prototype.map = function() {
	    var args, p;
	    p = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    return convertArgsToFunction(this, p, args, function(f) {
	      return withDescription(this, "map", f, this.withHandler(function(event) {
	        return this.push(event.fmap(f));
	      }));
	    });
	  };
	
	  Bacon.combineAsArray = function() {
	    var index, j, len1, s, sources, stream, streams;
	    streams = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    if (streams.length === 1 && isArray(streams[0])) {
	      streams = streams[0];
	    }
	    for (index = j = 0, len1 = streams.length; j < len1; index = ++j) {
	      stream = streams[index];
	      if (!(isObservable(stream))) {
	        streams[index] = Bacon.constant(stream);
	      }
	    }
	    if (streams.length) {
	      sources = (function() {
	        var k, len2, results;
	        results = [];
	        for (k = 0, len2 = streams.length; k < len2; k++) {
	          s = streams[k];
	          results.push(new Source(s, true));
	        }
	        return results;
	      })();
	      return withDescription.apply(null, [Bacon, "combineAsArray"].concat(slice.call(streams), [Bacon.when(sources, (function() {
	        var xs;
	        xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	        return xs;
	      })).toProperty()]));
	    } else {
	      return Bacon.constant([]);
	    }
	  };
	
	  Bacon.onValues = function() {
	    var f, j, streams;
	    streams = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), f = arguments[j++];
	    return Bacon.combineAsArray(streams).onValues(f);
	  };
	
	  Bacon.combineWith = function() {
	    var f, streams;
	    f = arguments[0], streams = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    return withDescription.apply(null, [Bacon, "combineWith", f].concat(slice.call(streams), [Bacon.combineAsArray(streams).map(function(values) {
	      return f.apply(null, values);
	    })]));
	  };
	
	  Bacon.combineTemplate = function(template) {
	    var applyStreamValue, combinator, compile, compileTemplate, constantValue, current, funcs, mkContext, setValue, streams;
	    funcs = [];
	    streams = [];
	    current = function(ctxStack) {
	      return ctxStack[ctxStack.length - 1];
	    };
	    setValue = function(ctxStack, key, value) {
	      return current(ctxStack)[key] = value;
	    };
	    applyStreamValue = function(key, index) {
	      return function(ctxStack, values) {
	        return setValue(ctxStack, key, values[index]);
	      };
	    };
	    constantValue = function(key, value) {
	      return function(ctxStack) {
	        return setValue(ctxStack, key, value);
	      };
	    };
	    mkContext = function(template) {
	      if (isArray(template)) {
	        return [];
	      } else {
	        return {};
	      }
	    };
	    compile = function(key, value) {
	      var popContext, pushContext;
	      if (isObservable(value)) {
	        streams.push(value);
	        return funcs.push(applyStreamValue(key, streams.length - 1));
	      } else if (value === Object(value) && typeof value !== "function" && !(value instanceof RegExp) && !(value instanceof Date)) {
	        pushContext = function(key) {
	          return function(ctxStack) {
	            var newContext;
	            newContext = mkContext(value);
	            setValue(ctxStack, key, newContext);
	            return ctxStack.push(newContext);
	          };
	        };
	        popContext = function(ctxStack) {
	          return ctxStack.pop();
	        };
	        funcs.push(pushContext(key));
	        compileTemplate(value);
	        return funcs.push(popContext);
	      } else {
	        return funcs.push(constantValue(key, value));
	      }
	    };
	    compileTemplate = function(template) {
	      return _.each(template, compile);
	    };
	    compileTemplate(template);
	    combinator = function(values) {
	      var ctxStack, f, j, len1, rootContext;
	      rootContext = mkContext(template);
	      ctxStack = [rootContext];
	      for (j = 0, len1 = funcs.length; j < len1; j++) {
	        f = funcs[j];
	        f(ctxStack, values);
	      }
	      return rootContext;
	    };
	    return withDescription(Bacon, "combineTemplate", template, Bacon.combineAsArray(streams).map(combinator));
	  };
	
	  Bacon.Observable.prototype.combine = function(other, f) {
	    var combinator;
	    combinator = toCombinator(f);
	    return withDescription(this, "combine", other, f, Bacon.combineAsArray(this, other).map(function(values) {
	      return combinator(values[0], values[1]);
	    }));
	  };
	
	  Bacon.Observable.prototype.decode = function(cases) {
	    return withDescription(this, "decode", cases, this.combine(Bacon.combineTemplate(cases), function(key, values) {
	      return values[key];
	    }));
	  };
	
	  Bacon.Observable.prototype.withStateMachine = function(initState, f) {
	    var state;
	    state = initState;
	    return withDescription(this, "withStateMachine", initState, f, this.withHandler(function(event) {
	      var fromF, j, len1, newState, output, outputs, reply;
	      fromF = f(state, event);
	      newState = fromF[0], outputs = fromF[1];
	      state = newState;
	      reply = Bacon.more;
	      for (j = 0, len1 = outputs.length; j < len1; j++) {
	        output = outputs[j];
	        reply = this.push(output);
	        if (reply === Bacon.noMore) {
	          return reply;
	        }
	      }
	      return reply;
	    }));
	  };
	
	  Bacon.Observable.prototype.skipDuplicates = function(isEqual) {
	    if (isEqual == null) {
	      isEqual = function(a, b) {
	        return a === b;
	      };
	    }
	    return withDescription(this, "skipDuplicates", this.withStateMachine(None, function(prev, event) {
	      if (!event.hasValue()) {
	        return [prev, [event]];
	      } else if (event.isInitial() || prev === None || !isEqual(prev.get(), event.value())) {
	        return [new Some(event.value()), [event]];
	      } else {
	        return [prev, []];
	      }
	    }));
	  };
	
	  Bacon.Observable.prototype.awaiting = function(other) {
	    return withDescription(this, "awaiting", other, Bacon.groupSimultaneous(this, other).map(function(arg) {
	      var myValues, otherValues;
	      myValues = arg[0], otherValues = arg[1];
	      return otherValues.length === 0;
	    }).toProperty(false).skipDuplicates());
	  };
	
	  Bacon.Observable.prototype.not = function() {
	    return withDescription(this, "not", this.map(function(x) {
	      return !x;
	    }));
	  };
	
	  Bacon.Property.prototype.and = function(other) {
	    return withDescription(this, "and", other, this.combine(other, function(x, y) {
	      return x && y;
	    }));
	  };
	
	  Bacon.Property.prototype.or = function(other) {
	    return withDescription(this, "or", other, this.combine(other, function(x, y) {
	      return x || y;
	    }));
	  };
	
	  Bacon.scheduler = {
	    setTimeout: function(f, d) {
	      return setTimeout(f, d);
	    },
	    setInterval: function(f, i) {
	      return setInterval(f, i);
	    },
	    clearInterval: function(id) {
	      return clearInterval(id);
	    },
	    clearTimeout: function(id) {
	      return clearTimeout(id);
	    },
	    now: function() {
	      return new Date().getTime();
	    }
	  };
	
	  Bacon.EventStream.prototype.bufferWithTime = function(delay) {
	    return withDescription(this, "bufferWithTime", delay, this.bufferWithTimeOrCount(delay, Number.MAX_VALUE));
	  };
	
	  Bacon.EventStream.prototype.bufferWithCount = function(count) {
	    return withDescription(this, "bufferWithCount", count, this.bufferWithTimeOrCount(void 0, count));
	  };
	
	  Bacon.EventStream.prototype.bufferWithTimeOrCount = function(delay, count) {
	    var flushOrSchedule;
	    flushOrSchedule = function(buffer) {
	      if (buffer.values.length === count) {
	        return buffer.flush();
	      } else if (delay !== void 0) {
	        return buffer.schedule();
	      }
	    };
	    return withDescription(this, "bufferWithTimeOrCount", delay, count, this.buffer(delay, flushOrSchedule, flushOrSchedule));
	  };
	
	  Bacon.EventStream.prototype.buffer = function(delay, onInput, onFlush) {
	    var buffer, delayMs, reply;
	    if (onInput == null) {
	      onInput = nop;
	    }
	    if (onFlush == null) {
	      onFlush = nop;
	    }
	    buffer = {
	      scheduled: null,
	      end: void 0,
	      values: [],
	      flush: function() {
	        var reply;
	        if (this.scheduled) {
	          Bacon.scheduler.clearTimeout(this.scheduled);
	          this.scheduled = null;
	        }
	        if (this.values.length > 0) {
	          reply = this.push(nextEvent(this.values));
	          this.values = [];
	          if (this.end != null) {
	            return this.push(this.end);
	          } else if (reply !== Bacon.noMore) {
	            return onFlush(this);
	          }
	        } else {
	          if (this.end != null) {
	            return this.push(this.end);
	          }
	        }
	      },
	      schedule: function() {
	        if (!this.scheduled) {
	          return this.scheduled = delay((function(_this) {
	            return function() {
	              return _this.flush();
	            };
	          })(this));
	        }
	      }
	    };
	    reply = Bacon.more;
	    if (!_.isFunction(delay)) {
	      delayMs = delay;
	      delay = function(f) {
	        return Bacon.scheduler.setTimeout(f, delayMs);
	      };
	    }
	    return withDescription(this, "buffer", this.withHandler(function(event) {
	      buffer.push = (function(_this) {
	        return function(event) {
	          return _this.push(event);
	        };
	      })(this);
	      if (event.isError()) {
	        reply = this.push(event);
	      } else if (event.isEnd()) {
	        buffer.end = event;
	        if (!buffer.scheduled) {
	          buffer.flush();
	        }
	      } else {
	        buffer.values.push(event.value());
	        onInput(buffer);
	      }
	      return reply;
	    }));
	  };
	
	  Bacon.Observable.prototype.filter = function() {
	    var args, f;
	    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    assertObservableIsProperty(f);
	    return convertArgsToFunction(this, f, args, function(f) {
	      return withDescription(this, "filter", f, this.withHandler(function(event) {
	        if (event.filter(f)) {
	          return this.push(event);
	        } else {
	          return Bacon.more;
	        }
	      }));
	    });
	  };
	
	  Bacon.once = function(value) {
	    return new EventStream(describe(Bacon, "once", value), function(sink) {
	      sink(toEvent(value));
	      sink(endEvent());
	      return nop;
	    });
	  };
	
	  Bacon.EventStream.prototype.concat = function(right) {
	    var left;
	    left = this;
	    return new EventStream(describe(left, "concat", right), function(sink) {
	      var unsubLeft, unsubRight;
	      unsubRight = nop;
	      unsubLeft = left.dispatcher.subscribe(function(e) {
	        if (e.isEnd()) {
	          return unsubRight = right.dispatcher.subscribe(sink);
	        } else {
	          return sink(e);
	        }
	      });
	      return function() {
	        unsubLeft();
	        return unsubRight();
	      };
	    });
	  };
	
	  Bacon.Observable.prototype.flatMap = function() {
	    return flatMap_(this, makeSpawner(arguments));
	  };
	
	  Bacon.Observable.prototype.flatMapFirst = function() {
	    return flatMap_(this, makeSpawner(arguments), true);
	  };
	
	  flatMap_ = function(root, f, firstOnly, limit) {
	    var childDeps, result, rootDep;
	    rootDep = [root];
	    childDeps = [];
	    result = new EventStream(describe(root, "flatMap" + (firstOnly ? "First" : ""), f), function(sink) {
	      var checkEnd, checkQueue, composite, queue, spawn;
	      composite = new CompositeUnsubscribe();
	      queue = [];
	      spawn = function(event) {
	        var child;
	        child = makeObservable(f(event.value()));
	        childDeps.push(child);
	        return composite.add(function(unsubAll, unsubMe) {
	          return child.dispatcher.subscribe(function(event) {
	            var reply;
	            if (event.isEnd()) {
	              _.remove(child, childDeps);
	              checkQueue();
	              checkEnd(unsubMe);
	              return Bacon.noMore;
	            } else {
	              if (event instanceof Initial) {
	                event = event.toNext();
	              }
	              reply = sink(event);
	              if (reply === Bacon.noMore) {
	                unsubAll();
	              }
	              return reply;
	            }
	          });
	        });
	      };
	      checkQueue = function() {
	        var event;
	        event = queue.shift();
	        if (event) {
	          return spawn(event);
	        }
	      };
	      checkEnd = function(unsub) {
	        unsub();
	        if (composite.empty()) {
	          return sink(endEvent());
	        }
	      };
	      composite.add(function(__, unsubRoot) {
	        return root.dispatcher.subscribe(function(event) {
	          if (event.isEnd()) {
	            return checkEnd(unsubRoot);
	          } else if (event.isError()) {
	            return sink(event);
	          } else if (firstOnly && composite.count() > 1) {
	            return Bacon.more;
	          } else {
	            if (composite.unsubscribed) {
	              return Bacon.noMore;
	            }
	            if (limit && composite.count() > limit) {
	              return queue.push(event);
	            } else {
	              return spawn(event);
	            }
	          }
	        });
	      });
	      return composite.unsubscribe;
	    });
	    result.internalDeps = function() {
	      if (childDeps.length) {
	        return rootDep.concat(childDeps);
	      } else {
	        return rootDep;
	      }
	    };
	    return result;
	  };
	
	  makeSpawner = function(args) {
	    if (args.length === 1 && isObservable(args[0])) {
	      return _.always(args[0]);
	    } else {
	      return makeFunctionArgs(args);
	    }
	  };
	
	  makeObservable = function(x) {
	    if (isObservable(x)) {
	      return x;
	    } else {
	      return Bacon.once(x);
	    }
	  };
	
	  Bacon.Observable.prototype.flatMapWithConcurrencyLimit = function() {
	    var args, limit;
	    limit = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    return withDescription.apply(null, [this, "flatMapWithConcurrencyLimit", limit].concat(slice.call(args), [flatMap_(this, makeSpawner(args), false, limit)]));
	  };
	
	  Bacon.Observable.prototype.flatMapConcat = function() {
	    return withDescription.apply(null, [this, "flatMapConcat"].concat(slice.call(arguments), [this.flatMapWithConcurrencyLimit.apply(this, [1].concat(slice.call(arguments)))]));
	  };
	
	  Bacon.later = function(delay, value) {
	    return withDescription(Bacon, "later", delay, value, Bacon.fromBinder(function(sink) {
	      var id, sender;
	      sender = function() {
	        return sink([value, endEvent()]);
	      };
	      id = Bacon.scheduler.setTimeout(sender, delay);
	      return function() {
	        return Bacon.scheduler.clearTimeout(id);
	      };
	    }));
	  };
	
	  Bacon.Observable.prototype.bufferingThrottle = function(minimumInterval) {
	    return withDescription(this, "bufferingThrottle", minimumInterval, this.flatMapConcat(function(x) {
	      return Bacon.once(x).concat(Bacon.later(minimumInterval).filter(false));
	    }));
	  };
	
	  Bacon.Property.prototype.bufferingThrottle = function() {
	    return Bacon.Observable.prototype.bufferingThrottle.apply(this, arguments).toProperty();
	  };
	
	  Bus = (function(superClass) {
	    extend(Bus, superClass);
	
	    function Bus() {
	      this.guardedSink = bind(this.guardedSink, this);
	      this.subscribeAll = bind(this.subscribeAll, this);
	      this.unsubAll = bind(this.unsubAll, this);
	      this.sink = void 0;
	      this.subscriptions = [];
	      this.ended = false;
	      Bus.__super__.constructor.call(this, describe(Bacon, "Bus"), this.subscribeAll);
	    }
	
	    Bus.prototype.unsubAll = function() {
	      var j, len1, ref, sub;
	      ref = this.subscriptions;
	      for (j = 0, len1 = ref.length; j < len1; j++) {
	        sub = ref[j];
	        if (typeof sub.unsub === "function") {
	          sub.unsub();
	        }
	      }
	      return void 0;
	    };
	
	    Bus.prototype.subscribeAll = function(newSink) {
	      var j, len1, ref, subscription;
	      if (this.ended) {
	        newSink(endEvent());
	      } else {
	        this.sink = newSink;
	        ref = cloneArray(this.subscriptions);
	        for (j = 0, len1 = ref.length; j < len1; j++) {
	          subscription = ref[j];
	          this.subscribeInput(subscription);
	        }
	      }
	      return this.unsubAll;
	    };
	
	    Bus.prototype.guardedSink = function(input) {
	      return (function(_this) {
	        return function(event) {
	          if (event.isEnd()) {
	            _this.unsubscribeInput(input);
	            return Bacon.noMore;
	          } else {
	            return _this.sink(event);
	          }
	        };
	      })(this);
	    };
	
	    Bus.prototype.subscribeInput = function(subscription) {
	      return subscription.unsub = subscription.input.dispatcher.subscribe(this.guardedSink(subscription.input));
	    };
	
	    Bus.prototype.unsubscribeInput = function(input) {
	      var i, j, len1, ref, sub;
	      ref = this.subscriptions;
	      for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {
	        sub = ref[i];
	        if (sub.input === input) {
	          if (typeof sub.unsub === "function") {
	            sub.unsub();
	          }
	          this.subscriptions.splice(i, 1);
	          return;
	        }
	      }
	    };
	
	    Bus.prototype.plug = function(input) {
	      var sub;
	      assertObservable(input);
	      if (this.ended) {
	        return;
	      }
	      sub = {
	        input: input
	      };
	      this.subscriptions.push(sub);
	      if ((this.sink != null)) {
	        this.subscribeInput(sub);
	      }
	      return (function(_this) {
	        return function() {
	          return _this.unsubscribeInput(input);
	        };
	      })(this);
	    };
	
	    Bus.prototype.end = function() {
	      this.ended = true;
	      this.unsubAll();
	      return typeof this.sink === "function" ? this.sink(endEvent()) : void 0;
	    };
	
	    Bus.prototype.push = function(value) {
	      if (!this.ended) {
	        return typeof this.sink === "function" ? this.sink(nextEvent(value)) : void 0;
	      }
	    };
	
	    Bus.prototype.error = function(error) {
	      return typeof this.sink === "function" ? this.sink(new Error(error)) : void 0;
	    };
	
	    return Bus;
	
	  })(EventStream);
	
	  Bacon.Bus = Bus;
	
	  liftCallback = function(desc, wrapped) {
	    return withMethodCallSupport(function() {
	      var args, f, stream;
	      f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	      stream = partiallyApplied(wrapped, [
	        function(values, callback) {
	          return f.apply(null, slice.call(values).concat([callback]));
	        }
	      ]);
	      return withDescription.apply(null, [Bacon, desc, f].concat(slice.call(args), [Bacon.combineAsArray(args).flatMap(stream)]));
	    });
	  };
	
	  Bacon.fromCallback = liftCallback("fromCallback", function() {
	    var args, f;
	    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    return Bacon.fromBinder(function(handler) {
	      makeFunction(f, args)(handler);
	      return nop;
	    }, (function(value) {
	      return [value, endEvent()];
	    }));
	  });
	
	  Bacon.fromNodeCallback = liftCallback("fromNodeCallback", function() {
	    var args, f;
	    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    return Bacon.fromBinder(function(handler) {
	      makeFunction(f, args)(handler);
	      return nop;
	    }, function(error, value) {
	      if (error) {
	        return [new Error(error), endEvent()];
	      }
	      return [value, endEvent()];
	    });
	  });
	
	  addPropertyInitValueToStream = function(property, stream) {
	    var justInitValue;
	    justInitValue = new EventStream(describe(property, "justInitValue"), function(sink) {
	      var unsub, value;
	      value = void 0;
	      unsub = property.dispatcher.subscribe(function(event) {
	        if (!event.isEnd()) {
	          value = event;
	        }
	        return Bacon.noMore;
	      });
	      UpdateBarrier.whenDoneWith(justInitValue, function() {
	        if (value != null) {
	          sink(value);
	        }
	        return sink(endEvent());
	      });
	      return unsub;
	    });
	    return justInitValue.concat(stream).toProperty();
	  };
	
	  Bacon.Observable.prototype.mapEnd = function() {
	    var f;
	    f = makeFunctionArgs(arguments);
	    return withDescription(this, "mapEnd", f, this.withHandler(function(event) {
	      if (event.isEnd()) {
	        this.push(nextEvent(f(event)));
	        this.push(endEvent());
	        return Bacon.noMore;
	      } else {
	        return this.push(event);
	      }
	    }));
	  };
	
	  Bacon.Observable.prototype.skipErrors = function() {
	    return withDescription(this, "skipErrors", this.withHandler(function(event) {
	      if (event.isError()) {
	        return Bacon.more;
	      } else {
	        return this.push(event);
	      }
	    }));
	  };
	
	  Bacon.EventStream.prototype.takeUntil = function(stopper) {
	    var endMarker;
	    endMarker = {};
	    return withDescription(this, "takeUntil", stopper, Bacon.groupSimultaneous(this.mapEnd(endMarker), stopper.skipErrors()).withHandler(function(event) {
	      var data, j, len1, ref, reply, value;
	      if (!event.hasValue()) {
	        return this.push(event);
	      } else {
	        ref = event.value(), data = ref[0], stopper = ref[1];
	        if (stopper.length) {
	          return this.push(endEvent());
	        } else {
	          reply = Bacon.more;
	          for (j = 0, len1 = data.length; j < len1; j++) {
	            value = data[j];
	            if (value === endMarker) {
	              reply = this.push(endEvent());
	            } else {
	              reply = this.push(nextEvent(value));
	            }
	          }
	          return reply;
	        }
	      }
	    }));
	  };
	
	  Bacon.Property.prototype.takeUntil = function(stopper) {
	    var changes;
	    changes = this.changes().takeUntil(stopper);
	    return withDescription(this, "takeUntil", stopper, addPropertyInitValueToStream(this, changes));
	  };
	
	  Bacon.Observable.prototype.flatMapLatest = function() {
	    var f, stream;
	    f = makeSpawner(arguments);
	    stream = this.toEventStream();
	    return withDescription(this, "flatMapLatest", f, stream.flatMap(function(value) {
	      return makeObservable(f(value)).takeUntil(stream);
	    }));
	  };
	
	  Bacon.Property.prototype.delayChanges = function() {
	    var desc, f, j;
	    desc = 2 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 1) : (j = 0, []), f = arguments[j++];
	    return withDescription.apply(null, [this].concat(slice.call(desc), [addPropertyInitValueToStream(this, f(this.changes()))]));
	  };
	
	  Bacon.EventStream.prototype.delay = function(delay) {
	    return withDescription(this, "delay", delay, this.flatMap(function(value) {
	      return Bacon.later(delay, value);
	    }));
	  };
	
	  Bacon.Property.prototype.delay = function(delay) {
	    return this.delayChanges("delay", delay, function(changes) {
	      return changes.delay(delay);
	    });
	  };
	
	  Bacon.EventStream.prototype.debounce = function(delay) {
	    return withDescription(this, "debounce", delay, this.flatMapLatest(function(value) {
	      return Bacon.later(delay, value);
	    }));
	  };
	
	  Bacon.Property.prototype.debounce = function(delay) {
	    return this.delayChanges("debounce", delay, function(changes) {
	      return changes.debounce(delay);
	    });
	  };
	
	  Bacon.EventStream.prototype.debounceImmediate = function(delay) {
	    return withDescription(this, "debounceImmediate", delay, this.flatMapFirst(function(value) {
	      return Bacon.once(value).concat(Bacon.later(delay).filter(false));
	    }));
	  };
	
	  Bacon.Observable.prototype.scan = function(seed, f) {
	    var acc, resultProperty, subscribe;
	    f = toCombinator(f);
	    acc = toOption(seed);
	    subscribe = (function(_this) {
	      return function(sink) {
	        var initSent, reply, sendInit, unsub;
	        initSent = false;
	        unsub = nop;
	        reply = Bacon.more;
	        sendInit = function() {
	          if (!initSent) {
	            return acc.forEach(function(value) {
	              initSent = true;
	              reply = sink(new Initial(function() {
	                return value;
	              }));
	              if (reply === Bacon.noMore) {
	                unsub();
	                return unsub = nop;
	              }
	            });
	          }
	        };
	        unsub = _this.dispatcher.subscribe(function(event) {
	          var next, prev;
	          if (event.hasValue()) {
	            if (initSent && event.isInitial()) {
	              return Bacon.more;
	            } else {
	              if (!event.isInitial()) {
	                sendInit();
	              }
	              initSent = true;
	              prev = acc.getOrElse(void 0);
	              next = f(prev, event.value());
	              acc = new Some(next);
	              return sink(event.apply(function() {
	                return next;
	              }));
	            }
	          } else {
	            if (event.isEnd()) {
	              reply = sendInit();
	            }
	            if (reply !== Bacon.noMore) {
	              return sink(event);
	            }
	          }
	        });
	        UpdateBarrier.whenDoneWith(resultProperty, sendInit);
	        return unsub;
	      };
	    })(this);
	    return resultProperty = new Property(describe(this, "scan", seed, f), subscribe);
	  };
	
	  Bacon.Observable.prototype.diff = function(start, f) {
	    f = toCombinator(f);
	    return withDescription(this, "diff", start, f, this.scan([start], function(prevTuple, next) {
	      return [next, f(prevTuple[0], next)];
	    }).filter(function(tuple) {
	      return tuple.length === 2;
	    }).map(function(tuple) {
	      return tuple[1];
	    }));
	  };
	
	  Bacon.Observable.prototype.doAction = function() {
	    var f;
	    f = makeFunctionArgs(arguments);
	    return withDescription(this, "doAction", f, this.withHandler(function(event) {
	      if (event.hasValue()) {
	        f(event.value());
	      }
	      return this.push(event);
	    }));
	  };
	
	  Bacon.Observable.prototype.doError = function() {
	    var f;
	    f = makeFunctionArgs(arguments);
	    return withDescription(this, "doError", f, this.withHandler(function(event) {
	      if (event.isError()) {
	        f(event.error);
	      }
	      return this.push(event);
	    }));
	  };
	
	  Bacon.Observable.prototype.endOnError = function() {
	    var args, f;
	    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (f == null) {
	      f = true;
	    }
	    return convertArgsToFunction(this, f, args, function(f) {
	      return withDescription(this, "endOnError", this.withHandler(function(event) {
	        if (event.isError() && f(event.error)) {
	          this.push(event);
	          return this.push(endEvent());
	        } else {
	          return this.push(event);
	        }
	      }));
	    });
	  };
	
	  Observable.prototype.errors = function() {
	    return withDescription(this, "errors", this.filter(function() {
	      return false;
	    }));
	  };
	
	  valueAndEnd = (function(value) {
	    return [value, endEvent()];
	  });
	
	  Bacon.fromPromise = function(promise, abort) {
	    return withDescription(Bacon, "fromPromise", promise, Bacon.fromBinder(function(handler) {
	      var ref;
	      if ((ref = promise.then(handler, function(e) {
	        return handler(new Error(e));
	      })) != null) {
	        if (typeof ref.done === "function") {
	          ref.done();
	        }
	      }
	      return function() {
	        if (abort) {
	          return typeof promise.abort === "function" ? promise.abort() : void 0;
	        }
	      };
	    }, valueAndEnd));
	  };
	
	  Bacon.Observable.prototype.mapError = function() {
	    var f;
	    f = makeFunctionArgs(arguments);
	    return withDescription(this, "mapError", f, this.withHandler(function(event) {
	      if (event.isError()) {
	        return this.push(nextEvent(f(event.error)));
	      } else {
	        return this.push(event);
	      }
	    }));
	  };
	
	  Bacon.Observable.prototype.flatMapError = function(fn) {
	    return withDescription(this, "flatMapError", fn, this.mapError(function(err) {
	      return new Error(err);
	    }).flatMap(function(x) {
	      if (x instanceof Error) {
	        return fn(x.error);
	      } else {
	        return Bacon.once(x);
	      }
	    }));
	  };
	
	  Bacon.EventStream.prototype.sampledBy = function(sampler, combinator) {
	    return withDescription(this, "sampledBy", sampler, combinator, this.toProperty().sampledBy(sampler, combinator));
	  };
	
	  Bacon.Property.prototype.sampledBy = function(sampler, combinator) {
	    var lazy, result, samplerSource, stream, thisSource;
	    if (combinator != null) {
	      combinator = toCombinator(combinator);
	    } else {
	      lazy = true;
	      combinator = function(f) {
	        return f.value();
	      };
	    }
	    thisSource = new Source(this, false, lazy);
	    samplerSource = new Source(sampler, true, lazy);
	    stream = Bacon.when([thisSource, samplerSource], combinator);
	    result = sampler instanceof Property ? stream.toProperty() : stream;
	    return withDescription(this, "sampledBy", sampler, combinator, result);
	  };
	
	  Bacon.Property.prototype.sample = function(interval) {
	    return withDescription(this, "sample", interval, this.sampledBy(Bacon.interval(interval, {})));
	  };
	
	  Bacon.Observable.prototype.map = function() {
	    var args, p;
	    p = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (p instanceof Property) {
	      return p.sampledBy(this, former);
	    } else {
	      return convertArgsToFunction(this, p, args, function(f) {
	        return withDescription(this, "map", f, this.withHandler(function(event) {
	          return this.push(event.fmap(f));
	        }));
	      });
	    }
	  };
	
	  Bacon.Observable.prototype.fold = function(seed, f) {
	    return withDescription(this, "fold", seed, f, this.scan(seed, f).sampledBy(this.filter(false).mapEnd().toProperty()));
	  };
	
	  Observable.prototype.reduce = Observable.prototype.fold;
	
	  Bacon.fromPoll = function(delay, poll) {
	    return withDescription(Bacon, "fromPoll", delay, poll, Bacon.fromBinder((function(handler) {
	      var id;
	      id = Bacon.scheduler.setInterval(handler, delay);
	      return function() {
	        return Bacon.scheduler.clearInterval(id);
	      };
	    }), poll));
	  };
	
	  Bacon.fromArray = function(values) {
	    var i;
	    assertArray(values);
	    if (!values.length) {
	      return withDescription(Bacon, "fromArray", values, Bacon.never());
	    } else {
	      i = 0;
	      return new EventStream(describe(Bacon, "fromArray", values), function(sink) {
	        var push, pushNeeded, pushing, reply, unsubd;
	        unsubd = false;
	        reply = Bacon.more;
	        pushing = false;
	        pushNeeded = false;
	        push = function() {
	          var value;
	          pushNeeded = true;
	          if (pushing) {
	            return;
	          }
	          pushing = true;
	          while (pushNeeded) {
	            pushNeeded = false;
	            if ((reply !== Bacon.noMore) && !unsubd) {
	              value = values[i++];
	              reply = sink(toEvent(value));
	              if (reply !== Bacon.noMore) {
	                if (i === values.length) {
	                  sink(endEvent());
	                } else {
	                  UpdateBarrier.afterTransaction(push);
	                }
	              }
	            }
	          }
	          return pushing = false;
	        };
	        push();
	        return function() {
	          return unsubd = true;
	        };
	      });
	    }
	  };
	
	  Bacon.EventStream.prototype.holdWhen = function(valve) {
	    var bufferedValues, composite, onHold, src;
	    composite = new CompositeUnsubscribe();
	    onHold = false;
	    bufferedValues = [];
	    src = this;
	    return new EventStream(describe(this, "holdWhen", valve), function(sink) {
	      var endIfBothEnded;
	      endIfBothEnded = function(unsub) {
	        unsub();
	        if (composite.empty()) {
	          return sink(endEvent());
	        }
	      };
	      composite.add(function(unsubAll, unsubMe) {
	        return src.subscribe(function(event) {
	          if (onHold && event.hasValue()) {
	            return bufferedValues.push(event.value());
	          } else if (event.isEnd() && bufferedValues.length) {
	            return endIfBothEnded(unsubMe);
	          } else {
	            return sink(event);
	          }
	        });
	      });
	      composite.add(function(unsubAll, unsubMe) {
	        return valve.subscribe(function(event) {
	          var toSend;
	          if (event.hasValue()) {
	            onHold = event.value();
	            if (!onHold) {
	              toSend = bufferedValues;
	              bufferedValues = [];
	              return _.each(toSend, function(index, value) {
	                return sink(nextEvent(value));
	              });
	            }
	          } else if (event.isEnd()) {
	            return endIfBothEnded(unsubMe);
	          } else {
	            return sink(event);
	          }
	        });
	      });
	      return composite.unsubscribe;
	    });
	  };
	
	  Bacon.interval = function(delay, value) {
	    if (value == null) {
	      value = {};
	    }
	    return withDescription(Bacon, "interval", delay, value, Bacon.fromPoll(delay, function() {
	      return nextEvent(value);
	    }));
	  };
	
	  Bacon.$ = {};
	
	  Bacon.$.asEventStream = function(eventName, selector, eventTransformer) {
	    var ref;
	    if (_.isFunction(selector)) {
	      ref = [selector, void 0], eventTransformer = ref[0], selector = ref[1];
	    }
	    return withDescription(this.selector || this, "asEventStream", eventName, Bacon.fromBinder((function(_this) {
	      return function(handler) {
	        _this.on(eventName, selector, handler);
	        return function() {
	          return _this.off(eventName, selector, handler);
	        };
	      };
	    })(this), eventTransformer));
	  };
	
	  if ((ref = typeof jQuery !== "undefined" && jQuery !== null ? jQuery : typeof Zepto !== "undefined" && Zepto !== null ? Zepto : void 0) != null) {
	    ref.fn.asEventStream = Bacon.$.asEventStream;
	  }
	
	  Bacon.Observable.prototype.log = function() {
	    var args;
	    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    this.subscribe(function(event) {
	      return typeof console !== "undefined" && console !== null ? typeof console.log === "function" ? console.log.apply(console, slice.call(args).concat([event.log()])) : void 0 : void 0;
	    });
	    return this;
	  };
	
	  Bacon.EventStream.prototype.merge = function(right) {
	    var left;
	    assertEventStream(right);
	    left = this;
	    return withDescription(left, "merge", right, Bacon.mergeAll(this, right));
	  };
	
	  Bacon.mergeAll = function() {
	    var streams;
	    streams = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    if (isArray(streams[0])) {
	      streams = streams[0];
	    }
	    if (streams.length) {
	      return new EventStream(describe.apply(null, [Bacon, "mergeAll"].concat(slice.call(streams))), function(sink) {
	        var ends, sinks, smartSink;
	        ends = 0;
	        smartSink = function(obs) {
	          return function(unsubBoth) {
	            return obs.dispatcher.subscribe(function(event) {
	              var reply;
	              if (event.isEnd()) {
	                ends++;
	                if (ends === streams.length) {
	                  return sink(endEvent());
	                } else {
	                  return Bacon.more;
	                }
	              } else {
	                reply = sink(event);
	                if (reply === Bacon.noMore) {
	                  unsubBoth();
	                }
	                return reply;
	              }
	            });
	          };
	        };
	        sinks = _.map(smartSink, streams);
	        return new Bacon.CompositeUnsubscribe(sinks).unsubscribe;
	      });
	    } else {
	      return Bacon.never();
	    }
	  };
	
	  Bacon.repeatedly = function(delay, values) {
	    var index;
	    index = 0;
	    return withDescription(Bacon, "repeatedly", delay, values, Bacon.fromPoll(delay, function() {
	      return values[index++ % values.length];
	    }));
	  };
	
	  Bacon.repeat = function(generator) {
	    var index;
	    index = 0;
	    return Bacon.fromBinder(function(sink) {
	      var flag, handleEvent, reply, subscribeNext, unsub;
	      flag = false;
	      reply = Bacon.more;
	      unsub = function() {};
	      handleEvent = function(event) {
	        if (event.isEnd()) {
	          if (!flag) {
	            return flag = true;
	          } else {
	            return subscribeNext();
	          }
	        } else {
	          return reply = sink(event);
	        }
	      };
	      subscribeNext = function() {
	        var next;
	        flag = true;
	        while (flag && reply !== Bacon.noMore) {
	          next = generator(index++);
	          flag = false;
	          if (next) {
	            unsub = next.subscribeInternal(handleEvent);
	          } else {
	            sink(endEvent());
	          }
	        }
	        return flag = true;
	      };
	      subscribeNext();
	      return function() {
	        return unsub();
	      };
	    });
	  };
	
	  Bacon.retry = function(options) {
	    var delay, error, finished, isRetryable, maxRetries, retries, source;
	    if (!_.isFunction(options.source)) {
	      throw new Exception("'source' option has to be a function");
	    }
	    source = options.source;
	    retries = options.retries || 0;
	    maxRetries = options.maxRetries || retries;
	    delay = options.delay || function() {
	      return 0;
	    };
	    isRetryable = options.isRetryable || function() {
	      return true;
	    };
	    finished = false;
	    error = null;
	    return withDescription(Bacon, "retry", options, Bacon.repeat(function() {
	      var context, pause, valueStream;
	      if (finished) {
	        return null;
	      } else {
	        valueStream = function() {
	          return source().endOnError().withHandler(function(event) {
	            if (event.isError()) {
	              error = event;
	              if (isRetryable(error.error) && retries > 0) {
	
	              } else {
	                finished = true;
	                return this.push(event);
	              }
	            } else {
	              if (event.hasValue()) {
	                error = null;
	                finished = true;
	              }
	              return this.push(event);
	            }
	          });
	        };
	        if (error) {
	          context = {
	            error: error.error,
	            retriesDone: maxRetries - retries
	          };
	          pause = Bacon.later(delay(context)).filter(false);
	          retries = retries - 1;
	          return pause.concat(Bacon.once().flatMap(valueStream));
	        } else {
	          return valueStream();
	        }
	      }
	    }));
	  };
	
	  Bacon.sequentially = function(delay, values) {
	    var index;
	    index = 0;
	    return withDescription(Bacon, "sequentially", delay, values, Bacon.fromPoll(delay, function() {
	      var value;
	      value = values[index++];
	      if (index < values.length) {
	        return value;
	      } else if (index === values.length) {
	        return [value, endEvent()];
	      } else {
	        return endEvent();
	      }
	    }));
	  };
	
	  Bacon.Observable.prototype.skip = function(count) {
	    return withDescription(this, "skip", count, this.withHandler(function(event) {
	      if (!event.hasValue()) {
	        return this.push(event);
	      } else if (count > 0) {
	        count--;
	        return Bacon.more;
	      } else {
	        return this.push(event);
	      }
	    }));
	  };
	
	  Bacon.Observable.prototype.take = function(count) {
	    if (count <= 0) {
	      return Bacon.never();
	    }
	    return withDescription(this, "take", count, this.withHandler(function(event) {
	      if (!event.hasValue()) {
	        return this.push(event);
	      } else {
	        count--;
	        if (count > 0) {
	          return this.push(event);
	        } else {
	          if (count === 0) {
	            this.push(event);
	          }
	          this.push(endEvent());
	          return Bacon.noMore;
	        }
	      }
	    }));
	  };
	
	  Bacon.EventStream.prototype.skipUntil = function(starter) {
	    var started;
	    started = starter.take(1).map(true).toProperty(false);
	    return withDescription(this, "skipUntil", starter, this.filter(started));
	  };
	
	  Bacon.EventStream.prototype.skipWhile = function() {
	    var args, f, ok;
	    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    assertObservableIsProperty(f);
	    ok = false;
	    return convertArgsToFunction(this, f, args, function(f) {
	      return withDescription(this, "skipWhile", f, this.withHandler(function(event) {
	        if (ok || !event.hasValue() || !f(event.value())) {
	          if (event.hasValue()) {
	            ok = true;
	          }
	          return this.push(event);
	        } else {
	          return Bacon.more;
	        }
	      }));
	    });
	  };
	
	  Bacon.Observable.prototype.slidingWindow = function(n, minValues) {
	    if (minValues == null) {
	      minValues = 0;
	    }
	    return withDescription(this, "slidingWindow", n, minValues, this.scan([], (function(window, value) {
	      return window.concat([value]).slice(-n);
	    })).filter((function(values) {
	      return values.length >= minValues;
	    })));
	  };
	
	  Bacon.spy = function(spy) {
	    return spys.push(spy);
	  };
	
	  spys = [];
	
	  registerObs = function(obs) {
	    var j, len1, spy;
	    if (spys.length) {
	      if (!registerObs.running) {
	        try {
	          registerObs.running = true;
	          for (j = 0, len1 = spys.length; j < len1; j++) {
	            spy = spys[j];
	            spy(obs);
	          }
	        } finally {
	          delete registerObs.running;
	        }
	      }
	    }
	    return void 0;
	  };
	
	  Bacon.Property.prototype.startWith = function(seed) {
	    return withDescription(this, "startWith", seed, this.scan(seed, function(prev, next) {
	      return next;
	    }));
	  };
	
	  Bacon.EventStream.prototype.startWith = function(seed) {
	    return withDescription(this, "startWith", seed, Bacon.once(seed).concat(this));
	  };
	
	  Bacon.Observable.prototype.takeWhile = function() {
	    var args, f;
	    f = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    assertObservableIsProperty(f);
	    return convertArgsToFunction(this, f, args, function(f) {
	      return withDescription(this, "takeWhile", f, this.withHandler(function(event) {
	        if (event.filter(f)) {
	          return this.push(event);
	        } else {
	          this.push(endEvent());
	          return Bacon.noMore;
	        }
	      }));
	    });
	  };
	
	  Bacon.update = function() {
	    var i, initial, lateBindFirst, patterns;
	    initial = arguments[0], patterns = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    lateBindFirst = function(f) {
	      return function() {
	        var args;
	        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	        return function(i) {
	          return f.apply(null, [i].concat(args));
	        };
	      };
	    };
	    i = patterns.length - 1;
	    while (i > 0) {
	      if (!(patterns[i] instanceof Function)) {
	        patterns[i] = (function(x) {
	          return function() {
	            return x;
	          };
	        })(patterns[i]);
	      }
	      patterns[i] = lateBindFirst(patterns[i]);
	      i = i - 2;
	    }
	    return withDescription.apply(null, [Bacon, "update", initial].concat(slice.call(patterns), [Bacon.when.apply(Bacon, patterns).scan(initial, (function(x, f) {
	      return f(x);
	    }))]));
	  };
	
	  Bacon.zipAsArray = function() {
	    var streams;
	    streams = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	    if (isArray(streams[0])) {
	      streams = streams[0];
	    }
	    return withDescription.apply(null, [Bacon, "zipAsArray"].concat(slice.call(streams), [Bacon.zipWith(streams, function() {
	      var xs;
	      xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
	      return xs;
	    })]));
	  };
	
	  Bacon.zipWith = function() {
	    var f, ref1, streams;
	    f = arguments[0], streams = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    if (!_.isFunction(f)) {
	      ref1 = [f, streams[0]], streams = ref1[0], f = ref1[1];
	    }
	    streams = _.map((function(s) {
	      return s.toEventStream();
	    }), streams);
	    return withDescription.apply(null, [Bacon, "zipWith", f].concat(slice.call(streams), [Bacon.when(streams, f)]));
	  };
	
	  Bacon.Observable.prototype.zip = function(other, f) {
	    if (f == null) {
	      f = Array;
	    }
	    return withDescription(this, "zip", other, Bacon.zipWith([this, other], f));
	  };
	
	  
	
	Bacon.Observable.prototype.first = function () {
	  return withDescription(this, "first", this.take(1));
	};
	
	Bacon.Observable.prototype.last = function () {
	  var lastEvent;
	
	  return withDescription(this, "last", this.withHandler(function (event) {
	    if (event.isEnd()) {
	      if (lastEvent) {
	        this.push(lastEvent);
	      }
	      this.push(endEvent());
	      return Bacon.noMore;
	    } else {
	      lastEvent = event;
	    }
	  }));
	};
	
	Bacon.EventStream.prototype.throttle = function (delay) {
	  return withDescription(this, "throttle", delay, this.bufferWithTime(delay).map(function (values) {
	    return values[values.length - 1];
	  }));
	};
	
	Bacon.Property.prototype.throttle = function (delay) {
	  return this.delayChanges("throttle", delay, function (changes) {
	    return changes.throttle(delay);
	  });
	};
	
	Observable.prototype.firstToPromise = function (PromiseCtr) {
	  var _this = this;
	
	  if (typeof PromiseCtr !== "function") {
	    if (typeof Promise === "function") {
	      PromiseCtr = Promise;
	    } else {
	      throw new Exception("There isn't default Promise, use shim or parameter");
	    }
	  }
	
	  return new PromiseCtr(function (resolve, reject) {
	    return _this.subscribe(function (event) {
	      if (event.hasValue()) {
	        resolve(event.value());
	      }
	      if (event.isError()) {
	        reject(event.error);
	      }
	
	      return Bacon.noMore;
	    });
	  });
	};
	
	Observable.prototype.toPromise = function (PromiseCtr) {
	  return this.last().firstToPromise(PromiseCtr);
	};
	
	if (("function" !== "undefined" && __webpack_require__(/*! !webpack amd define */ 3) !== null) && (__webpack_require__(/*! !webpack amd options */ 4) != null)) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return Bacon;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    this.Bacon = Bacon;
	  } else if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
	    module.exports = Bacon;
	    Bacon.Bacon = Bacon;
	  } else {
	    this.Bacon = Bacon;
	  }
	
	}).call(this);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./../../webpack/buildin/module.js */ 2)(module)))

/***/ },
/* 2 */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 3 */
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 4 */
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;
	
	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ },
/* 5 */
/*!********************!*\
  !*** ./~/d3/d3.js ***!
  \********************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
	  var d3 = {
	    version: "3.5.5"
	  };
	  var d3_arraySlice = [].slice, d3_array = function(list) {
	    return d3_arraySlice.call(list);
	  };
	  var d3_document = this.document;
	  function d3_documentElement(node) {
	    return node && (node.ownerDocument || node.document || node).documentElement;
	  }
	  function d3_window(node) {
	    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
	  }
	  if (d3_document) {
	    try {
	      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
	    } catch (e) {
	      d3_array = function(list) {
	        var i = list.length, array = new Array(i);
	        while (i--) array[i] = list[i];
	        return array;
	      };
	    }
	  }
	  if (!Date.now) Date.now = function() {
	    return +new Date();
	  };
	  if (d3_document) {
	    try {
	      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
	    } catch (error) {
	      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
	      d3_element_prototype.setAttribute = function(name, value) {
	        d3_element_setAttribute.call(this, name, value + "");
	      };
	      d3_element_prototype.setAttributeNS = function(space, local, value) {
	        d3_element_setAttributeNS.call(this, space, local, value + "");
	      };
	      d3_style_prototype.setProperty = function(name, value, priority) {
	        d3_style_setProperty.call(this, name, value + "", priority);
	      };
	    }
	  }
	  d3.ascending = d3_ascending;
	  function d3_ascending(a, b) {
	    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	  }
	  d3.descending = function(a, b) {
	    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	  };
	  d3.min = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
	    }
	    return a;
	  };
	  d3.max = function(array, f) {
	    var i = -1, n = array.length, a, b;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
	    }
	    return a;
	  };
	  d3.extent = function(array, f) {
	    var i = -1, n = array.length, a, b, c;
	    if (arguments.length === 1) {
	      while (++i < n) if ((b = array[i]) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = array[i]) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    } else {
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
	        a = c = b;
	        break;
	      }
	      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
	        if (a > b) a = b;
	        if (c < b) c = b;
	      }
	    }
	    return [ a, c ];
	  };
	  function d3_number(x) {
	    return x === null ? NaN : +x;
	  }
	  function d3_numeric(x) {
	    return !isNaN(x);
	  }
	  d3.sum = function(array, f) {
	    var s = 0, n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
	    } else {
	      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
	    }
	    return s;
	  };
	  d3.mean = function(array, f) {
	    var s = 0, n = array.length, a, i = -1, j = n;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
	    }
	    if (j) return s / j;
	  };
	  d3.quantile = function(values, p) {
	    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
	    return e ? v + e * (values[h] - v) : v;
	  };
	  d3.median = function(array, f) {
	    var numbers = [], n = array.length, a, i = -1;
	    if (arguments.length === 1) {
	      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
	    } else {
	      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
	    }
	    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
	  };
	  d3.variance = function(array, f) {
	    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
	    if (arguments.length === 1) {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(array[i]))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    } else {
	      while (++i < n) {
	        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
	          d = a - m;
	          m += d / ++j;
	          s += d * (a - m);
	        }
	      }
	    }
	    if (j > 1) return s / (j - 1);
	  };
	  d3.deviation = function() {
	    var v = d3.variance.apply(this, arguments);
	    return v ? Math.sqrt(v) : v;
	  };
	  function d3_bisector(compare) {
	    return {
	      left: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
	        }
	        return lo;
	      },
	      right: function(a, x, lo, hi) {
	        if (arguments.length < 3) lo = 0;
	        if (arguments.length < 4) hi = a.length;
	        while (lo < hi) {
	          var mid = lo + hi >>> 1;
	          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
	        }
	        return lo;
	      }
	    };
	  }
	  var d3_bisect = d3_bisector(d3_ascending);
	  d3.bisectLeft = d3_bisect.left;
	  d3.bisect = d3.bisectRight = d3_bisect.right;
	  d3.bisector = function(f) {
	    return d3_bisector(f.length === 1 ? function(d, x) {
	      return d3_ascending(f(d), x);
	    } : f);
	  };
	  d3.shuffle = function(array, i0, i1) {
	    if ((m = arguments.length) < 3) {
	      i1 = array.length;
	      if (m < 2) i0 = 0;
	    }
	    var m = i1 - i0, t, i;
	    while (m) {
	      i = Math.random() * m-- | 0;
	      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
	    }
	    return array;
	  };
	  d3.permute = function(array, indexes) {
	    var i = indexes.length, permutes = new Array(i);
	    while (i--) permutes[i] = array[indexes[i]];
	    return permutes;
	  };
	  d3.pairs = function(array) {
	    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
	    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
	    return pairs;
	  };
	  d3.zip = function() {
	    if (!(n = arguments.length)) return [];
	    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
	      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
	        zip[j] = arguments[j][i];
	      }
	    }
	    return zips;
	  };
	  function d3_zipLength(d) {
	    return d.length;
	  }
	  d3.transpose = function(matrix) {
	    return d3.zip.apply(d3, matrix);
	  };
	  d3.keys = function(map) {
	    var keys = [];
	    for (var key in map) keys.push(key);
	    return keys;
	  };
	  d3.values = function(map) {
	    var values = [];
	    for (var key in map) values.push(map[key]);
	    return values;
	  };
	  d3.entries = function(map) {
	    var entries = [];
	    for (var key in map) entries.push({
	      key: key,
	      value: map[key]
	    });
	    return entries;
	  };
	  d3.merge = function(arrays) {
	    var n = arrays.length, m, i = -1, j = 0, merged, array;
	    while (++i < n) j += arrays[i].length;
	    merged = new Array(j);
	    while (--n >= 0) {
	      array = arrays[n];
	      m = array.length;
	      while (--m >= 0) {
	        merged[--j] = array[m];
	      }
	    }
	    return merged;
	  };
	  var abs = Math.abs;
	  d3.range = function(start, stop, step) {
	    if (arguments.length < 3) {
	      step = 1;
	      if (arguments.length < 2) {
	        stop = start;
	        start = 0;
	      }
	    }
	    if ((stop - start) / step === Infinity) throw new Error("infinite range");
	    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
	    start *= k, stop *= k, step *= k;
	    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
	    return range;
	  };
	  function d3_range_integerScale(x) {
	    var k = 1;
	    while (x * k % 1) k *= 10;
	    return k;
	  }
	  function d3_class(ctor, properties) {
	    for (var key in properties) {
	      Object.defineProperty(ctor.prototype, key, {
	        value: properties[key],
	        enumerable: false
	      });
	    }
	  }
	  d3.map = function(object, f) {
	    var map = new d3_Map();
	    if (object instanceof d3_Map) {
	      object.forEach(function(key, value) {
	        map.set(key, value);
	      });
	    } else if (Array.isArray(object)) {
	      var i = -1, n = object.length, o;
	      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
	    } else {
	      for (var key in object) map.set(key, object[key]);
	    }
	    return map;
	  };
	  function d3_Map() {
	    this._ = Object.create(null);
	  }
	  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
	  d3_class(d3_Map, {
	    has: d3_map_has,
	    get: function(key) {
	      return this._[d3_map_escape(key)];
	    },
	    set: function(key, value) {
	      return this._[d3_map_escape(key)] = value;
	    },
	    remove: d3_map_remove,
	    keys: d3_map_keys,
	    values: function() {
	      var values = [];
	      for (var key in this._) values.push(this._[key]);
	      return values;
	    },
	    entries: function() {
	      var entries = [];
	      for (var key in this._) entries.push({
	        key: d3_map_unescape(key),
	        value: this._[key]
	      });
	      return entries;
	    },
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
	    }
	  });
	  function d3_map_escape(key) {
	    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
	  }
	  function d3_map_unescape(key) {
	    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
	  }
	  function d3_map_has(key) {
	    return d3_map_escape(key) in this._;
	  }
	  function d3_map_remove(key) {
	    return (key = d3_map_escape(key)) in this._ && delete this._[key];
	  }
	  function d3_map_keys() {
	    var keys = [];
	    for (var key in this._) keys.push(d3_map_unescape(key));
	    return keys;
	  }
	  function d3_map_size() {
	    var size = 0;
	    for (var key in this._) ++size;
	    return size;
	  }
	  function d3_map_empty() {
	    for (var key in this._) return false;
	    return true;
	  }
	  d3.nest = function() {
	    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
	    function map(mapType, array, depth) {
	      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
	      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
	      while (++i < n) {
	        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
	          values.push(object);
	        } else {
	          valuesByKey.set(keyValue, [ object ]);
	        }
	      }
	      if (mapType) {
	        object = mapType();
	        setter = function(keyValue, values) {
	          object.set(keyValue, map(mapType, values, depth));
	        };
	      } else {
	        object = {};
	        setter = function(keyValue, values) {
	          object[keyValue] = map(mapType, values, depth);
	        };
	      }
	      valuesByKey.forEach(setter);
	      return object;
	    }
	    function entries(map, depth) {
	      if (depth >= keys.length) return map;
	      var array = [], sortKey = sortKeys[depth++];
	      map.forEach(function(key, keyMap) {
	        array.push({
	          key: key,
	          values: entries(keyMap, depth)
	        });
	      });
	      return sortKey ? array.sort(function(a, b) {
	        return sortKey(a.key, b.key);
	      }) : array;
	    }
	    nest.map = function(array, mapType) {
	      return map(mapType, array, 0);
	    };
	    nest.entries = function(array) {
	      return entries(map(d3.map, array, 0), 0);
	    };
	    nest.key = function(d) {
	      keys.push(d);
	      return nest;
	    };
	    nest.sortKeys = function(order) {
	      sortKeys[keys.length - 1] = order;
	      return nest;
	    };
	    nest.sortValues = function(order) {
	      sortValues = order;
	      return nest;
	    };
	    nest.rollup = function(f) {
	      rollup = f;
	      return nest;
	    };
	    return nest;
	  };
	  d3.set = function(array) {
	    var set = new d3_Set();
	    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
	    return set;
	  };
	  function d3_Set() {
	    this._ = Object.create(null);
	  }
	  d3_class(d3_Set, {
	    has: d3_map_has,
	    add: function(key) {
	      this._[d3_map_escape(key += "")] = true;
	      return key;
	    },
	    remove: d3_map_remove,
	    values: d3_map_keys,
	    size: d3_map_size,
	    empty: d3_map_empty,
	    forEach: function(f) {
	      for (var key in this._) f.call(this, d3_map_unescape(key));
	    }
	  });
	  d3.behavior = {};
	  function d3_identity(d) {
	    return d;
	  }
	  d3.rebind = function(target, source) {
	    var i = 1, n = arguments.length, method;
	    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
	    return target;
	  };
	  function d3_rebind(target, source, method) {
	    return function() {
	      var value = method.apply(source, arguments);
	      return value === source ? target : value;
	    };
	  }
	  function d3_vendorSymbol(object, name) {
	    if (name in object) return name;
	    name = name.charAt(0).toUpperCase() + name.slice(1);
	    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
	      var prefixName = d3_vendorPrefixes[i] + name;
	      if (prefixName in object) return prefixName;
	    }
	  }
	  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
	  function d3_noop() {}
	  d3.dispatch = function() {
	    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    return dispatch;
	  };
	  function d3_dispatch() {}
	  d3_dispatch.prototype.on = function(type, listener) {
	    var i = type.indexOf("."), name = "";
	    if (i >= 0) {
	      name = type.slice(i + 1);
	      type = type.slice(0, i);
	    }
	    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
	    if (arguments.length === 2) {
	      if (listener == null) for (type in this) {
	        if (this.hasOwnProperty(type)) this[type].on(name, null);
	      }
	      return this;
	    }
	  };
	  function d3_dispatch_event(dispatch) {
	    var listeners = [], listenerByName = new d3_Map();
	    function event() {
	      var z = listeners, i = -1, n = z.length, l;
	      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
	      return dispatch;
	    }
	    event.on = function(name, listener) {
	      var l = listenerByName.get(name), i;
	      if (arguments.length < 2) return l && l.on;
	      if (l) {
	        l.on = null;
	        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
	        listenerByName.remove(name);
	      }
	      if (listener) listeners.push(listenerByName.set(name, {
	        on: listener
	      }));
	      return dispatch;
	    };
	    return event;
	  }
	  d3.event = null;
	  function d3_eventPreventDefault() {
	    d3.event.preventDefault();
	  }
	  function d3_eventSource() {
	    var e = d3.event, s;
	    while (s = e.sourceEvent) e = s;
	    return e;
	  }
	  function d3_eventDispatch(target) {
	    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
	    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
	    dispatch.of = function(thiz, argumentz) {
	      return function(e1) {
	        try {
	          var e0 = e1.sourceEvent = d3.event;
	          e1.target = target;
	          d3.event = e1;
	          dispatch[e1.type].apply(thiz, argumentz);
	        } finally {
	          d3.event = e0;
	        }
	      };
	    };
	    return dispatch;
	  }
	  d3.requote = function(s) {
	    return s.replace(d3_requote_re, "\\$&");
	  };
	  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
	  var d3_subclass = {}.__proto__ ? function(object, prototype) {
	    object.__proto__ = prototype;
	  } : function(object, prototype) {
	    for (var property in prototype) object[property] = prototype[property];
	  };
	  function d3_selection(groups) {
	    d3_subclass(groups, d3_selectionPrototype);
	    return groups;
	  }
	  var d3_select = function(s, n) {
	    return n.querySelector(s);
	  }, d3_selectAll = function(s, n) {
	    return n.querySelectorAll(s);
	  }, d3_selectMatches = function(n, s) {
	    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
	    d3_selectMatches = function(n, s) {
	      return d3_selectMatcher.call(n, s);
	    };
	    return d3_selectMatches(n, s);
	  };
	  if (typeof Sizzle === "function") {
	    d3_select = function(s, n) {
	      return Sizzle(s, n)[0] || null;
	    };
	    d3_selectAll = Sizzle;
	    d3_selectMatches = Sizzle.matchesSelector;
	  }
	  d3.selection = function() {
	    return d3.select(d3_document.documentElement);
	  };
	  var d3_selectionPrototype = d3.selection.prototype = [];
	  d3_selectionPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, group, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
	          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selector(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_select(selector, this);
	    };
	  }
	  d3_selectionPrototype.selectAll = function(selector) {
	    var subgroups = [], subgroup, node;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
	          subgroup.parentNode = node;
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_selectorAll(selector) {
	    return typeof selector === "function" ? selector : function() {
	      return d3_selectAll(selector, this);
	    };
	  }
	  var d3_nsPrefix = {
	    svg: "http://www.w3.org/2000/svg",
	    xhtml: "http://www.w3.org/1999/xhtml",
	    xlink: "http://www.w3.org/1999/xlink",
	    xml: "http://www.w3.org/XML/1998/namespace",
	    xmlns: "http://www.w3.org/2000/xmlns/"
	  };
	  d3.ns = {
	    prefix: d3_nsPrefix,
	    qualify: function(name) {
	      var i = name.indexOf(":"), prefix = name;
	      if (i >= 0) {
	        prefix = name.slice(0, i);
	        name = name.slice(i + 1);
	      }
	      return d3_nsPrefix.hasOwnProperty(prefix) ? {
	        space: d3_nsPrefix[prefix],
	        local: name
	      } : name;
	    }
	  };
	  d3_selectionPrototype.attr = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node();
	        name = d3.ns.qualify(name);
	        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
	      }
	      for (value in name) this.each(d3_selection_attr(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_attr(name, value));
	  };
	  function d3_selection_attr(name, value) {
	    name = d3.ns.qualify(name);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrConstant() {
	      this.setAttribute(name, value);
	    }
	    function attrConstantNS() {
	      this.setAttributeNS(name.space, name.local, value);
	    }
	    function attrFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
	    }
	    function attrFunctionNS() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
	    }
	    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
	  }
	  function d3_collapse(s) {
	    return s.trim().replace(/\s+/g, " ");
	  }
	  d3_selectionPrototype.classed = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") {
	        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
	        if (value = node.classList) {
	          while (++i < n) if (!value.contains(name[i])) return false;
	        } else {
	          value = node.getAttribute("class");
	          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
	        }
	        return true;
	      }
	      for (value in name) this.each(d3_selection_classed(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_classed(name, value));
	  };
	  function d3_selection_classedRe(name) {
	    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
	  }
	  function d3_selection_classes(name) {
	    return (name + "").trim().split(/^|\s+/);
	  }
	  function d3_selection_classed(name, value) {
	    name = d3_selection_classes(name).map(d3_selection_classedName);
	    var n = name.length;
	    function classedConstant() {
	      var i = -1;
	      while (++i < n) name[i](this, value);
	    }
	    function classedFunction() {
	      var i = -1, x = value.apply(this, arguments);
	      while (++i < n) name[i](this, x);
	    }
	    return typeof value === "function" ? classedFunction : classedConstant;
	  }
	  function d3_selection_classedName(name) {
	    var re = d3_selection_classedRe(name);
	    return function(node, value) {
	      if (c = node.classList) return value ? c.add(name) : c.remove(name);
	      var c = node.getAttribute("class") || "";
	      if (value) {
	        re.lastIndex = 0;
	        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
	      } else {
	        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
	      }
	    };
	  }
	  d3_selectionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
	        return this;
	      }
	      if (n < 2) {
	        var node = this.node();
	        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
	      }
	      priority = "";
	    }
	    return this.each(d3_selection_style(name, value, priority));
	  };
	  function d3_selection_style(name, value, priority) {
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleConstant() {
	      this.style.setProperty(name, value, priority);
	    }
	    function styleFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
	    }
	    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
	  }
	  d3_selectionPrototype.property = function(name, value) {
	    if (arguments.length < 2) {
	      if (typeof name === "string") return this.node()[name];
	      for (value in name) this.each(d3_selection_property(value, name[value]));
	      return this;
	    }
	    return this.each(d3_selection_property(name, value));
	  };
	  function d3_selection_property(name, value) {
	    function propertyNull() {
	      delete this[name];
	    }
	    function propertyConstant() {
	      this[name] = value;
	    }
	    function propertyFunction() {
	      var x = value.apply(this, arguments);
	      if (x == null) delete this[name]; else this[name] = x;
	    }
	    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
	  }
	  d3_selectionPrototype.text = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.textContent = v == null ? "" : v;
	    } : value == null ? function() {
	      this.textContent = "";
	    } : function() {
	      this.textContent = value;
	    }) : this.node().textContent;
	  };
	  d3_selectionPrototype.html = function(value) {
	    return arguments.length ? this.each(typeof value === "function" ? function() {
	      var v = value.apply(this, arguments);
	      this.innerHTML = v == null ? "" : v;
	    } : value == null ? function() {
	      this.innerHTML = "";
	    } : function() {
	      this.innerHTML = value;
	    }) : this.node().innerHTML;
	  };
	  d3_selectionPrototype.append = function(name) {
	    name = d3_selection_creator(name);
	    return this.select(function() {
	      return this.appendChild(name.apply(this, arguments));
	    });
	  };
	  function d3_selection_creator(name) {
	    function create() {
	      var document = this.ownerDocument, namespace = this.namespaceURI;
	      return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
	    }
	    function createNS() {
	      return this.ownerDocument.createElementNS(name.space, name.local);
	    }
	    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
	  }
	  d3_selectionPrototype.insert = function(name, before) {
	    name = d3_selection_creator(name);
	    before = d3_selection_selector(before);
	    return this.select(function() {
	      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
	    });
	  };
	  d3_selectionPrototype.remove = function() {
	    return this.each(d3_selectionRemove);
	  };
	  function d3_selectionRemove() {
	    var parent = this.parentNode;
	    if (parent) parent.removeChild(this);
	  }
	  d3_selectionPrototype.data = function(value, key) {
	    var i = -1, n = this.length, group, node;
	    if (!arguments.length) {
	      value = new Array(n = (group = this[0]).length);
	      while (++i < n) {
	        if (node = group[i]) {
	          value[i] = node.__data__;
	        }
	      }
	      return value;
	    }
	    function bind(group, groupData) {
	      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
	      if (key) {
	        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
	        for (i = -1; ++i < n; ) {
	          if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
	            exitNodes[i] = node;
	          } else {
	            nodeByKeyValue.set(keyValue, node);
	          }
	          keyValues[i] = keyValue;
	        }
	        for (i = -1; ++i < m; ) {
	          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          } else if (node !== true) {
	            updateNodes[i] = node;
	            node.__data__ = nodeData;
	          }
	          nodeByKeyValue.set(keyValue, true);
	        }
	        for (i = -1; ++i < n; ) {
	          if (nodeByKeyValue.get(keyValues[i]) !== true) {
	            exitNodes[i] = group[i];
	          }
	        }
	      } else {
	        for (i = -1; ++i < n0; ) {
	          node = group[i];
	          nodeData = groupData[i];
	          if (node) {
	            node.__data__ = nodeData;
	            updateNodes[i] = node;
	          } else {
	            enterNodes[i] = d3_selection_dataNode(nodeData);
	          }
	        }
	        for (;i < m; ++i) {
	          enterNodes[i] = d3_selection_dataNode(groupData[i]);
	        }
	        for (;i < n; ++i) {
	          exitNodes[i] = group[i];
	        }
	      }
	      enterNodes.update = updateNodes;
	      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
	      enter.push(enterNodes);
	      update.push(updateNodes);
	      exit.push(exitNodes);
	    }
	    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
	    if (typeof value === "function") {
	      while (++i < n) {
	        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
	      }
	    } else {
	      while (++i < n) {
	        bind(group = this[i], value);
	      }
	    }
	    update.enter = function() {
	      return enter;
	    };
	    update.exit = function() {
	      return exit;
	    };
	    return update;
	  };
	  function d3_selection_dataNode(data) {
	    return {
	      __data__: data
	    };
	  }
	  d3_selectionPrototype.datum = function(value) {
	    return arguments.length ? this.property("__data__", value) : this.property("__data__");
	  };
	  d3_selectionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = (group = this[j]).parentNode;
	      for (var i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  function d3_selection_filter(selector) {
	    return function() {
	      return d3_selectMatches(this, selector);
	    };
	  }
	  d3_selectionPrototype.order = function() {
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
	        if (node = group[i]) {
	          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	          next = node;
	        }
	      }
	    }
	    return this;
	  };
	  d3_selectionPrototype.sort = function(comparator) {
	    comparator = d3_selection_sortComparator.apply(this, arguments);
	    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
	    return this.order();
	  };
	  function d3_selection_sortComparator(comparator) {
	    if (!arguments.length) comparator = d3_ascending;
	    return function(a, b) {
	      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
	    };
	  }
	  d3_selectionPrototype.each = function(callback) {
	    return d3_selection_each(this, function(node, i, j) {
	      callback.call(node, node.__data__, i, j);
	    });
	  };
	  function d3_selection_each(groups, callback) {
	    for (var j = 0, m = groups.length; j < m; j++) {
	      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
	        if (node = group[i]) callback(node, i, j);
	      }
	    }
	    return groups;
	  }
	  d3_selectionPrototype.call = function(callback) {
	    var args = d3_array(arguments);
	    callback.apply(args[0] = this, args);
	    return this;
	  };
	  d3_selectionPrototype.empty = function() {
	    return !this.node();
	  };
	  d3_selectionPrototype.node = function() {
	    for (var j = 0, m = this.length; j < m; j++) {
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        var node = group[i];
	        if (node) return node;
	      }
	    }
	    return null;
	  };
	  d3_selectionPrototype.size = function() {
	    var n = 0;
	    d3_selection_each(this, function() {
	      ++n;
	    });
	    return n;
	  };
	  function d3_selection_enter(selection) {
	    d3_subclass(selection, d3_selection_enterPrototype);
	    return selection;
	  }
	  var d3_selection_enterPrototype = [];
	  d3.selection.enter = d3_selection_enter;
	  d3.selection.enter.prototype = d3_selection_enterPrototype;
	  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
	  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
	  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
	  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
	  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
	  d3_selection_enterPrototype.select = function(selector) {
	    var subgroups = [], subgroup, subnode, upgroup, group, node;
	    for (var j = -1, m = this.length; ++j < m; ) {
	      upgroup = (group = this[j]).update;
	      subgroups.push(subgroup = []);
	      subgroup.parentNode = group.parentNode;
	      for (var i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
	          subnode.__data__ = node.__data__;
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_selection(subgroups);
	  };
	  d3_selection_enterPrototype.insert = function(name, before) {
	    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
	    return d3_selectionPrototype.insert.call(this, name, before);
	  };
	  function d3_selection_enterInsertBefore(enter) {
	    var i0, j0;
	    return function(d, i, j) {
	      var group = enter[j].update, n = group.length, node;
	      if (j != j0) j0 = j, i0 = 0;
	      if (i >= i0) i0 = i + 1;
	      while (!(node = group[i0]) && ++i0 < n) ;
	      return node;
	    };
	  }
	  d3.select = function(node) {
	    var group;
	    if (typeof node === "string") {
	      group = [ d3_select(node, d3_document) ];
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = [ node ];
	      group.parentNode = d3_documentElement(node);
	    }
	    return d3_selection([ group ]);
	  };
	  d3.selectAll = function(nodes) {
	    var group;
	    if (typeof nodes === "string") {
	      group = d3_array(d3_selectAll(nodes, d3_document));
	      group.parentNode = d3_document.documentElement;
	    } else {
	      group = nodes;
	      group.parentNode = null;
	    }
	    return d3_selection([ group ]);
	  };
	  d3_selectionPrototype.on = function(type, listener, capture) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof type !== "string") {
	        if (n < 2) listener = false;
	        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
	        return this;
	      }
	      if (n < 2) return (n = this.node()["__on" + type]) && n._;
	      capture = false;
	    }
	    return this.each(d3_selection_on(type, listener, capture));
	  };
	  function d3_selection_on(type, listener, capture) {
	    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
	    if (i > 0) type = type.slice(0, i);
	    var filter = d3_selection_onFilters.get(type);
	    if (filter) type = filter, wrap = d3_selection_onFilter;
	    function onRemove() {
	      var l = this[name];
	      if (l) {
	        this.removeEventListener(type, l, l.$);
	        delete this[name];
	      }
	    }
	    function onAdd() {
	      var l = wrap(listener, d3_array(arguments));
	      onRemove.call(this);
	      this.addEventListener(type, this[name] = l, l.$ = capture);
	      l._ = listener;
	    }
	    function removeAll() {
	      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
	      for (var name in this) {
	        if (match = name.match(re)) {
	          var l = this[name];
	          this.removeEventListener(match[1], l, l.$);
	          delete this[name];
	        }
	      }
	    }
	    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
	  }
	  var d3_selection_onFilters = d3.map({
	    mouseenter: "mouseover",
	    mouseleave: "mouseout"
	  });
	  if (d3_document) {
	    d3_selection_onFilters.forEach(function(k) {
	      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
	    });
	  }
	  function d3_selection_onListener(listener, argumentz) {
	    return function(e) {
	      var o = d3.event;
	      d3.event = e;
	      argumentz[0] = this.__data__;
	      try {
	        listener.apply(this, argumentz);
	      } finally {
	        d3.event = o;
	      }
	    };
	  }
	  function d3_selection_onFilter(listener, argumentz) {
	    var l = d3_selection_onListener(listener, argumentz);
	    return function(e) {
	      var target = this, related = e.relatedTarget;
	      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
	        l.call(target, e);
	      }
	    };
	  }
	  var d3_event_dragSelect, d3_event_dragId = 0;
	  function d3_event_dragSuppress(node) {
	    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
	    if (d3_event_dragSelect == null) {
	      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
	    }
	    if (d3_event_dragSelect) {
	      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
	      style[d3_event_dragSelect] = "none";
	    }
	    return function(suppressClick) {
	      w.on(name, null);
	      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
	      if (suppressClick) {
	        var off = function() {
	          w.on(click, null);
	        };
	        w.on(click, function() {
	          d3_eventPreventDefault();
	          off();
	        }, true);
	        setTimeout(off, 0);
	      }
	    };
	  }
	  d3.mouse = function(container) {
	    return d3_mousePoint(container, d3_eventSource());
	  };
	  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
	  function d3_mousePoint(container, e) {
	    if (e.changedTouches) e = e.changedTouches[0];
	    var svg = container.ownerSVGElement || container;
	    if (svg.createSVGPoint) {
	      var point = svg.createSVGPoint();
	      if (d3_mouse_bug44083 < 0) {
	        var window = d3_window(container);
	        if (window.scrollX || window.scrollY) {
	          svg = d3.select("body").append("svg").style({
	            position: "absolute",
	            top: 0,
	            left: 0,
	            margin: 0,
	            padding: 0,
	            border: "none"
	          }, "important");
	          var ctm = svg[0][0].getScreenCTM();
	          d3_mouse_bug44083 = !(ctm.f || ctm.e);
	          svg.remove();
	        }
	      }
	      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
	      point.y = e.clientY;
	      point = point.matrixTransform(container.getScreenCTM().inverse());
	      return [ point.x, point.y ];
	    }
	    var rect = container.getBoundingClientRect();
	    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
	  }
	  d3.touch = function(container, touches, identifier) {
	    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
	    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
	      if ((touch = touches[i]).identifier === identifier) {
	        return d3_mousePoint(container, touch);
	      }
	    }
	  };
	  d3.behavior.drag = function() {
	    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
	    function drag() {
	      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
	    }
	    function dragstart(id, position, subject, move, end) {
	      return function() {
	        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
	        if (origin) {
	          dragOffset = origin.apply(that, arguments);
	          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
	        } else {
	          dragOffset = [ 0, 0 ];
	        }
	        dispatch({
	          type: "dragstart"
	        });
	        function moved() {
	          var position1 = position(parent, dragId), dx, dy;
	          if (!position1) return;
	          dx = position1[0] - position0[0];
	          dy = position1[1] - position0[1];
	          dragged |= dx | dy;
	          position0 = position1;
	          dispatch({
	            type: "drag",
	            x: position1[0] + dragOffset[0],
	            y: position1[1] + dragOffset[1],
	            dx: dx,
	            dy: dy
	          });
	        }
	        function ended() {
	          if (!position(parent, dragId)) return;
	          dragSubject.on(move + dragName, null).on(end + dragName, null);
	          dragRestore(dragged && d3.event.target === target);
	          dispatch({
	            type: "dragend"
	          });
	        }
	      };
	    }
	    drag.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return drag;
	    };
	    return d3.rebind(drag, event, "on");
	  };
	  function d3_behavior_dragTouchId() {
	    return d3.event.changedTouches[0].identifier;
	  }
	  d3.touches = function(container, touches) {
	    if (arguments.length < 2) touches = d3_eventSource().touches;
	    return touches ? d3_array(touches).map(function(touch) {
	      var point = d3_mousePoint(container, touch);
	      point.identifier = touch.identifier;
	      return point;
	    }) : [];
	  };
	  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
	  function d3_sgn(x) {
	    return x > 0 ? 1 : x < 0 ? -1 : 0;
	  }
	  function d3_cross2d(a, b, c) {
	    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	  }
	  function d3_acos(x) {
	    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
	  }
	  function d3_asin(x) {
	    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
	  }
	  function d3_sinh(x) {
	    return ((x = Math.exp(x)) - 1 / x) / 2;
	  }
	  function d3_cosh(x) {
	    return ((x = Math.exp(x)) + 1 / x) / 2;
	  }
	  function d3_tanh(x) {
	    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	  }
	  function d3_haversin(x) {
	    return (x = Math.sin(x / 2)) * x;
	  }
	  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
	  d3.interpolateZoom = function(p0, p1) {
	    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
	    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
	    function interpolate(t) {
	      var s = t * S;
	      if (dr) {
	        var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
	        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
	      }
	      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
	    }
	    interpolate.duration = S * 1e3;
	    return interpolate;
	  };
	  d3.behavior.zoom = function() {
	    var view = {
	      x: 0,
	      y: 0,
	      k: 1
	    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
	    if (!d3_behavior_zoomWheel) {
	      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
	      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
	        return d3.event.wheelDelta;
	      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
	        return -d3.event.detail;
	      }, "MozMousePixelScroll");
	    }
	    function zoom(g) {
	      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
	    }
	    zoom.event = function(g) {
	      g.each(function() {
	        var dispatch = event.of(this, arguments), view1 = view;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.zoom", function() {
	            view = this.__chart__ || {
	              x: 0,
	              y: 0,
	              k: 1
	            };
	            zoomstarted(dispatch);
	          }).tween("zoom:zoom", function() {
	            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
	            return function(t) {
	              var l = i(t), k = dx / l[2];
	              this.__chart__ = view = {
	                x: cx - l[0] * k,
	                y: cy - l[1] * k,
	                k: k
	              };
	              zoomed(dispatch);
	            };
	          }).each("interrupt.zoom", function() {
	            zoomended(dispatch);
	          }).each("end.zoom", function() {
	            zoomended(dispatch);
	          });
	        } else {
	          this.__chart__ = view;
	          zoomstarted(dispatch);
	          zoomed(dispatch);
	          zoomended(dispatch);
	        }
	      });
	    };
	    zoom.translate = function(_) {
	      if (!arguments.length) return [ view.x, view.y ];
	      view = {
	        x: +_[0],
	        y: +_[1],
	        k: view.k
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scale = function(_) {
	      if (!arguments.length) return view.k;
	      view = {
	        x: view.x,
	        y: view.y,
	        k: +_
	      };
	      rescale();
	      return zoom;
	    };
	    zoom.scaleExtent = function(_) {
	      if (!arguments.length) return scaleExtent;
	      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.center = function(_) {
	      if (!arguments.length) return center;
	      center = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.size = function(_) {
	      if (!arguments.length) return size;
	      size = _ && [ +_[0], +_[1] ];
	      return zoom;
	    };
	    zoom.duration = function(_) {
	      if (!arguments.length) return duration;
	      duration = +_;
	      return zoom;
	    };
	    zoom.x = function(z) {
	      if (!arguments.length) return x1;
	      x1 = z;
	      x0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    zoom.y = function(z) {
	      if (!arguments.length) return y1;
	      y1 = z;
	      y0 = z.copy();
	      view = {
	        x: 0,
	        y: 0,
	        k: 1
	      };
	      return zoom;
	    };
	    function location(p) {
	      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
	    }
	    function point(l) {
	      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
	    }
	    function scaleTo(s) {
	      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
	    }
	    function translateTo(p, l) {
	      l = point(l);
	      view.x += p[0] - l[0];
	      view.y += p[1] - l[1];
	    }
	    function zoomTo(that, p, l, k) {
	      that.__chart__ = {
	        x: view.x,
	        y: view.y,
	        k: view.k
	      };
	      scaleTo(Math.pow(2, k));
	      translateTo(center0 = p, l);
	      that = d3.select(that);
	      if (duration > 0) that = that.transition().duration(duration);
	      that.call(zoom.event);
	    }
	    function rescale() {
	      if (x1) x1.domain(x0.range().map(function(x) {
	        return (x - view.x) / view.k;
	      }).map(x0.invert));
	      if (y1) y1.domain(y0.range().map(function(y) {
	        return (y - view.y) / view.k;
	      }).map(y0.invert));
	    }
	    function zoomstarted(dispatch) {
	      if (!zooming++) dispatch({
	        type: "zoomstart"
	      });
	    }
	    function zoomed(dispatch) {
	      rescale();
	      dispatch({
	        type: "zoom",
	        scale: view.k,
	        translate: [ view.x, view.y ]
	      });
	    }
	    function zoomended(dispatch) {
	      if (!--zooming) dispatch({
	        type: "zoomend"
	      });
	      center0 = null;
	    }
	    function mousedowned() {
	      var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
	      d3_selection_interrupt.call(that);
	      zoomstarted(dispatch);
	      function moved() {
	        dragged = 1;
	        translateTo(d3.mouse(that), location0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        subject.on(mousemove, null).on(mouseup, null);
	        dragRestore(dragged && d3.event.target === target);
	        zoomended(dispatch);
	      }
	    }
	    function touchstarted() {
	      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
	      started();
	      zoomstarted(dispatch);
	      subject.on(mousedown, null).on(touchstart, started);
	      function relocate() {
	        var touches = d3.touches(that);
	        scale0 = view.k;
	        touches.forEach(function(t) {
	          if (t.identifier in locations0) locations0[t.identifier] = location(t);
	        });
	        return touches;
	      }
	      function started() {
	        var target = d3.event.target;
	        d3.select(target).on(touchmove, moved).on(touchend, ended);
	        targets.push(target);
	        var changed = d3.event.changedTouches;
	        for (var i = 0, n = changed.length; i < n; ++i) {
	          locations0[changed[i].identifier] = null;
	        }
	        var touches = relocate(), now = Date.now();
	        if (touches.length === 1) {
	          if (now - touchtime < 500) {
	            var p = touches[0];
	            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
	            d3_eventPreventDefault();
	          }
	          touchtime = now;
	        } else if (touches.length > 1) {
	          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
	          distance0 = dx * dx + dy * dy;
	        }
	      }
	      function moved() {
	        var touches = d3.touches(that), p0, l0, p1, l1;
	        d3_selection_interrupt.call(that);
	        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
	          p1 = touches[i];
	          if (l1 = locations0[p1.identifier]) {
	            if (l0) break;
	            p0 = p1, l0 = l1;
	          }
	        }
	        if (l1) {
	          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
	          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
	          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
	          scaleTo(scale1 * scale0);
	        }
	        touchtime = null;
	        translateTo(p0, l0);
	        zoomed(dispatch);
	      }
	      function ended() {
	        if (d3.event.touches.length) {
	          var changed = d3.event.changedTouches;
	          for (var i = 0, n = changed.length; i < n; ++i) {
	            delete locations0[changed[i].identifier];
	          }
	          for (var identifier in locations0) {
	            return void relocate();
	          }
	        }
	        d3.selectAll(targets).on(zoomName, null);
	        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
	        dragRestore();
	        zoomended(dispatch);
	      }
	    }
	    function mousewheeled() {
	      var dispatch = event.of(this, arguments);
	      if (mousewheelTimer) clearTimeout(mousewheelTimer); else translate0 = location(center0 = center || d3.mouse(this)), 
	      d3_selection_interrupt.call(this), zoomstarted(dispatch);
	      mousewheelTimer = setTimeout(function() {
	        mousewheelTimer = null;
	        zoomended(dispatch);
	      }, 50);
	      d3_eventPreventDefault();
	      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
	      translateTo(center0, translate0);
	      zoomed(dispatch);
	    }
	    function dblclicked() {
	      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
	      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
	    }
	    return d3.rebind(zoom, event, "on");
	  };
	  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
	  d3.color = d3_color;
	  function d3_color() {}
	  d3_color.prototype.toString = function() {
	    return this.rgb() + "";
	  };
	  d3.hsl = d3_hsl;
	  function d3_hsl(h, s, l) {
	    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
	  }
	  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
	  d3_hslPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, this.l / k);
	  };
	  d3_hslPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_hsl(this.h, this.s, k * this.l);
	  };
	  d3_hslPrototype.rgb = function() {
	    return d3_hsl_rgb(this.h, this.s, this.l);
	  };
	  function d3_hsl_rgb(h, s, l) {
	    var m1, m2;
	    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
	    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
	    l = l < 0 ? 0 : l > 1 ? 1 : l;
	    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
	    m1 = 2 * l - m2;
	    function v(h) {
	      if (h > 360) h -= 360; else if (h < 0) h += 360;
	      if (h < 60) return m1 + (m2 - m1) * h / 60;
	      if (h < 180) return m2;
	      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
	      return m1;
	    }
	    function vv(h) {
	      return Math.round(v(h) * 255);
	    }
	    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
	  }
	  d3.hcl = d3_hcl;
	  function d3_hcl(h, c, l) {
	    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
	  }
	  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
	  d3_hclPrototype.brighter = function(k) {
	    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.darker = function(k) {
	    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
	  };
	  d3_hclPrototype.rgb = function() {
	    return d3_hcl_lab(this.h, this.c, this.l).rgb();
	  };
	  function d3_hcl_lab(h, c, l) {
	    if (isNaN(h)) h = 0;
	    if (isNaN(c)) c = 0;
	    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
	  }
	  d3.lab = d3_lab;
	  function d3_lab(l, a, b) {
	    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
	  }
	  var d3_lab_K = 18;
	  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
	  var d3_labPrototype = d3_lab.prototype = new d3_color();
	  d3_labPrototype.brighter = function(k) {
	    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.darker = function(k) {
	    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
	  };
	  d3_labPrototype.rgb = function() {
	    return d3_lab_rgb(this.l, this.a, this.b);
	  };
	  function d3_lab_rgb(l, a, b) {
	    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
	    x = d3_lab_xyz(x) * d3_lab_X;
	    y = d3_lab_xyz(y) * d3_lab_Y;
	    z = d3_lab_xyz(z) * d3_lab_Z;
	    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
	  }
	  function d3_lab_hcl(l, a, b) {
	    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
	  }
	  function d3_lab_xyz(x) {
	    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
	  }
	  function d3_xyz_lab(x) {
	    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
	  }
	  function d3_xyz_rgb(r) {
	    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
	  }
	  d3.rgb = d3_rgb;
	  function d3_rgb(r, g, b) {
	    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
	  }
	  function d3_rgbNumber(value) {
	    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
	  }
	  function d3_rgbString(value) {
	    return d3_rgbNumber(value) + "";
	  }
	  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
	  d3_rgbPrototype.brighter = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    var r = this.r, g = this.g, b = this.b, i = 30;
	    if (!r && !g && !b) return new d3_rgb(i, i, i);
	    if (r && r < i) r = i;
	    if (g && g < i) g = i;
	    if (b && b < i) b = i;
	    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
	  };
	  d3_rgbPrototype.darker = function(k) {
	    k = Math.pow(.7, arguments.length ? k : 1);
	    return new d3_rgb(k * this.r, k * this.g, k * this.b);
	  };
	  d3_rgbPrototype.hsl = function() {
	    return d3_rgb_hsl(this.r, this.g, this.b);
	  };
	  d3_rgbPrototype.toString = function() {
	    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
	  };
	  function d3_rgb_hex(v) {
	    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
	  }
	  function d3_rgb_parse(format, rgb, hsl) {
	    var r = 0, g = 0, b = 0, m1, m2, color;
	    m1 = /([a-z]+)\((.*)\)/i.exec(format);
	    if (m1) {
	      m2 = m1[2].split(",");
	      switch (m1[1]) {
	       case "hsl":
	        {
	          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
	        }
	
	       case "rgb":
	        {
	          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
	        }
	      }
	    }
	    if (color = d3_rgb_names.get(format.toLowerCase())) {
	      return rgb(color.r, color.g, color.b);
	    }
	    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
	      if (format.length === 4) {
	        r = (color & 3840) >> 4;
	        r = r >> 4 | r;
	        g = color & 240;
	        g = g >> 4 | g;
	        b = color & 15;
	        b = b << 4 | b;
	      } else if (format.length === 7) {
	        r = (color & 16711680) >> 16;
	        g = (color & 65280) >> 8;
	        b = color & 255;
	      }
	    }
	    return rgb(r, g, b);
	  }
	  function d3_rgb_hsl(r, g, b) {
	    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
	    if (d) {
	      s = l < .5 ? d / (max + min) : d / (2 - max - min);
	      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
	      h *= 60;
	    } else {
	      h = NaN;
	      s = l > 0 && l < 1 ? 0 : h;
	    }
	    return new d3_hsl(h, s, l);
	  }
	  function d3_rgb_lab(r, g, b) {
	    r = d3_rgb_xyz(r);
	    g = d3_rgb_xyz(g);
	    b = d3_rgb_xyz(b);
	    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
	    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
	  }
	  function d3_rgb_xyz(r) {
	    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
	  }
	  function d3_rgb_parseNumber(c) {
	    var f = parseFloat(c);
	    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
	  }
	  var d3_rgb_names = d3.map({
	    aliceblue: 15792383,
	    antiquewhite: 16444375,
	    aqua: 65535,
	    aquamarine: 8388564,
	    azure: 15794175,
	    beige: 16119260,
	    bisque: 16770244,
	    black: 0,
	    blanchedalmond: 16772045,
	    blue: 255,
	    blueviolet: 9055202,
	    brown: 10824234,
	    burlywood: 14596231,
	    cadetblue: 6266528,
	    chartreuse: 8388352,
	    chocolate: 13789470,
	    coral: 16744272,
	    cornflowerblue: 6591981,
	    cornsilk: 16775388,
	    crimson: 14423100,
	    cyan: 65535,
	    darkblue: 139,
	    darkcyan: 35723,
	    darkgoldenrod: 12092939,
	    darkgray: 11119017,
	    darkgreen: 25600,
	    darkgrey: 11119017,
	    darkkhaki: 12433259,
	    darkmagenta: 9109643,
	    darkolivegreen: 5597999,
	    darkorange: 16747520,
	    darkorchid: 10040012,
	    darkred: 9109504,
	    darksalmon: 15308410,
	    darkseagreen: 9419919,
	    darkslateblue: 4734347,
	    darkslategray: 3100495,
	    darkslategrey: 3100495,
	    darkturquoise: 52945,
	    darkviolet: 9699539,
	    deeppink: 16716947,
	    deepskyblue: 49151,
	    dimgray: 6908265,
	    dimgrey: 6908265,
	    dodgerblue: 2003199,
	    firebrick: 11674146,
	    floralwhite: 16775920,
	    forestgreen: 2263842,
	    fuchsia: 16711935,
	    gainsboro: 14474460,
	    ghostwhite: 16316671,
	    gold: 16766720,
	    goldenrod: 14329120,
	    gray: 8421504,
	    green: 32768,
	    greenyellow: 11403055,
	    grey: 8421504,
	    honeydew: 15794160,
	    hotpink: 16738740,
	    indianred: 13458524,
	    indigo: 4915330,
	    ivory: 16777200,
	    khaki: 15787660,
	    lavender: 15132410,
	    lavenderblush: 16773365,
	    lawngreen: 8190976,
	    lemonchiffon: 16775885,
	    lightblue: 11393254,
	    lightcoral: 15761536,
	    lightcyan: 14745599,
	    lightgoldenrodyellow: 16448210,
	    lightgray: 13882323,
	    lightgreen: 9498256,
	    lightgrey: 13882323,
	    lightpink: 16758465,
	    lightsalmon: 16752762,
	    lightseagreen: 2142890,
	    lightskyblue: 8900346,
	    lightslategray: 7833753,
	    lightslategrey: 7833753,
	    lightsteelblue: 11584734,
	    lightyellow: 16777184,
	    lime: 65280,
	    limegreen: 3329330,
	    linen: 16445670,
	    magenta: 16711935,
	    maroon: 8388608,
	    mediumaquamarine: 6737322,
	    mediumblue: 205,
	    mediumorchid: 12211667,
	    mediumpurple: 9662683,
	    mediumseagreen: 3978097,
	    mediumslateblue: 8087790,
	    mediumspringgreen: 64154,
	    mediumturquoise: 4772300,
	    mediumvioletred: 13047173,
	    midnightblue: 1644912,
	    mintcream: 16121850,
	    mistyrose: 16770273,
	    moccasin: 16770229,
	    navajowhite: 16768685,
	    navy: 128,
	    oldlace: 16643558,
	    olive: 8421376,
	    olivedrab: 7048739,
	    orange: 16753920,
	    orangered: 16729344,
	    orchid: 14315734,
	    palegoldenrod: 15657130,
	    palegreen: 10025880,
	    paleturquoise: 11529966,
	    palevioletred: 14381203,
	    papayawhip: 16773077,
	    peachpuff: 16767673,
	    peru: 13468991,
	    pink: 16761035,
	    plum: 14524637,
	    powderblue: 11591910,
	    purple: 8388736,
	    rebeccapurple: 6697881,
	    red: 16711680,
	    rosybrown: 12357519,
	    royalblue: 4286945,
	    saddlebrown: 9127187,
	    salmon: 16416882,
	    sandybrown: 16032864,
	    seagreen: 3050327,
	    seashell: 16774638,
	    sienna: 10506797,
	    silver: 12632256,
	    skyblue: 8900331,
	    slateblue: 6970061,
	    slategray: 7372944,
	    slategrey: 7372944,
	    snow: 16775930,
	    springgreen: 65407,
	    steelblue: 4620980,
	    tan: 13808780,
	    teal: 32896,
	    thistle: 14204888,
	    tomato: 16737095,
	    turquoise: 4251856,
	    violet: 15631086,
	    wheat: 16113331,
	    white: 16777215,
	    whitesmoke: 16119285,
	    yellow: 16776960,
	    yellowgreen: 10145074
	  });
	  d3_rgb_names.forEach(function(key, value) {
	    d3_rgb_names.set(key, d3_rgbNumber(value));
	  });
	  function d3_functor(v) {
	    return typeof v === "function" ? v : function() {
	      return v;
	    };
	  }
	  d3.functor = d3_functor;
	  d3.xhr = d3_xhrType(d3_identity);
	  function d3_xhrType(response) {
	    return function(url, mimeType, callback) {
	      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
	      mimeType = null;
	      return d3_xhr(url, mimeType, response, callback);
	    };
	  }
	  function d3_xhr(url, mimeType, response, callback) {
	    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
	    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
	    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
	      request.readyState > 3 && respond();
	    };
	    function respond() {
	      var status = request.status, result;
	      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
	        try {
	          result = response.call(xhr, request);
	        } catch (e) {
	          dispatch.error.call(xhr, e);
	          return;
	        }
	        dispatch.load.call(xhr, result);
	      } else {
	        dispatch.error.call(xhr, request);
	      }
	    }
	    request.onprogress = function(event) {
	      var o = d3.event;
	      d3.event = event;
	      try {
	        dispatch.progress.call(xhr, request);
	      } finally {
	        d3.event = o;
	      }
	    };
	    xhr.header = function(name, value) {
	      name = (name + "").toLowerCase();
	      if (arguments.length < 2) return headers[name];
	      if (value == null) delete headers[name]; else headers[name] = value + "";
	      return xhr;
	    };
	    xhr.mimeType = function(value) {
	      if (!arguments.length) return mimeType;
	      mimeType = value == null ? null : value + "";
	      return xhr;
	    };
	    xhr.responseType = function(value) {
	      if (!arguments.length) return responseType;
	      responseType = value;
	      return xhr;
	    };
	    xhr.response = function(value) {
	      response = value;
	      return xhr;
	    };
	    [ "get", "post" ].forEach(function(method) {
	      xhr[method] = function() {
	        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
	      };
	    });
	    xhr.send = function(method, data, callback) {
	      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
	      request.open(method, url, true);
	      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
	      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
	      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
	      if (responseType != null) request.responseType = responseType;
	      if (callback != null) xhr.on("error", callback).on("load", function(request) {
	        callback(null, request);
	      });
	      dispatch.beforesend.call(xhr, request);
	      request.send(data == null ? null : data);
	      return xhr;
	    };
	    xhr.abort = function() {
	      request.abort();
	      return xhr;
	    };
	    d3.rebind(xhr, dispatch, "on");
	    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
	  }
	  function d3_xhr_fixCallback(callback) {
	    return callback.length === 1 ? function(error, request) {
	      callback(error == null ? request : null);
	    } : callback;
	  }
	  function d3_xhrHasResponse(request) {
	    var type = request.responseType;
	    return type && type !== "text" ? request.response : request.responseText;
	  }
	  d3.dsv = function(delimiter, mimeType) {
	    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
	    function dsv(url, row, callback) {
	      if (arguments.length < 3) callback = row, row = null;
	      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
	      xhr.row = function(_) {
	        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
	      };
	      return xhr;
	    }
	    function response(request) {
	      return dsv.parse(request.responseText);
	    }
	    function typedResponse(f) {
	      return function(request) {
	        return dsv.parse(request.responseText, f);
	      };
	    }
	    dsv.parse = function(text, f) {
	      var o;
	      return dsv.parseRows(text, function(row, i) {
	        if (o) return o(row, i - 1);
	        var a = new Function("d", "return {" + row.map(function(name, i) {
	          return JSON.stringify(name) + ": d[" + i + "]";
	        }).join(",") + "}");
	        o = f ? function(row, i) {
	          return f(a(row), i);
	        } : a;
	      });
	    };
	    dsv.parseRows = function(text, f) {
	      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
	      function token() {
	        if (I >= N) return EOF;
	        if (eol) return eol = false, EOL;
	        var j = I;
	        if (text.charCodeAt(j) === 34) {
	          var i = j;
	          while (i++ < N) {
	            if (text.charCodeAt(i) === 34) {
	              if (text.charCodeAt(i + 1) !== 34) break;
	              ++i;
	            }
	          }
	          I = i + 2;
	          var c = text.charCodeAt(i + 1);
	          if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(i + 2) === 10) ++I;
	          } else if (c === 10) {
	            eol = true;
	          }
	          return text.slice(j + 1, i).replace(/""/g, '"');
	        }
	        while (I < N) {
	          var c = text.charCodeAt(I++), k = 1;
	          if (c === 10) eol = true; else if (c === 13) {
	            eol = true;
	            if (text.charCodeAt(I) === 10) ++I, ++k;
	          } else if (c !== delimiterCode) continue;
	          return text.slice(j, I - k);
	        }
	        return text.slice(j);
	      }
	      while ((t = token()) !== EOF) {
	        var a = [];
	        while (t !== EOL && t !== EOF) {
	          a.push(t);
	          t = token();
	        }
	        if (f && (a = f(a, n++)) == null) continue;
	        rows.push(a);
	      }
	      return rows;
	    };
	    dsv.format = function(rows) {
	      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
	      var fieldSet = new d3_Set(), fields = [];
	      rows.forEach(function(row) {
	        for (var field in row) {
	          if (!fieldSet.has(field)) {
	            fields.push(fieldSet.add(field));
	          }
	        }
	      });
	      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
	        return fields.map(function(field) {
	          return formatValue(row[field]);
	        }).join(delimiter);
	      })).join("\n");
	    };
	    dsv.formatRows = function(rows) {
	      return rows.map(formatRow).join("\n");
	    };
	    function formatRow(row) {
	      return row.map(formatValue).join(delimiter);
	    }
	    function formatValue(text) {
	      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
	    }
	    return dsv;
	  };
	  d3.csv = d3.dsv(",", "text/csv");
	  d3.tsv = d3.dsv("	", "text/tab-separated-values");
	  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
	    setTimeout(callback, 17);
	  };
	  d3.timer = function(callback, delay, then) {
	    var n = arguments.length;
	    if (n < 2) delay = 0;
	    if (n < 3) then = Date.now();
	    var time = then + delay, timer = {
	      c: callback,
	      t: time,
	      f: false,
	      n: null
	    };
	    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
	    d3_timer_queueTail = timer;
	    if (!d3_timer_interval) {
	      d3_timer_timeout = clearTimeout(d3_timer_timeout);
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  };
	  function d3_timer_step() {
	    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
	    if (delay > 24) {
	      if (isFinite(delay)) {
	        clearTimeout(d3_timer_timeout);
	        d3_timer_timeout = setTimeout(d3_timer_step, delay);
	      }
	      d3_timer_interval = 0;
	    } else {
	      d3_timer_interval = 1;
	      d3_timer_frame(d3_timer_step);
	    }
	  }
	  d3.timer.flush = function() {
	    d3_timer_mark();
	    d3_timer_sweep();
	  };
	  function d3_timer_mark() {
	    var now = Date.now();
	    d3_timer_active = d3_timer_queueHead;
	    while (d3_timer_active) {
	      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
	      d3_timer_active = d3_timer_active.n;
	    }
	    return now;
	  }
	  function d3_timer_sweep() {
	    var t0, t1 = d3_timer_queueHead, time = Infinity;
	    while (t1) {
	      if (t1.f) {
	        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
	      } else {
	        if (t1.t < time) time = t1.t;
	        t1 = (t0 = t1).n;
	      }
	    }
	    d3_timer_queueTail = t0;
	    return time;
	  }
	  function d3_format_precision(x, p) {
	    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
	  }
	  d3.round = function(x, n) {
	    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
	  };
	  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
	  d3.formatPrefix = function(value, precision) {
	    var i = 0;
	    if (value) {
	      if (value < 0) value *= -1;
	      if (precision) value = d3.round(value, d3_format_precision(value, precision));
	      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
	      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
	    }
	    return d3_formatPrefixes[8 + i / 3];
	  };
	  function d3_formatPrefix(d, i) {
	    var k = Math.pow(10, abs(8 - i) * 3);
	    return {
	      scale: i > 8 ? function(d) {
	        return d / k;
	      } : function(d) {
	        return d * k;
	      },
	      symbol: d
	    };
	  }
	  function d3_locale_numberFormat(locale) {
	    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
	      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
	      while (i > 0 && g > 0) {
	        if (length + g + 1 > width) g = Math.max(1, width - length);
	        t.push(value.substring(i -= g, i + g));
	        if ((length += g + 1) > width) break;
	        g = locale_grouping[j = (j + 1) % locale_grouping.length];
	      }
	      return t.reverse().join(locale_thousands);
	    } : d3_identity;
	    return function(specifier) {
	      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
	      if (precision) precision = +precision.substring(1);
	      if (zfill || fill === "0" && align === "=") {
	        zfill = fill = "0";
	        align = "=";
	      }
	      switch (type) {
	       case "n":
	        comma = true;
	        type = "g";
	        break;
	
	       case "%":
	        scale = 100;
	        suffix = "%";
	        type = "f";
	        break;
	
	       case "p":
	        scale = 100;
	        suffix = "%";
	        type = "r";
	        break;
	
	       case "b":
	       case "o":
	       case "x":
	       case "X":
	        if (symbol === "#") prefix = "0" + type.toLowerCase();
	
	       case "c":
	        exponent = false;
	
	       case "d":
	        integer = true;
	        precision = 0;
	        break;
	
	       case "s":
	        scale = -1;
	        type = "r";
	        break;
	      }
	      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
	      if (type == "r" && !precision) type = "g";
	      if (precision != null) {
	        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
	      }
	      type = d3_format_types.get(type) || d3_format_typeDefault;
	      var zcomma = zfill && comma;
	      return function(value) {
	        var fullSuffix = suffix;
	        if (integer && value % 1) return "";
	        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
	        if (scale < 0) {
	          var unit = d3.formatPrefix(value, precision);
	          value = unit.scale(value);
	          fullSuffix = unit.symbol + suffix;
	        } else {
	          value *= scale;
	        }
	        value = type(value, precision);
	        var i = value.lastIndexOf("."), before, after;
	        if (i < 0) {
	          var j = exponent ? value.lastIndexOf("e") : -1;
	          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
	        } else {
	          before = value.substring(0, i);
	          after = locale_decimal + value.substring(i + 1);
	        }
	        if (!zfill && comma) before = formatGroup(before, Infinity);
	        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
	        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
	        negative += prefix;
	        value = before + after;
	        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
	      };
	    };
	  }
	  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
	  var d3_format_types = d3.map({
	    b: function(x) {
	      return x.toString(2);
	    },
	    c: function(x) {
	      return String.fromCharCode(x);
	    },
	    o: function(x) {
	      return x.toString(8);
	    },
	    x: function(x) {
	      return x.toString(16);
	    },
	    X: function(x) {
	      return x.toString(16).toUpperCase();
	    },
	    g: function(x, p) {
	      return x.toPrecision(p);
	    },
	    e: function(x, p) {
	      return x.toExponential(p);
	    },
	    f: function(x, p) {
	      return x.toFixed(p);
	    },
	    r: function(x, p) {
	      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
	    }
	  });
	  function d3_format_typeDefault(x) {
	    return x + "";
	  }
	  var d3_time = d3.time = {}, d3_date = Date;
	  function d3_date_utc() {
	    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
	  }
	  d3_date_utc.prototype = {
	    getDate: function() {
	      return this._.getUTCDate();
	    },
	    getDay: function() {
	      return this._.getUTCDay();
	    },
	    getFullYear: function() {
	      return this._.getUTCFullYear();
	    },
	    getHours: function() {
	      return this._.getUTCHours();
	    },
	    getMilliseconds: function() {
	      return this._.getUTCMilliseconds();
	    },
	    getMinutes: function() {
	      return this._.getUTCMinutes();
	    },
	    getMonth: function() {
	      return this._.getUTCMonth();
	    },
	    getSeconds: function() {
	      return this._.getUTCSeconds();
	    },
	    getTime: function() {
	      return this._.getTime();
	    },
	    getTimezoneOffset: function() {
	      return 0;
	    },
	    valueOf: function() {
	      return this._.valueOf();
	    },
	    setDate: function() {
	      d3_time_prototype.setUTCDate.apply(this._, arguments);
	    },
	    setDay: function() {
	      d3_time_prototype.setUTCDay.apply(this._, arguments);
	    },
	    setFullYear: function() {
	      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
	    },
	    setHours: function() {
	      d3_time_prototype.setUTCHours.apply(this._, arguments);
	    },
	    setMilliseconds: function() {
	      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
	    },
	    setMinutes: function() {
	      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
	    },
	    setMonth: function() {
	      d3_time_prototype.setUTCMonth.apply(this._, arguments);
	    },
	    setSeconds: function() {
	      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
	    },
	    setTime: function() {
	      d3_time_prototype.setTime.apply(this._, arguments);
	    }
	  };
	  var d3_time_prototype = Date.prototype;
	  function d3_time_interval(local, step, number) {
	    function round(date) {
	      var d0 = local(date), d1 = offset(d0, 1);
	      return date - d0 < d1 - date ? d0 : d1;
	    }
	    function ceil(date) {
	      step(date = local(new d3_date(date - 1)), 1);
	      return date;
	    }
	    function offset(date, k) {
	      step(date = new d3_date(+date), k);
	      return date;
	    }
	    function range(t0, t1, dt) {
	      var time = ceil(t0), times = [];
	      if (dt > 1) {
	        while (time < t1) {
	          if (!(number(time) % dt)) times.push(new Date(+time));
	          step(time, 1);
	        }
	      } else {
	        while (time < t1) times.push(new Date(+time)), step(time, 1);
	      }
	      return times;
	    }
	    function range_utc(t0, t1, dt) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = t0;
	        return range(utc, t1, dt);
	      } finally {
	        d3_date = Date;
	      }
	    }
	    local.floor = local;
	    local.round = round;
	    local.ceil = ceil;
	    local.offset = offset;
	    local.range = range;
	    var utc = local.utc = d3_time_interval_utc(local);
	    utc.floor = utc;
	    utc.round = d3_time_interval_utc(round);
	    utc.ceil = d3_time_interval_utc(ceil);
	    utc.offset = d3_time_interval_utc(offset);
	    utc.range = range_utc;
	    return local;
	  }
	  function d3_time_interval_utc(method) {
	    return function(date, k) {
	      try {
	        d3_date = d3_date_utc;
	        var utc = new d3_date_utc();
	        utc._ = date;
	        return method(utc, k)._;
	      } finally {
	        d3_date = Date;
	      }
	    };
	  }
	  d3_time.year = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setMonth(0, 1);
	    return date;
	  }, function(date, offset) {
	    date.setFullYear(date.getFullYear() + offset);
	  }, function(date) {
	    return date.getFullYear();
	  });
	  d3_time.years = d3_time.year.range;
	  d3_time.years.utc = d3_time.year.utc.range;
	  d3_time.day = d3_time_interval(function(date) {
	    var day = new d3_date(2e3, 0);
	    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
	    return day;
	  }, function(date, offset) {
	    date.setDate(date.getDate() + offset);
	  }, function(date) {
	    return date.getDate() - 1;
	  });
	  d3_time.days = d3_time.day.range;
	  d3_time.days.utc = d3_time.day.utc.range;
	  d3_time.dayOfYear = function(date) {
	    var year = d3_time.year(date);
	    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
	  };
	  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
	    i = 7 - i;
	    var interval = d3_time[day] = d3_time_interval(function(date) {
	      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
	      return date;
	    }, function(date, offset) {
	      date.setDate(date.getDate() + Math.floor(offset) * 7);
	    }, function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
	    });
	    d3_time[day + "s"] = interval.range;
	    d3_time[day + "s"].utc = interval.utc.range;
	    d3_time[day + "OfYear"] = function(date) {
	      var day = d3_time.year(date).getDay();
	      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
	    };
	  });
	  d3_time.week = d3_time.sunday;
	  d3_time.weeks = d3_time.sunday.range;
	  d3_time.weeks.utc = d3_time.sunday.utc.range;
	  d3_time.weekOfYear = d3_time.sundayOfYear;
	  function d3_locale_timeFormat(locale) {
	    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
	    function d3_time_format(template) {
	      var n = template.length;
	      function format(date) {
	        var string = [], i = -1, j = 0, c, p, f;
	        while (++i < n) {
	          if (template.charCodeAt(i) === 37) {
	            string.push(template.slice(j, i));
	            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
	            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
	            string.push(c);
	            j = i + 1;
	          }
	        }
	        string.push(template.slice(j, i));
	        return string.join("");
	      }
	      format.parse = function(string) {
	        var d = {
	          y: 1900,
	          m: 0,
	          d: 1,
	          H: 0,
	          M: 0,
	          S: 0,
	          L: 0,
	          Z: null
	        }, i = d3_time_parse(d, template, string, 0);
	        if (i != string.length) return null;
	        if ("p" in d) d.H = d.H % 12 + d.p * 12;
	        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
	        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
	          date.setFullYear(d.y, 0, 1);
	          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
	        } else date.setFullYear(d.y, d.m, d.d);
	        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
	        return localZ ? date._ : date;
	      };
	      format.toString = function() {
	        return template;
	      };
	      return format;
	    }
	    function d3_time_parse(date, template, string, j) {
	      var c, p, t, i = 0, n = template.length, m = string.length;
	      while (i < n) {
	        if (j >= m) return -1;
	        c = template.charCodeAt(i++);
	        if (c === 37) {
	          t = template.charAt(i++);
	          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
	          if (!p || (j = p(date, string, j)) < 0) return -1;
	        } else if (c != string.charCodeAt(j++)) {
	          return -1;
	        }
	      }
	      return j;
	    }
	    d3_time_format.utc = function(template) {
	      var local = d3_time_format(template);
	      function format(date) {
	        try {
	          d3_date = d3_date_utc;
	          var utc = new d3_date();
	          utc._ = date;
	          return local(utc);
	        } finally {
	          d3_date = Date;
	        }
	      }
	      format.parse = function(string) {
	        try {
	          d3_date = d3_date_utc;
	          var date = local.parse(string);
	          return date && date._;
	        } finally {
	          d3_date = Date;
	        }
	      };
	      format.toString = local.toString;
	      return format;
	    };
	    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
	    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
	    locale_periods.forEach(function(p, i) {
	      d3_time_periodLookup.set(p.toLowerCase(), i);
	    });
	    var d3_time_formats = {
	      a: function(d) {
	        return locale_shortDays[d.getDay()];
	      },
	      A: function(d) {
	        return locale_days[d.getDay()];
	      },
	      b: function(d) {
	        return locale_shortMonths[d.getMonth()];
	      },
	      B: function(d) {
	        return locale_months[d.getMonth()];
	      },
	      c: d3_time_format(locale_dateTime),
	      d: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      e: function(d, p) {
	        return d3_time_formatPad(d.getDate(), p, 2);
	      },
	      H: function(d, p) {
	        return d3_time_formatPad(d.getHours(), p, 2);
	      },
	      I: function(d, p) {
	        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
	      },
	      j: function(d, p) {
	        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
	      },
	      L: function(d, p) {
	        return d3_time_formatPad(d.getMilliseconds(), p, 3);
	      },
	      m: function(d, p) {
	        return d3_time_formatPad(d.getMonth() + 1, p, 2);
	      },
	      M: function(d, p) {
	        return d3_time_formatPad(d.getMinutes(), p, 2);
	      },
	      p: function(d) {
	        return locale_periods[+(d.getHours() >= 12)];
	      },
	      S: function(d, p) {
	        return d3_time_formatPad(d.getSeconds(), p, 2);
	      },
	      U: function(d, p) {
	        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
	      },
	      w: function(d) {
	        return d.getDay();
	      },
	      W: function(d, p) {
	        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
	      },
	      x: d3_time_format(locale_date),
	      X: d3_time_format(locale_time),
	      y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
	      },
	      Y: function(d, p) {
	        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
	      },
	      Z: d3_time_zone,
	      "%": function() {
	        return "%";
	      }
	    };
	    var d3_time_parsers = {
	      a: d3_time_parseWeekdayAbbrev,
	      A: d3_time_parseWeekday,
	      b: d3_time_parseMonthAbbrev,
	      B: d3_time_parseMonth,
	      c: d3_time_parseLocaleFull,
	      d: d3_time_parseDay,
	      e: d3_time_parseDay,
	      H: d3_time_parseHour24,
	      I: d3_time_parseHour24,
	      j: d3_time_parseDayOfYear,
	      L: d3_time_parseMilliseconds,
	      m: d3_time_parseMonthNumber,
	      M: d3_time_parseMinutes,
	      p: d3_time_parseAmPm,
	      S: d3_time_parseSeconds,
	      U: d3_time_parseWeekNumberSunday,
	      w: d3_time_parseWeekdayNumber,
	      W: d3_time_parseWeekNumberMonday,
	      x: d3_time_parseLocaleDate,
	      X: d3_time_parseLocaleTime,
	      y: d3_time_parseYear,
	      Y: d3_time_parseFullYear,
	      Z: d3_time_parseZone,
	      "%": d3_time_parseLiteralPercent
	    };
	    function d3_time_parseWeekdayAbbrev(date, string, i) {
	      d3_time_dayAbbrevRe.lastIndex = 0;
	      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseWeekday(date, string, i) {
	      d3_time_dayRe.lastIndex = 0;
	      var n = d3_time_dayRe.exec(string.slice(i));
	      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonthAbbrev(date, string, i) {
	      d3_time_monthAbbrevRe.lastIndex = 0;
	      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseMonth(date, string, i) {
	      d3_time_monthRe.lastIndex = 0;
	      var n = d3_time_monthRe.exec(string.slice(i));
	      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	    }
	    function d3_time_parseLocaleFull(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
	    }
	    function d3_time_parseLocaleDate(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
	    }
	    function d3_time_parseLocaleTime(date, string, i) {
	      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
	    }
	    function d3_time_parseAmPm(date, string, i) {
	      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
	      return n == null ? -1 : (date.p = n, i);
	    }
	    return d3_time_format;
	  }
	  var d3_time_formatPads = {
	    "-": "",
	    _: " ",
	    "0": "0"
	  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
	  function d3_time_formatPad(value, fill, width) {
	    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
	    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	  }
	  function d3_time_formatRe(names) {
	    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
	  }
	  function d3_time_formatLookup(names) {
	    var map = new d3_Map(), i = -1, n = names.length;
	    while (++i < n) map.set(names[i].toLowerCase(), i);
	    return map;
	  }
	  function d3_time_parseWeekdayNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
	    return n ? (date.w = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberSunday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.U = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseWeekNumberMonday(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i));
	    return n ? (date.W = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseFullYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
	    return n ? (date.y = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
	  }
	  function d3_time_parseZone(date, string, i) {
	    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
	    i + 5) : -1;
	  }
	  function d3_time_expandYear(d) {
	    return d + (d > 68 ? 1900 : 2e3);
	  }
	  function d3_time_parseMonthNumber(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
	  }
	  function d3_time_parseDay(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.d = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseDayOfYear(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.j = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseHour24(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.H = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMinutes(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.M = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseSeconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
	    return n ? (date.S = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_parseMilliseconds(date, string, i) {
	    d3_time_numberRe.lastIndex = 0;
	    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
	    return n ? (date.L = +n[0], i + n[0].length) : -1;
	  }
	  function d3_time_zone(d) {
	    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
	    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
	  }
	  function d3_time_parseLiteralPercent(date, string, i) {
	    d3_time_percentRe.lastIndex = 0;
	    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
	    return n ? i + n[0].length : -1;
	  }
	  function d3_time_formatMulti(formats) {
	    var n = formats.length, i = -1;
	    while (++i < n) formats[i][0] = this(formats[i][0]);
	    return function(date) {
	      var i = 0, f = formats[i];
	      while (!f[1](date)) f = formats[++i];
	      return f[0](date);
	    };
	  }
	  d3.locale = function(locale) {
	    return {
	      numberFormat: d3_locale_numberFormat(locale),
	      timeFormat: d3_locale_timeFormat(locale)
	    };
	  };
	  var d3_locale_enUS = d3.locale({
	    decimal: ".",
	    thousands: ",",
	    grouping: [ 3 ],
	    currency: [ "$", "" ],
	    dateTime: "%a %b %e %X %Y",
	    date: "%m/%d/%Y",
	    time: "%H:%M:%S",
	    periods: [ "AM", "PM" ],
	    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
	    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
	    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
	    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
	  });
	  d3.format = d3_locale_enUS.numberFormat;
	  d3.geo = {};
	  function d3_adder() {}
	  d3_adder.prototype = {
	    s: 0,
	    t: 0,
	    add: function(y) {
	      d3_adderSum(y, this.t, d3_adderTemp);
	      d3_adderSum(d3_adderTemp.s, this.s, this);
	      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
	    },
	    reset: function() {
	      this.s = this.t = 0;
	    },
	    valueOf: function() {
	      return this.s;
	    }
	  };
	  var d3_adderTemp = new d3_adder();
	  function d3_adderSum(a, b, o) {
	    var x = o.s = a + b, bv = x - a, av = x - bv;
	    o.t = a - av + (b - bv);
	  }
	  d3.geo.stream = function(object, listener) {
	    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
	      d3_geo_streamObjectType[object.type](object, listener);
	    } else {
	      d3_geo_streamGeometry(object, listener);
	    }
	  };
	  function d3_geo_streamGeometry(geometry, listener) {
	    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
	      d3_geo_streamGeometryType[geometry.type](geometry, listener);
	    }
	  }
	  var d3_geo_streamObjectType = {
	    Feature: function(feature, listener) {
	      d3_geo_streamGeometry(feature.geometry, listener);
	    },
	    FeatureCollection: function(object, listener) {
	      var features = object.features, i = -1, n = features.length;
	      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
	    }
	  };
	  var d3_geo_streamGeometryType = {
	    Sphere: function(object, listener) {
	      listener.sphere();
	    },
	    Point: function(object, listener) {
	      object = object.coordinates;
	      listener.point(object[0], object[1], object[2]);
	    },
	    MultiPoint: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
	    },
	    LineString: function(object, listener) {
	      d3_geo_streamLine(object.coordinates, listener, 0);
	    },
	    MultiLineString: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
	    },
	    Polygon: function(object, listener) {
	      d3_geo_streamPolygon(object.coordinates, listener);
	    },
	    MultiPolygon: function(object, listener) {
	      var coordinates = object.coordinates, i = -1, n = coordinates.length;
	      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
	    },
	    GeometryCollection: function(object, listener) {
	      var geometries = object.geometries, i = -1, n = geometries.length;
	      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
	    }
	  };
	  function d3_geo_streamLine(coordinates, listener, closed) {
	    var i = -1, n = coordinates.length - closed, coordinate;
	    listener.lineStart();
	    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
	    listener.lineEnd();
	  }
	  function d3_geo_streamPolygon(coordinates, listener) {
	    var i = -1, n = coordinates.length;
	    listener.polygonStart();
	    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
	    listener.polygonEnd();
	  }
	  d3.geo.area = function(object) {
	    d3_geo_areaSum = 0;
	    d3.geo.stream(object, d3_geo_area);
	    return d3_geo_areaSum;
	  };
	  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
	  var d3_geo_area = {
	    sphere: function() {
	      d3_geo_areaSum += 4 * π;
	    },
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_areaRingSum.reset();
	      d3_geo_area.lineStart = d3_geo_areaRingStart;
	    },
	    polygonEnd: function() {
	      var area = 2 * d3_geo_areaRingSum;
	      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
	      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
	    }
	  };
	  function d3_geo_areaRingStart() {
	    var λ00, φ00, λ0, cosφ0, sinφ0;
	    d3_geo_area.point = function(λ, φ) {
	      d3_geo_area.point = nextPoint;
	      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
	      sinφ0 = Math.sin(φ);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      φ = φ * d3_radians / 2 + π / 4;
	      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
	      d3_geo_areaRingSum.add(Math.atan2(v, u));
	      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
	    }
	    d3_geo_area.lineEnd = function() {
	      nextPoint(λ00, φ00);
	    };
	  }
	  function d3_geo_cartesian(spherical) {
	    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
	    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
	  }
	  function d3_geo_cartesianDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	  }
	  function d3_geo_cartesianCross(a, b) {
	    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
	  }
	  function d3_geo_cartesianAdd(a, b) {
	    a[0] += b[0];
	    a[1] += b[1];
	    a[2] += b[2];
	  }
	  function d3_geo_cartesianScale(vector, k) {
	    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
	  }
	  function d3_geo_cartesianNormalize(d) {
	    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	    d[0] /= l;
	    d[1] /= l;
	    d[2] /= l;
	  }
	  function d3_geo_spherical(cartesian) {
	    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
	  }
	  function d3_geo_sphericalEqual(a, b) {
	    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
	  }
	  d3.geo.bounds = function() {
	    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
	    var bound = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        bound.point = ringPoint;
	        bound.lineStart = ringStart;
	        bound.lineEnd = ringEnd;
	        dλSum = 0;
	        d3_geo_area.polygonStart();
	      },
	      polygonEnd: function() {
	        d3_geo_area.polygonEnd();
	        bound.point = point;
	        bound.lineStart = lineStart;
	        bound.lineEnd = lineEnd;
	        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
	        range[0] = λ0, range[1] = λ1;
	      }
	    };
	    function point(λ, φ) {
	      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
	      if (φ < φ0) φ0 = φ;
	      if (φ > φ1) φ1 = φ;
	    }
	    function linePoint(λ, φ) {
	      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
	      if (p0) {
	        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
	        d3_geo_cartesianNormalize(inflection);
	        inflection = d3_geo_spherical(inflection);
	        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
	        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = inflection[1] * d3_degrees;
	          if (φi > φ1) φ1 = φi;
	        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
	          var φi = -inflection[1] * d3_degrees;
	          if (φi < φ0) φ0 = φi;
	        } else {
	          if (φ < φ0) φ0 = φ;
	          if (φ > φ1) φ1 = φ;
	        }
	        if (antimeridian) {
	          if (λ < λ_) {
	            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	          } else {
	            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	          }
	        } else {
	          if (λ1 >= λ0) {
	            if (λ < λ0) λ0 = λ;
	            if (λ > λ1) λ1 = λ;
	          } else {
	            if (λ > λ_) {
	              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
	            } else {
	              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
	            }
	          }
	        }
	      } else {
	        point(λ, φ);
	      }
	      p0 = p, λ_ = λ;
	    }
	    function lineStart() {
	      bound.point = linePoint;
	    }
	    function lineEnd() {
	      range[0] = λ0, range[1] = λ1;
	      bound.point = point;
	      p0 = null;
	    }
	    function ringPoint(λ, φ) {
	      if (p0) {
	        var dλ = λ - λ_;
	        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
	      } else λ__ = λ, φ__ = φ;
	      d3_geo_area.point(λ, φ);
	      linePoint(λ, φ);
	    }
	    function ringStart() {
	      d3_geo_area.lineStart();
	    }
	    function ringEnd() {
	      ringPoint(λ__, φ__);
	      d3_geo_area.lineEnd();
	      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
	      range[0] = λ0, range[1] = λ1;
	      p0 = null;
	    }
	    function angle(λ0, λ1) {
	      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
	    }
	    function compareRanges(a, b) {
	      return a[0] - b[0];
	    }
	    function withinRange(x, range) {
	      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
	    }
	    return function(feature) {
	      φ1 = λ1 = -(λ0 = φ0 = Infinity);
	      ranges = [];
	      d3.geo.stream(feature, bound);
	      var n = ranges.length;
	      if (n) {
	        ranges.sort(compareRanges);
	        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
	          b = ranges[i];
	          if (withinRange(b[0], a) || withinRange(b[1], a)) {
	            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	          } else {
	            merged.push(a = b);
	          }
	        }
	        var best = -Infinity, dλ;
	        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
	          b = merged[i];
	          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
	        }
	      }
	      ranges = range = null;
	      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
	    };
	  }();
	  d3.geo.centroid = function(object) {
	    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	    d3.geo.stream(object, d3_geo_centroid);
	    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
	    if (m < ε2) {
	      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
	      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
	      m = x * x + y * y + z * z;
	      if (m < ε2) return [ NaN, NaN ];
	    }
	    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
	  };
	  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
	  var d3_geo_centroid = {
	    sphere: d3_noop,
	    point: d3_geo_centroidPoint,
	    lineStart: d3_geo_centroidLineStart,
	    lineEnd: d3_geo_centroidLineEnd,
	    polygonStart: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
	    }
	  };
	  function d3_geo_centroidPoint(λ, φ) {
	    λ *= d3_radians;
	    var cosφ = Math.cos(φ *= d3_radians);
	    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
	  }
	  function d3_geo_centroidPointXYZ(x, y, z) {
	    ++d3_geo_centroidW0;
	    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
	    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
	    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
	  }
	  function d3_geo_centroidLineStart() {
	    var x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroid.point = nextPoint;
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_centroidLineEnd() {
	    d3_geo_centroid.point = d3_geo_centroidPoint;
	  }
	  function d3_geo_centroidRingStart() {
	    var λ00, φ00, x0, y0, z0;
	    d3_geo_centroid.point = function(λ, φ) {
	      λ00 = λ, φ00 = φ;
	      d3_geo_centroid.point = nextPoint;
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians);
	      x0 = cosφ * Math.cos(λ);
	      y0 = cosφ * Math.sin(λ);
	      z0 = Math.sin(φ);
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    };
	    d3_geo_centroid.lineEnd = function() {
	      nextPoint(λ00, φ00);
	      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
	      d3_geo_centroid.point = d3_geo_centroidPoint;
	    };
	    function nextPoint(λ, φ) {
	      λ *= d3_radians;
	      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
	      d3_geo_centroidX2 += v * cx;
	      d3_geo_centroidY2 += v * cy;
	      d3_geo_centroidZ2 += v * cz;
	      d3_geo_centroidW1 += w;
	      d3_geo_centroidX1 += w * (x0 + (x0 = x));
	      d3_geo_centroidY1 += w * (y0 + (y0 = y));
	      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
	      d3_geo_centroidPointXYZ(x0, y0, z0);
	    }
	  }
	  function d3_geo_compose(a, b) {
	    function compose(x, y) {
	      return x = a(x, y), b(x[0], x[1]);
	    }
	    if (a.invert && b.invert) compose.invert = function(x, y) {
	      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	    };
	    return compose;
	  }
	  function d3_true() {
	    return true;
	  }
	  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
	    var subject = [], clip = [];
	    segments.forEach(function(segment) {
	      if ((n = segment.length - 1) <= 0) return;
	      var n, p0 = segment[0], p1 = segment[n];
	      if (d3_geo_sphericalEqual(p0, p1)) {
	        listener.lineStart();
	        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
	        listener.lineEnd();
	        return;
	      }
	      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
	      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
	      a.o = b;
	      subject.push(a);
	      clip.push(b);
	    });
	    clip.sort(compare);
	    d3_geo_clipPolygonLinkCircular(subject);
	    d3_geo_clipPolygonLinkCircular(clip);
	    if (!subject.length) return;
	    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
	      clip[i].e = entry = !entry;
	    }
	    var start = subject[0], points, point;
	    while (1) {
	      var current = start, isSubject = true;
	      while (current.v) if ((current = current.n) === start) return;
	      points = current.z;
	      listener.lineStart();
	      do {
	        current.v = current.o.v = true;
	        if (current.e) {
	          if (isSubject) {
	            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.n.x, 1, listener);
	          }
	          current = current.n;
	        } else {
	          if (isSubject) {
	            points = current.p.z;
	            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
	          } else {
	            interpolate(current.x, current.p.x, -1, listener);
	          }
	          current = current.p;
	        }
	        current = current.o;
	        points = current.z;
	        isSubject = !isSubject;
	      } while (!current.v);
	      listener.lineEnd();
	    }
	  }
	  function d3_geo_clipPolygonLinkCircular(array) {
	    if (!(n = array.length)) return;
	    var n, i = 0, a = array[0], b;
	    while (++i < n) {
	      a.n = b = array[i];
	      b.p = a;
	      a = b;
	    }
	    a.n = b = array[0];
	    b.p = a;
	  }
	  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
	    this.x = point;
	    this.z = points;
	    this.o = other;
	    this.e = entry;
	    this.v = false;
	    this.n = this.p = null;
	  }
	  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
	    return function(rotate, listener) {
	      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          clip.point = pointRing;
	          clip.lineStart = ringStart;
	          clip.lineEnd = ringEnd;
	          segments = [];
	          polygon = [];
	        },
	        polygonEnd: function() {
	          clip.point = point;
	          clip.lineStart = lineStart;
	          clip.lineEnd = lineEnd;
	          segments = d3.merge(segments);
	          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
	          if (segments.length) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
	          } else if (clipStartInside) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            interpolate(null, null, 1, listener);
	            listener.lineEnd();
	          }
	          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
	          segments = polygon = null;
	        },
	        sphere: function() {
	          listener.polygonStart();
	          listener.lineStart();
	          interpolate(null, null, 1, listener);
	          listener.lineEnd();
	          listener.polygonEnd();
	        }
	      };
	      function point(λ, φ) {
	        var point = rotate(λ, φ);
	        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
	      }
	      function pointLine(λ, φ) {
	        var point = rotate(λ, φ);
	        line.point(point[0], point[1]);
	      }
	      function lineStart() {
	        clip.point = pointLine;
	        line.lineStart();
	      }
	      function lineEnd() {
	        clip.point = point;
	        line.lineEnd();
	      }
	      var segments;
	      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
	      function pointRing(λ, φ) {
	        ring.push([ λ, φ ]);
	        var point = rotate(λ, φ);
	        ringListener.point(point[0], point[1]);
	      }
	      function ringStart() {
	        ringListener.lineStart();
	        ring = [];
	      }
	      function ringEnd() {
	        pointRing(ring[0][0], ring[0][1]);
	        ringListener.lineEnd();
	        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
	        ring.pop();
	        polygon.push(ring);
	        ring = null;
	        if (!n) return;
	        if (clean & 1) {
	          segment = ringSegments[0];
	          var n = segment.length - 1, i = -1, point;
	          if (n > 0) {
	            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
	            listener.lineStart();
	            while (++i < n) listener.point((point = segment[i])[0], point[1]);
	            listener.lineEnd();
	          }
	          return;
	        }
	        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
	        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
	      }
	      return clip;
	    };
	  }
	  function d3_geo_clipSegmentLength1(segment) {
	    return segment.length > 1;
	  }
	  function d3_geo_clipBufferListener() {
	    var lines = [], line;
	    return {
	      lineStart: function() {
	        lines.push(line = []);
	      },
	      point: function(λ, φ) {
	        line.push([ λ, φ ]);
	      },
	      lineEnd: d3_noop,
	      buffer: function() {
	        var buffer = lines;
	        lines = [];
	        line = null;
	        return buffer;
	      },
	      rejoin: function() {
	        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	      }
	    };
	  }
	  function d3_geo_clipSort(a, b) {
	    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
	  }
	  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
	  function d3_geo_clipAntimeridianLine(listener) {
	    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
	    return {
	      lineStart: function() {
	        listener.lineStart();
	        clean = 1;
	      },
	      point: function(λ1, φ1) {
	        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
	        if (abs(dλ - π) < ε) {
	          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          listener.point(λ1, φ0);
	          clean = 0;
	        } else if (sλ0 !== sλ1 && dλ >= π) {
	          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
	          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
	          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
	          listener.point(sλ0, φ0);
	          listener.lineEnd();
	          listener.lineStart();
	          listener.point(sλ1, φ0);
	          clean = 0;
	        }
	        listener.point(λ0 = λ1, φ0 = φ1);
	        sλ0 = sλ1;
	      },
	      lineEnd: function() {
	        listener.lineEnd();
	        λ0 = φ0 = NaN;
	      },
	      clean: function() {
	        return 2 - clean;
	      }
	    };
	  }
	  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
	    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
	    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
	  }
	  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
	    var φ;
	    if (from == null) {
	      φ = direction * halfπ;
	      listener.point(-π, φ);
	      listener.point(0, φ);
	      listener.point(π, φ);
	      listener.point(π, 0);
	      listener.point(π, -φ);
	      listener.point(0, -φ);
	      listener.point(-π, -φ);
	      listener.point(-π, 0);
	      listener.point(-π, φ);
	    } else if (abs(from[0] - to[0]) > ε) {
	      var s = from[0] < to[0] ? π : -π;
	      φ = direction * s / 2;
	      listener.point(-s, φ);
	      listener.point(0, φ);
	      listener.point(s, φ);
	    } else {
	      listener.point(to[0], to[1]);
	    }
	  }
	  function d3_geo_pointInPolygon(point, polygon) {
	    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
	    d3_geo_areaRingSum.reset();
	    for (var i = 0, n = polygon.length; i < n; ++i) {
	      var ring = polygon[i], m = ring.length;
	      if (!m) continue;
	      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
	      while (true) {
	        if (j === m) j = 0;
	        point = ring[j];
	        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
	        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
	        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
	        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
	          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
	          d3_geo_cartesianNormalize(arc);
	          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
	          d3_geo_cartesianNormalize(intersection);
	          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
	          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
	            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
	          }
	        }
	        if (!j++) break;
	        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
	      }
	    }
	    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
	  }
	  function d3_geo_clipCircle(radius) {
	    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
	    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
	    function visible(λ, φ) {
	      return Math.cos(λ) * Math.cos(φ) > cr;
	    }
	    function clipLine(listener) {
	      var point0, c0, v0, v00, clean;
	      return {
	        lineStart: function() {
	          v00 = v0 = false;
	          clean = 1;
	        },
	        point: function(λ, φ) {
	          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
	          if (!point0 && (v00 = v0 = v)) listener.lineStart();
	          if (v !== v0) {
	            point2 = intersect(point0, point1);
	            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
	              point1[0] += ε;
	              point1[1] += ε;
	              v = visible(point1[0], point1[1]);
	            }
	          }
	          if (v !== v0) {
	            clean = 0;
	            if (v) {
	              listener.lineStart();
	              point2 = intersect(point1, point0);
	              listener.point(point2[0], point2[1]);
	            } else {
	              point2 = intersect(point0, point1);
	              listener.point(point2[0], point2[1]);
	              listener.lineEnd();
	            }
	            point0 = point2;
	          } else if (notHemisphere && point0 && smallRadius ^ v) {
	            var t;
	            if (!(c & c0) && (t = intersect(point1, point0, true))) {
	              clean = 0;
	              if (smallRadius) {
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	              } else {
	                listener.point(t[1][0], t[1][1]);
	                listener.lineEnd();
	                listener.lineStart();
	                listener.point(t[0][0], t[0][1]);
	              }
	            }
	          }
	          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
	            listener.point(point1[0], point1[1]);
	          }
	          point0 = point1, v0 = v, c0 = c;
	        },
	        lineEnd: function() {
	          if (v0) listener.lineEnd();
	          point0 = null;
	        },
	        clean: function() {
	          return clean | (v00 && v0) << 1;
	        }
	      };
	    }
	    function intersect(a, b, two) {
	      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
	      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
	      if (!determinant) return !two && a;
	      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
	      d3_geo_cartesianAdd(A, B);
	      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
	      if (t2 < 0) return;
	      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
	      d3_geo_cartesianAdd(q, A);
	      q = d3_geo_spherical(q);
	      if (!two) return q;
	      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
	      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
	      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
	      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
	      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
	        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
	        d3_geo_cartesianAdd(q1, A);
	        return [ q, d3_geo_spherical(q1) ];
	      }
	    }
	    function code(λ, φ) {
	      var r = smallRadius ? radius : π - radius, code = 0;
	      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
	      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
	      return code;
	    }
	  }
	  function d3_geom_clipLine(x0, y0, x1, y1) {
	    return function(line) {
	      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
	      r = x0 - ax;
	      if (!dx && r > 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dx > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = x1 - ax;
	      if (!dx && r < 0) return;
	      r /= dx;
	      if (dx < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dx > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      r = y0 - ay;
	      if (!dy && r > 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      } else if (dy > 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      }
	      r = y1 - ay;
	      if (!dy && r < 0) return;
	      r /= dy;
	      if (dy < 0) {
	        if (r > t1) return;
	        if (r > t0) t0 = r;
	      } else if (dy > 0) {
	        if (r < t0) return;
	        if (r < t1) t1 = r;
	      }
	      if (t0 > 0) line.a = {
	        x: ax + t0 * dx,
	        y: ay + t0 * dy
	      };
	      if (t1 < 1) line.b = {
	        x: ax + t1 * dx,
	        y: ay + t1 * dy
	      };
	      return line;
	    };
	  }
	  var d3_geo_clipExtentMAX = 1e9;
	  d3.geo.clipExtent = function() {
	    var x0, y0, x1, y1, stream, clip, clipExtent = {
	      stream: function(output) {
	        if (stream) stream.valid = false;
	        stream = clip(output);
	        stream.valid = true;
	        return stream;
	      },
	      extent: function(_) {
	        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
	        if (stream) stream.valid = false, stream = null;
	        return clipExtent;
	      }
	    };
	    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
	  };
	  function d3_geo_clipExtent(x0, y0, x1, y1) {
	    return function(listener) {
	      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
	      var clip = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          listener = bufferListener;
	          segments = [];
	          polygon = [];
	          clean = true;
	        },
	        polygonEnd: function() {
	          listener = listener_;
	          segments = d3.merge(segments);
	          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
	          if (inside || visible) {
	            listener.polygonStart();
	            if (inside) {
	              listener.lineStart();
	              interpolate(null, null, 1, listener);
	              listener.lineEnd();
	            }
	            if (visible) {
	              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
	            }
	            listener.polygonEnd();
	          }
	          segments = polygon = ring = null;
	        }
	      };
	      function insidePolygon(p) {
	        var wn = 0, n = polygon.length, y = p[1];
	        for (var i = 0; i < n; ++i) {
	          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
	            b = v[j];
	            if (a[1] <= y) {
	              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
	            } else {
	              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
	            }
	            a = b;
	          }
	        }
	        return wn !== 0;
	      }
	      function interpolate(from, to, direction, listener) {
	        var a = 0, a1 = 0;
	        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
	          do {
	            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	          } while ((a = (a + direction + 4) % 4) !== a1);
	        } else {
	          listener.point(to[0], to[1]);
	        }
	      }
	      function pointVisible(x, y) {
	        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	      }
	      function point(x, y) {
	        if (pointVisible(x, y)) listener.point(x, y);
	      }
	      var x__, y__, v__, x_, y_, v_, first, clean;
	      function lineStart() {
	        clip.point = linePoint;
	        if (polygon) polygon.push(ring = []);
	        first = true;
	        v_ = false;
	        x_ = y_ = NaN;
	      }
	      function lineEnd() {
	        if (segments) {
	          linePoint(x__, y__);
	          if (v__ && v_) bufferListener.rejoin();
	          segments.push(bufferListener.buffer());
	        }
	        clip.point = point;
	        if (v_) listener.lineEnd();
	      }
	      function linePoint(x, y) {
	        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
	        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
	        var v = pointVisible(x, y);
	        if (polygon) ring.push([ x, y ]);
	        if (first) {
	          x__ = x, y__ = y, v__ = v;
	          first = false;
	          if (v) {
	            listener.lineStart();
	            listener.point(x, y);
	          }
	        } else {
	          if (v && v_) listener.point(x, y); else {
	            var l = {
	              a: {
	                x: x_,
	                y: y_
	              },
	              b: {
	                x: x,
	                y: y
	              }
	            };
	            if (clipLine(l)) {
	              if (!v_) {
	                listener.lineStart();
	                listener.point(l.a.x, l.a.y);
	              }
	              listener.point(l.b.x, l.b.y);
	              if (!v) listener.lineEnd();
	              clean = false;
	            } else if (v) {
	              listener.lineStart();
	              listener.point(x, y);
	              clean = false;
	            }
	          }
	        }
	        x_ = x, y_ = y, v_ = v;
	      }
	      return clip;
	    };
	    function corner(p, direction) {
	      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
	    }
	    function compare(a, b) {
	      return comparePoints(a.x, b.x);
	    }
	    function comparePoints(a, b) {
	      var ca = corner(a, 1), cb = corner(b, 1);
	      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
	    }
	  }
	  function d3_geo_conic(projectAt) {
	    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
	    p.parallels = function(_) {
	      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
	      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
	    };
	    return p;
	  }
	  function d3_geo_conicEqualArea(φ0, φ1) {
	    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
	    function forward(λ, φ) {
	      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
	      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = ρ0 - y;
	      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEqualArea = function() {
	    return d3_geo_conic(d3_geo_conicEqualArea);
	  }).raw = d3_geo_conicEqualArea;
	  d3.geo.albers = function() {
	    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
	  };
	  d3.geo.albersUsa = function() {
	    var lower48 = d3.geo.albers();
	    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
	    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
	    var point, pointStream = {
	      point: function(x, y) {
	        point = [ x, y ];
	      }
	    }, lower48Point, alaskaPoint, hawaiiPoint;
	    function albersUsa(coordinates) {
	      var x = coordinates[0], y = coordinates[1];
	      point = null;
	      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
	      return point;
	    }
	    albersUsa.invert = function(coordinates) {
	      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
	      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
	    };
	    albersUsa.stream = function(stream) {
	      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
	      return {
	        point: function(x, y) {
	          lower48Stream.point(x, y);
	          alaskaStream.point(x, y);
	          hawaiiStream.point(x, y);
	        },
	        sphere: function() {
	          lower48Stream.sphere();
	          alaskaStream.sphere();
	          hawaiiStream.sphere();
	        },
	        lineStart: function() {
	          lower48Stream.lineStart();
	          alaskaStream.lineStart();
	          hawaiiStream.lineStart();
	        },
	        lineEnd: function() {
	          lower48Stream.lineEnd();
	          alaskaStream.lineEnd();
	          hawaiiStream.lineEnd();
	        },
	        polygonStart: function() {
	          lower48Stream.polygonStart();
	          alaskaStream.polygonStart();
	          hawaiiStream.polygonStart();
	        },
	        polygonEnd: function() {
	          lower48Stream.polygonEnd();
	          alaskaStream.polygonEnd();
	          hawaiiStream.polygonEnd();
	        }
	      };
	    };
	    albersUsa.precision = function(_) {
	      if (!arguments.length) return lower48.precision();
	      lower48.precision(_);
	      alaska.precision(_);
	      hawaii.precision(_);
	      return albersUsa;
	    };
	    albersUsa.scale = function(_) {
	      if (!arguments.length) return lower48.scale();
	      lower48.scale(_);
	      alaska.scale(_ * .35);
	      hawaii.scale(_);
	      return albersUsa.translate(lower48.translate());
	    };
	    albersUsa.translate = function(_) {
	      if (!arguments.length) return lower48.translate();
	      var k = lower48.scale(), x = +_[0], y = +_[1];
	      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
	      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
	      return albersUsa;
	    };
	    return albersUsa.scale(1070);
	  };
	  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
	    point: d3_noop,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: function() {
	      d3_geo_pathAreaPolygon = 0;
	      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
	      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
	    }
	  };
	  function d3_geo_pathAreaRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathArea.point = function(x, y) {
	      d3_geo_pathArea.point = nextPoint;
	      x00 = x0 = x, y00 = y0 = y;
	    };
	    function nextPoint(x, y) {
	      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
	      x0 = x, y0 = y;
	    }
	    d3_geo_pathArea.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
	  var d3_geo_pathBounds = {
	    point: d3_geo_pathBoundsPoint,
	    lineStart: d3_noop,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_pathBoundsPoint(x, y) {
	    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
	    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
	    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
	    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
	  }
	  function d3_geo_pathBuffer() {
	    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointCircle = d3_geo_pathBufferCircle(_);
	        return stream;
	      },
	      result: function() {
	        if (buffer.length) {
	          var result = buffer.join("");
	          buffer = [];
	          return result;
	        }
	      }
	    };
	    function point(x, y) {
	      buffer.push("M", x, ",", y, pointCircle);
	    }
	    function pointLineStart(x, y) {
	      buffer.push("M", x, ",", y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      buffer.push("L", x, ",", y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      buffer.push("Z");
	    }
	    return stream;
	  }
	  function d3_geo_pathBufferCircle(radius) {
	    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
	  }
	  var d3_geo_pathCentroid = {
	    point: d3_geo_pathCentroidPoint,
	    lineStart: d3_geo_pathCentroidLineStart,
	    lineEnd: d3_geo_pathCentroidLineEnd,
	    polygonStart: function() {
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
	    },
	    polygonEnd: function() {
	      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
	      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
	    }
	  };
	  function d3_geo_pathCentroidPoint(x, y) {
	    d3_geo_centroidX0 += x;
	    d3_geo_centroidY0 += y;
	    ++d3_geo_centroidZ0;
	  }
	  function d3_geo_pathCentroidLineStart() {
	    var x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	  }
	  function d3_geo_pathCentroidLineEnd() {
	    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
	  }
	  function d3_geo_pathCentroidRingStart() {
	    var x00, y00, x0, y0;
	    d3_geo_pathCentroid.point = function(x, y) {
	      d3_geo_pathCentroid.point = nextPoint;
	      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
	    };
	    function nextPoint(x, y) {
	      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
	      d3_geo_centroidX1 += z * (x0 + x) / 2;
	      d3_geo_centroidY1 += z * (y0 + y) / 2;
	      d3_geo_centroidZ1 += z;
	      z = y0 * x - x0 * y;
	      d3_geo_centroidX2 += z * (x0 + x);
	      d3_geo_centroidY2 += z * (y0 + y);
	      d3_geo_centroidZ2 += z * 3;
	      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
	    }
	    d3_geo_pathCentroid.lineEnd = function() {
	      nextPoint(x00, y00);
	    };
	  }
	  function d3_geo_pathContext(context) {
	    var pointRadius = 4.5;
	    var stream = {
	      point: point,
	      lineStart: function() {
	        stream.point = pointLineStart;
	      },
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        stream.lineEnd = lineEndPolygon;
	      },
	      polygonEnd: function() {
	        stream.lineEnd = lineEnd;
	        stream.point = point;
	      },
	      pointRadius: function(_) {
	        pointRadius = _;
	        return stream;
	      },
	      result: d3_noop
	    };
	    function point(x, y) {
	      context.moveTo(x + pointRadius, y);
	      context.arc(x, y, pointRadius, 0, τ);
	    }
	    function pointLineStart(x, y) {
	      context.moveTo(x, y);
	      stream.point = pointLine;
	    }
	    function pointLine(x, y) {
	      context.lineTo(x, y);
	    }
	    function lineEnd() {
	      stream.point = point;
	    }
	    function lineEndPolygon() {
	      context.closePath();
	    }
	    return stream;
	  }
	  function d3_geo_resample(project) {
	    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
	    function resample(stream) {
	      return (maxDepth ? resampleRecursive : resampleNone)(stream);
	    }
	    function resampleNone(stream) {
	      return d3_geo_transformPoint(stream, function(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      });
	    }
	    function resampleRecursive(stream) {
	      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
	      var resample = {
	        point: point,
	        lineStart: lineStart,
	        lineEnd: lineEnd,
	        polygonStart: function() {
	          stream.polygonStart();
	          resample.lineStart = ringStart;
	        },
	        polygonEnd: function() {
	          stream.polygonEnd();
	          resample.lineStart = lineStart;
	        }
	      };
	      function point(x, y) {
	        x = project(x, y);
	        stream.point(x[0], x[1]);
	      }
	      function lineStart() {
	        x0 = NaN;
	        resample.point = linePoint;
	        stream.lineStart();
	      }
	      function linePoint(λ, φ) {
	        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	        stream.point(x0, y0);
	      }
	      function lineEnd() {
	        resample.point = point;
	        stream.lineEnd();
	      }
	      function ringStart() {
	        lineStart();
	        resample.point = ringPoint;
	        resample.lineEnd = ringEnd;
	      }
	      function ringPoint(λ, φ) {
	        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	        resample.point = linePoint;
	      }
	      function ringEnd() {
	        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
	        resample.lineEnd = lineEnd;
	        lineEnd();
	      }
	      return resample;
	    }
	    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
	      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
	      if (d2 > 4 * δ2 && depth--) {
	        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
	        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
	          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
	          stream.point(x2, y2);
	          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
	        }
	      }
	    }
	    resample.precision = function(_) {
	      if (!arguments.length) return Math.sqrt(δ2);
	      maxDepth = (δ2 = _ * _) > 0 && 16;
	      return resample;
	    };
	    return resample;
	  }
	  d3.geo.path = function() {
	    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
	    function path(object) {
	      if (object) {
	        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
	        d3.geo.stream(object, cacheStream);
	      }
	      return contextStream.result();
	    }
	    path.area = function(object) {
	      d3_geo_pathAreaSum = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathArea));
	      return d3_geo_pathAreaSum;
	    };
	    path.centroid = function(object) {
	      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
	      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
	      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
	    };
	    path.bounds = function(object) {
	      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
	      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
	      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
	    };
	    path.projection = function(_) {
	      if (!arguments.length) return projection;
	      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
	      return reset();
	    };
	    path.context = function(_) {
	      if (!arguments.length) return context;
	      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
	      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	      return reset();
	    };
	    path.pointRadius = function(_) {
	      if (!arguments.length) return pointRadius;
	      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	      return path;
	    };
	    function reset() {
	      cacheStream = null;
	      return path;
	    }
	    return path.projection(d3.geo.albersUsa()).context(null);
	  };
	  function d3_geo_pathProjectStream(project) {
	    var resample = d3_geo_resample(function(x, y) {
	      return project([ x * d3_degrees, y * d3_degrees ]);
	    });
	    return function(stream) {
	      return d3_geo_projectionRadians(resample(stream));
	    };
	  }
	  d3.geo.transform = function(methods) {
	    return {
	      stream: function(stream) {
	        var transform = new d3_geo_transform(stream);
	        for (var k in methods) transform[k] = methods[k];
	        return transform;
	      }
	    };
	  };
	  function d3_geo_transform(stream) {
	    this.stream = stream;
	  }
	  d3_geo_transform.prototype = {
	    point: function(x, y) {
	      this.stream.point(x, y);
	    },
	    sphere: function() {
	      this.stream.sphere();
	    },
	    lineStart: function() {
	      this.stream.lineStart();
	    },
	    lineEnd: function() {
	      this.stream.lineEnd();
	    },
	    polygonStart: function() {
	      this.stream.polygonStart();
	    },
	    polygonEnd: function() {
	      this.stream.polygonEnd();
	    }
	  };
	  function d3_geo_transformPoint(stream, point) {
	    return {
	      point: point,
	      sphere: function() {
	        stream.sphere();
	      },
	      lineStart: function() {
	        stream.lineStart();
	      },
	      lineEnd: function() {
	        stream.lineEnd();
	      },
	      polygonStart: function() {
	        stream.polygonStart();
	      },
	      polygonEnd: function() {
	        stream.polygonEnd();
	      }
	    };
	  }
	  d3.geo.projection = d3_geo_projection;
	  d3.geo.projectionMutator = d3_geo_projectionMutator;
	  function d3_geo_projection(project) {
	    return d3_geo_projectionMutator(function() {
	      return project;
	    })();
	  }
	  function d3_geo_projectionMutator(projectAt) {
	    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
	      x = project(x, y);
	      return [ x[0] * k + δx, δy - x[1] * k ];
	    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
	    function projection(point) {
	      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
	      return [ point[0] * k + δx, δy - point[1] * k ];
	    }
	    function invert(point) {
	      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
	      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
	    }
	    projection.stream = function(output) {
	      if (stream) stream.valid = false;
	      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
	      stream.valid = true;
	      return stream;
	    };
	    projection.clipAngle = function(_) {
	      if (!arguments.length) return clipAngle;
	      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
	      return invalidate();
	    };
	    projection.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent;
	      clipExtent = _;
	      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
	      return invalidate();
	    };
	    projection.scale = function(_) {
	      if (!arguments.length) return k;
	      k = +_;
	      return reset();
	    };
	    projection.translate = function(_) {
	      if (!arguments.length) return [ x, y ];
	      x = +_[0];
	      y = +_[1];
	      return reset();
	    };
	    projection.center = function(_) {
	      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
	      λ = _[0] % 360 * d3_radians;
	      φ = _[1] % 360 * d3_radians;
	      return reset();
	    };
	    projection.rotate = function(_) {
	      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
	      δλ = _[0] % 360 * d3_radians;
	      δφ = _[1] % 360 * d3_radians;
	      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
	      return reset();
	    };
	    d3.rebind(projection, projectResample, "precision");
	    function reset() {
	      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
	      var center = project(λ, φ);
	      δx = x - center[0] * k;
	      δy = y + center[1] * k;
	      return invalidate();
	    }
	    function invalidate() {
	      if (stream) stream.valid = false, stream = null;
	      return projection;
	    }
	    return function() {
	      project = projectAt.apply(this, arguments);
	      projection.invert = project.invert && invert;
	      return reset();
	    };
	  }
	  function d3_geo_projectionRadians(stream) {
	    return d3_geo_transformPoint(stream, function(x, y) {
	      stream.point(x * d3_radians, y * d3_radians);
	    });
	  }
	  function d3_geo_equirectangular(λ, φ) {
	    return [ λ, φ ];
	  }
	  (d3.geo.equirectangular = function() {
	    return d3_geo_projection(d3_geo_equirectangular);
	  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
	  d3.geo.rotation = function(rotate) {
	    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
	    function forward(coordinates) {
	      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    }
	    forward.invert = function(coordinates) {
	      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
	      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
	    };
	    return forward;
	  };
	  function d3_geo_identityRotation(λ, φ) {
	    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	  }
	  d3_geo_identityRotation.invert = d3_geo_equirectangular;
	  function d3_geo_rotation(δλ, δφ, δγ) {
	    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
	  }
	  function d3_geo_forwardRotationλ(δλ) {
	    return function(λ, φ) {
	      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
	    };
	  }
	  function d3_geo_rotationλ(δλ) {
	    var rotation = d3_geo_forwardRotationλ(δλ);
	    rotation.invert = d3_geo_forwardRotationλ(-δλ);
	    return rotation;
	  }
	  function d3_geo_rotationφγ(δφ, δγ) {
	    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
	    function rotation(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
	      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
	    }
	    rotation.invert = function(λ, φ) {
	      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
	      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
	    };
	    return rotation;
	  }
	  d3.geo.circle = function() {
	    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
	    function circle() {
	      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
	      interpolate(null, null, 1, {
	        point: function(x, y) {
	          ring.push(x = rotate(x, y));
	          x[0] *= d3_degrees, x[1] *= d3_degrees;
	        }
	      });
	      return {
	        type: "Polygon",
	        coordinates: [ ring ]
	      };
	    }
	    circle.origin = function(x) {
	      if (!arguments.length) return origin;
	      origin = x;
	      return circle;
	    };
	    circle.angle = function(x) {
	      if (!arguments.length) return angle;
	      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
	      return circle;
	    };
	    circle.precision = function(_) {
	      if (!arguments.length) return precision;
	      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
	      return circle;
	    };
	    return circle.angle(90);
	  };
	  function d3_geo_circleInterpolate(radius, precision) {
	    var cr = Math.cos(radius), sr = Math.sin(radius);
	    return function(from, to, direction, listener) {
	      var step = direction * precision;
	      if (from != null) {
	        from = d3_geo_circleAngle(cr, from);
	        to = d3_geo_circleAngle(cr, to);
	        if (direction > 0 ? from < to : from > to) from += direction * τ;
	      } else {
	        from = radius + direction * τ;
	        to = radius - .5 * step;
	      }
	      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
	        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
	      }
	    };
	  }
	  function d3_geo_circleAngle(cr, point) {
	    var a = d3_geo_cartesian(point);
	    a[0] -= cr;
	    d3_geo_cartesianNormalize(a);
	    var angle = d3_acos(-a[1]);
	    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
	  }
	  d3.geo.distance = function(a, b) {
	    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
	    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
	  };
	  d3.geo.graticule = function() {
	    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
	    function graticule() {
	      return {
	        type: "MultiLineString",
	        coordinates: lines()
	      };
	    }
	    function lines() {
	      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
	        return abs(x % DX) > ε;
	      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
	        return abs(y % DY) > ε;
	      }).map(y));
	    }
	    graticule.lines = function() {
	      return lines().map(function(coordinates) {
	        return {
	          type: "LineString",
	          coordinates: coordinates
	        };
	      });
	    };
	    graticule.outline = function() {
	      return {
	        type: "Polygon",
	        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
	      };
	    };
	    graticule.extent = function(_) {
	      if (!arguments.length) return graticule.minorExtent();
	      return graticule.majorExtent(_).minorExtent(_);
	    };
	    graticule.majorExtent = function(_) {
	      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
	      X0 = +_[0][0], X1 = +_[1][0];
	      Y0 = +_[0][1], Y1 = +_[1][1];
	      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.minorExtent = function(_) {
	      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
	      x0 = +_[0][0], x1 = +_[1][0];
	      y0 = +_[0][1], y1 = +_[1][1];
	      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	      return graticule.precision(precision);
	    };
	    graticule.step = function(_) {
	      if (!arguments.length) return graticule.minorStep();
	      return graticule.majorStep(_).minorStep(_);
	    };
	    graticule.majorStep = function(_) {
	      if (!arguments.length) return [ DX, DY ];
	      DX = +_[0], DY = +_[1];
	      return graticule;
	    };
	    graticule.minorStep = function(_) {
	      if (!arguments.length) return [ dx, dy ];
	      dx = +_[0], dy = +_[1];
	      return graticule;
	    };
	    graticule.precision = function(_) {
	      if (!arguments.length) return precision;
	      precision = +_;
	      x = d3_geo_graticuleX(y0, y1, 90);
	      y = d3_geo_graticuleY(x0, x1, precision);
	      X = d3_geo_graticuleX(Y0, Y1, 90);
	      Y = d3_geo_graticuleY(X0, X1, precision);
	      return graticule;
	    };
	    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
	  };
	  function d3_geo_graticuleX(y0, y1, dy) {
	    var y = d3.range(y0, y1 - ε, dy).concat(y1);
	    return function(x) {
	      return y.map(function(y) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_geo_graticuleY(x0, x1, dx) {
	    var x = d3.range(x0, x1 - ε, dx).concat(x1);
	    return function(y) {
	      return x.map(function(x) {
	        return [ x, y ];
	      });
	    };
	  }
	  function d3_source(d) {
	    return d.source;
	  }
	  function d3_target(d) {
	    return d.target;
	  }
	  d3.geo.greatArc = function() {
	    var source = d3_source, source_, target = d3_target, target_;
	    function greatArc() {
	      return {
	        type: "LineString",
	        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
	      };
	    }
	    greatArc.distance = function() {
	      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
	    };
	    greatArc.source = function(_) {
	      if (!arguments.length) return source;
	      source = _, source_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.target = function(_) {
	      if (!arguments.length) return target;
	      target = _, target_ = typeof _ === "function" ? null : _;
	      return greatArc;
	    };
	    greatArc.precision = function() {
	      return arguments.length ? greatArc : 0;
	    };
	    return greatArc;
	  };
	  d3.geo.interpolate = function(source, target) {
	    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
	  };
	  function d3_geo_interpolate(x0, y0, x1, y1) {
	    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
	    var interpolate = d ? function(t) {
	      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
	      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
	    } : function() {
	      return [ x0 * d3_degrees, y0 * d3_degrees ];
	    };
	    interpolate.distance = d;
	    return interpolate;
	  }
	  d3.geo.length = function(object) {
	    d3_geo_lengthSum = 0;
	    d3.geo.stream(object, d3_geo_length);
	    return d3_geo_lengthSum;
	  };
	  var d3_geo_lengthSum;
	  var d3_geo_length = {
	    sphere: d3_noop,
	    point: d3_noop,
	    lineStart: d3_geo_lengthLineStart,
	    lineEnd: d3_noop,
	    polygonStart: d3_noop,
	    polygonEnd: d3_noop
	  };
	  function d3_geo_lengthLineStart() {
	    var λ0, sinφ0, cosφ0;
	    d3_geo_length.point = function(λ, φ) {
	      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
	      d3_geo_length.point = nextPoint;
	    };
	    d3_geo_length.lineEnd = function() {
	      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
	    };
	    function nextPoint(λ, φ) {
	      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
	      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
	      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
	    }
	  }
	  function d3_geo_azimuthal(scale, angle) {
	    function azimuthal(λ, φ) {
	      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
	      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
	    }
	    azimuthal.invert = function(x, y) {
	      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
	      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
	    };
	    return azimuthal;
	  }
	  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
	    return Math.sqrt(2 / (1 + cosλcosφ));
	  }, function(ρ) {
	    return 2 * Math.asin(ρ / 2);
	  });
	  (d3.geo.azimuthalEqualArea = function() {
	    return d3_geo_projection(d3_geo_azimuthalEqualArea);
	  }).raw = d3_geo_azimuthalEqualArea;
	  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
	    var c = Math.acos(cosλcosφ);
	    return c && c / Math.sin(c);
	  }, d3_identity);
	  (d3.geo.azimuthalEquidistant = function() {
	    return d3_geo_projection(d3_geo_azimuthalEquidistant);
	  }).raw = d3_geo_azimuthalEquidistant;
	  function d3_geo_conicConformal(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), t = function(φ) {
	      return Math.tan(π / 4 + φ / 2);
	    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
	    if (!n) return d3_geo_mercator;
	    function forward(λ, φ) {
	      if (F > 0) {
	        if (φ < -halfπ + ε) φ = -halfπ + ε;
	      } else {
	        if (φ > halfπ - ε) φ = halfπ - ε;
	      }
	      var ρ = F / Math.pow(t(φ), n);
	      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
	      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
	    };
	    return forward;
	  }
	  (d3.geo.conicConformal = function() {
	    return d3_geo_conic(d3_geo_conicConformal);
	  }).raw = d3_geo_conicConformal;
	  function d3_geo_conicEquidistant(φ0, φ1) {
	    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
	    if (abs(n) < ε) return d3_geo_equirectangular;
	    function forward(λ, φ) {
	      var ρ = G - φ;
	      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
	    }
	    forward.invert = function(x, y) {
	      var ρ0_y = G - y;
	      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
	    };
	    return forward;
	  }
	  (d3.geo.conicEquidistant = function() {
	    return d3_geo_conic(d3_geo_conicEquidistant);
	  }).raw = d3_geo_conicEquidistant;
	  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / cosλcosφ;
	  }, Math.atan);
	  (d3.geo.gnomonic = function() {
	    return d3_geo_projection(d3_geo_gnomonic);
	  }).raw = d3_geo_gnomonic;
	  function d3_geo_mercator(λ, φ) {
	    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
	  }
	  d3_geo_mercator.invert = function(x, y) {
	    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
	  };
	  function d3_geo_mercatorProjection(project) {
	    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
	    m.scale = function() {
	      var v = scale.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.translate = function() {
	      var v = translate.apply(m, arguments);
	      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
	    };
	    m.clipExtent = function(_) {
	      var v = clipExtent.apply(m, arguments);
	      if (v === m) {
	        if (clipAuto = _ == null) {
	          var k = π * scale(), t = translate();
	          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
	        }
	      } else if (clipAuto) {
	        v = null;
	      }
	      return v;
	    };
	    return m.clipExtent(null);
	  }
	  (d3.geo.mercator = function() {
	    return d3_geo_mercatorProjection(d3_geo_mercator);
	  }).raw = d3_geo_mercator;
	  var d3_geo_orthographic = d3_geo_azimuthal(function() {
	    return 1;
	  }, Math.asin);
	  (d3.geo.orthographic = function() {
	    return d3_geo_projection(d3_geo_orthographic);
	  }).raw = d3_geo_orthographic;
	  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
	    return 1 / (1 + cosλcosφ);
	  }, function(ρ) {
	    return 2 * Math.atan(ρ);
	  });
	  (d3.geo.stereographic = function() {
	    return d3_geo_projection(d3_geo_stereographic);
	  }).raw = d3_geo_stereographic;
	  function d3_geo_transverseMercator(λ, φ) {
	    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
	  }
	  d3_geo_transverseMercator.invert = function(x, y) {
	    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
	  };
	  (d3.geo.transverseMercator = function() {
	    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
	    projection.center = function(_) {
	      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
	    };
	    projection.rotate = function(_) {
	      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
	      [ _[0], _[1], _[2] - 90 ]);
	    };
	    return rotate([ 0, 0, 90 ]);
	  }).raw = d3_geo_transverseMercator;
	  d3.geom = {};
	  function d3_geom_pointX(d) {
	    return d[0];
	  }
	  function d3_geom_pointY(d) {
	    return d[1];
	  }
	  d3.geom.hull = function(vertices) {
	    var x = d3_geom_pointX, y = d3_geom_pointY;
	    if (arguments.length) return hull(vertices);
	    function hull(data) {
	      if (data.length < 3) return [];
	      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
	      for (i = 0; i < n; i++) {
	        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
	      }
	      points.sort(d3_geom_hullOrder);
	      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
	      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
	      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
	      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
	      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
	      return polygon;
	    }
	    hull.x = function(_) {
	      return arguments.length ? (x = _, hull) : x;
	    };
	    hull.y = function(_) {
	      return arguments.length ? (y = _, hull) : y;
	    };
	    return hull;
	  };
	  function d3_geom_hullUpper(points) {
	    var n = points.length, hull = [ 0, 1 ], hs = 2;
	    for (var i = 2; i < n; i++) {
	      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
	      hull[hs++] = i;
	    }
	    return hull.slice(0, hs);
	  }
	  function d3_geom_hullOrder(a, b) {
	    return a[0] - b[0] || a[1] - b[1];
	  }
	  d3.geom.polygon = function(coordinates) {
	    d3_subclass(coordinates, d3_geom_polygonPrototype);
	    return coordinates;
	  };
	  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
	  d3_geom_polygonPrototype.area = function() {
	    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      area += a[1] * b[0] - a[0] * b[1];
	    }
	    return area * .5;
	  };
	  d3_geom_polygonPrototype.centroid = function(k) {
	    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
	    if (!arguments.length) k = -1 / (6 * this.area());
	    while (++i < n) {
	      a = b;
	      b = this[i];
	      c = a[0] * b[1] - b[0] * a[1];
	      x += (a[0] + b[0]) * c;
	      y += (a[1] + b[1]) * c;
	    }
	    return [ x * k, y * k ];
	  };
	  d3_geom_polygonPrototype.clip = function(subject) {
	    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
	    while (++i < n) {
	      input = subject.slice();
	      subject.length = 0;
	      b = this[i];
	      c = input[(m = input.length - closed) - 1];
	      j = -1;
	      while (++j < m) {
	        d = input[j];
	        if (d3_geom_polygonInside(d, a, b)) {
	          if (!d3_geom_polygonInside(c, a, b)) {
	            subject.push(d3_geom_polygonIntersect(c, d, a, b));
	          }
	          subject.push(d);
	        } else if (d3_geom_polygonInside(c, a, b)) {
	          subject.push(d3_geom_polygonIntersect(c, d, a, b));
	        }
	        c = d;
	      }
	      if (closed) subject.push(subject[0]);
	      a = b;
	    }
	    return subject;
	  };
	  function d3_geom_polygonInside(p, a, b) {
	    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
	  }
	  function d3_geom_polygonIntersect(c, d, a, b) {
	    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
	    return [ x1 + ua * x21, y1 + ua * y21 ];
	  }
	  function d3_geom_polygonClosed(coordinates) {
	    var a = coordinates[0], b = coordinates[coordinates.length - 1];
	    return !(a[0] - b[0] || a[1] - b[1]);
	  }
	  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
	  function d3_geom_voronoiBeach() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.edge = this.site = this.circle = null;
	  }
	  function d3_geom_voronoiCreateBeach(site) {
	    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
	    beach.site = site;
	    return beach;
	  }
	  function d3_geom_voronoiDetachBeach(beach) {
	    d3_geom_voronoiDetachCircle(beach);
	    d3_geom_voronoiBeaches.remove(beach);
	    d3_geom_voronoiBeachPool.push(beach);
	    d3_geom_voronoiRedBlackNode(beach);
	  }
	  function d3_geom_voronoiRemoveBeach(beach) {
	    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
	      x: x,
	      y: y
	    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
	    d3_geom_voronoiDetachBeach(beach);
	    var lArc = previous;
	    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
	      previous = lArc.P;
	      disappearing.unshift(lArc);
	      d3_geom_voronoiDetachBeach(lArc);
	      lArc = previous;
	    }
	    disappearing.unshift(lArc);
	    d3_geom_voronoiDetachCircle(lArc);
	    var rArc = next;
	    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
	      next = rArc.N;
	      disappearing.push(rArc);
	      d3_geom_voronoiDetachBeach(rArc);
	      rArc = next;
	    }
	    disappearing.push(rArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var nArcs = disappearing.length, iArc;
	    for (iArc = 1; iArc < nArcs; ++iArc) {
	      rArc = disappearing[iArc];
	      lArc = disappearing[iArc - 1];
	      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	    }
	    lArc = disappearing[0];
	    rArc = disappearing[nArcs - 1];
	    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiAddBeach(site) {
	    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
	    while (node) {
	      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
	      if (dxl > ε) node = node.L; else {
	        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
	        if (dxr > ε) {
	          if (!node.R) {
	            lArc = node;
	            break;
	          }
	          node = node.R;
	        } else {
	          if (dxl > -ε) {
	            lArc = node.P;
	            rArc = node;
	          } else if (dxr > -ε) {
	            lArc = node;
	            rArc = node.N;
	          } else {
	            lArc = rArc = node;
	          }
	          break;
	        }
	      }
	    }
	    var newArc = d3_geom_voronoiCreateBeach(site);
	    d3_geom_voronoiBeaches.insert(lArc, newArc);
	    if (!lArc && !rArc) return;
	    if (lArc === rArc) {
	      d3_geom_voronoiDetachCircle(lArc);
	      rArc = d3_geom_voronoiCreateBeach(lArc.site);
	      d3_geom_voronoiBeaches.insert(newArc, rArc);
	      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      d3_geom_voronoiAttachCircle(lArc);
	      d3_geom_voronoiAttachCircle(rArc);
	      return;
	    }
	    if (!rArc) {
	      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
	      return;
	    }
	    d3_geom_voronoiDetachCircle(lArc);
	    d3_geom_voronoiDetachCircle(rArc);
	    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
	      x: (cy * hb - by * hc) / d + ax,
	      y: (bx * hc - cx * hb) / d + ay
	    };
	    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
	    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
	    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
	    d3_geom_voronoiAttachCircle(lArc);
	    d3_geom_voronoiAttachCircle(rArc);
	  }
	  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
	    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
	    if (!pby2) return rfocx;
	    var lArc = arc.P;
	    if (!lArc) return -Infinity;
	    site = lArc.site;
	    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
	    if (!plby2) return lfocx;
	    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
	    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
	    return (rfocx + lfocx) / 2;
	  }
	  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
	    var rArc = arc.N;
	    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
	    var site = arc.site;
	    return site.y === directrix ? site.x : Infinity;
	  }
	  function d3_geom_voronoiCell(site) {
	    this.site = site;
	    this.edges = [];
	  }
	  d3_geom_voronoiCell.prototype.prepare = function() {
	    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
	    while (iHalfEdge--) {
	      edge = halfEdges[iHalfEdge].edge;
	      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
	    }
	    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
	    return halfEdges.length;
	  };
	  function d3_geom_voronoiCloseCells(extent) {
	    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
	    while (iCell--) {
	      cell = cells[iCell];
	      if (!cell || !cell.prepare()) continue;
	      halfEdges = cell.edges;
	      nHalfEdges = halfEdges.length;
	      iHalfEdge = 0;
	      while (iHalfEdge < nHalfEdges) {
	        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
	        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
	        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
	          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
	            x: x0,
	            y: abs(x2 - x0) < ε ? y2 : y1
	          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
	            x: abs(y2 - y1) < ε ? x2 : x1,
	            y: y1
	          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
	            x: x1,
	            y: abs(x2 - x1) < ε ? y2 : y0
	          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
	            x: abs(y2 - y0) < ε ? x2 : x0,
	            y: y0
	          } : null), cell.site, null));
	          ++nHalfEdges;
	        }
	      }
	    }
	  }
	  function d3_geom_voronoiHalfEdgeOrder(a, b) {
	    return b.angle - a.angle;
	  }
	  function d3_geom_voronoiCircle() {
	    d3_geom_voronoiRedBlackNode(this);
	    this.x = this.y = this.arc = this.site = this.cy = null;
	  }
	  function d3_geom_voronoiAttachCircle(arc) {
	    var lArc = arc.P, rArc = arc.N;
	    if (!lArc || !rArc) return;
	    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
	    if (lSite === rSite) return;
	    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
	    var d = 2 * (ax * cy - ay * cx);
	    if (d >= -ε2) return;
	    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
	    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
	    circle.arc = arc;
	    circle.site = cSite;
	    circle.x = x + bx;
	    circle.y = cy + Math.sqrt(x * x + y * y);
	    circle.cy = cy;
	    arc.circle = circle;
	    var before = null, node = d3_geom_voronoiCircles._;
	    while (node) {
	      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
	        if (node.L) node = node.L; else {
	          before = node.P;
	          break;
	        }
	      } else {
	        if (node.R) node = node.R; else {
	          before = node;
	          break;
	        }
	      }
	    }
	    d3_geom_voronoiCircles.insert(before, circle);
	    if (!before) d3_geom_voronoiFirstCircle = circle;
	  }
	  function d3_geom_voronoiDetachCircle(arc) {
	    var circle = arc.circle;
	    if (circle) {
	      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
	      d3_geom_voronoiCircles.remove(circle);
	      d3_geom_voronoiCirclePool.push(circle);
	      d3_geom_voronoiRedBlackNode(circle);
	      arc.circle = null;
	    }
	  }
	  function d3_geom_voronoiClipEdges(extent) {
	    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
	    while (i--) {
	      e = edges[i];
	      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
	        e.a = e.b = null;
	        edges.splice(i, 1);
	      }
	    }
	  }
	  function d3_geom_voronoiConnectEdge(edge, extent) {
	    var vb = edge.b;
	    if (vb) return true;
	    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
	    if (ry === ly) {
	      if (fx < x0 || fx >= x1) return;
	      if (lx > rx) {
	        if (!va) va = {
	          x: fx,
	          y: y0
	        }; else if (va.y >= y1) return;
	        vb = {
	          x: fx,
	          y: y1
	        };
	      } else {
	        if (!va) va = {
	          x: fx,
	          y: y1
	        }; else if (va.y < y0) return;
	        vb = {
	          x: fx,
	          y: y0
	        };
	      }
	    } else {
	      fm = (lx - rx) / (ry - ly);
	      fb = fy - fm * fx;
	      if (fm < -1 || fm > 1) {
	        if (lx > rx) {
	          if (!va) va = {
	            x: (y0 - fb) / fm,
	            y: y0
	          }; else if (va.y >= y1) return;
	          vb = {
	            x: (y1 - fb) / fm,
	            y: y1
	          };
	        } else {
	          if (!va) va = {
	            x: (y1 - fb) / fm,
	            y: y1
	          }; else if (va.y < y0) return;
	          vb = {
	            x: (y0 - fb) / fm,
	            y: y0
	          };
	        }
	      } else {
	        if (ly < ry) {
	          if (!va) va = {
	            x: x0,
	            y: fm * x0 + fb
	          }; else if (va.x >= x1) return;
	          vb = {
	            x: x1,
	            y: fm * x1 + fb
	          };
	        } else {
	          if (!va) va = {
	            x: x1,
	            y: fm * x1 + fb
	          }; else if (va.x < x0) return;
	          vb = {
	            x: x0,
	            y: fm * x0 + fb
	          };
	        }
	      }
	    }
	    edge.a = va;
	    edge.b = vb;
	    return true;
	  }
	  function d3_geom_voronoiEdge(lSite, rSite) {
	    this.l = lSite;
	    this.r = rSite;
	    this.a = this.b = null;
	  }
	  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, rSite);
	    d3_geom_voronoiEdges.push(edge);
	    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
	    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
	    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
	    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
	    return edge;
	  }
	  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
	    var edge = new d3_geom_voronoiEdge(lSite, null);
	    edge.a = va;
	    edge.b = vb;
	    d3_geom_voronoiEdges.push(edge);
	    return edge;
	  }
	  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
	    if (!edge.a && !edge.b) {
	      edge.a = vertex;
	      edge.l = lSite;
	      edge.r = rSite;
	    } else if (edge.l === rSite) {
	      edge.b = vertex;
	    } else {
	      edge.a = vertex;
	    }
	  }
	  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
	    var va = edge.a, vb = edge.b;
	    this.edge = edge;
	    this.site = lSite;
	    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
	  }
	  d3_geom_voronoiHalfEdge.prototype = {
	    start: function() {
	      return this.edge.l === this.site ? this.edge.a : this.edge.b;
	    },
	    end: function() {
	      return this.edge.l === this.site ? this.edge.b : this.edge.a;
	    }
	  };
	  function d3_geom_voronoiRedBlackTree() {
	    this._ = null;
	  }
	  function d3_geom_voronoiRedBlackNode(node) {
	    node.U = node.C = node.L = node.R = node.P = node.N = null;
	  }
	  d3_geom_voronoiRedBlackTree.prototype = {
	    insert: function(after, node) {
	      var parent, grandpa, uncle;
	      if (after) {
	        node.P = after;
	        node.N = after.N;
	        if (after.N) after.N.P = node;
	        after.N = node;
	        if (after.R) {
	          after = after.R;
	          while (after.L) after = after.L;
	          after.L = node;
	        } else {
	          after.R = node;
	        }
	        parent = after;
	      } else if (this._) {
	        after = d3_geom_voronoiRedBlackFirst(this._);
	        node.P = null;
	        node.N = after;
	        after.P = after.L = node;
	        parent = after;
	      } else {
	        node.P = node.N = null;
	        this._ = node;
	        parent = null;
	      }
	      node.L = node.R = null;
	      node.U = parent;
	      node.C = true;
	      after = node;
	      while (parent && parent.C) {
	        grandpa = parent.U;
	        if (parent === grandpa.L) {
	          uncle = grandpa.R;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.R) {
	              d3_geom_voronoiRedBlackRotateLeft(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
	          }
	        } else {
	          uncle = grandpa.L;
	          if (uncle && uncle.C) {
	            parent.C = uncle.C = false;
	            grandpa.C = true;
	            after = grandpa;
	          } else {
	            if (after === parent.L) {
	              d3_geom_voronoiRedBlackRotateRight(this, parent);
	              after = parent;
	              parent = after.U;
	            }
	            parent.C = false;
	            grandpa.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
	          }
	        }
	        parent = after.U;
	      }
	      this._.C = false;
	    },
	    remove: function(node) {
	      if (node.N) node.N.P = node.P;
	      if (node.P) node.P.N = node.N;
	      node.N = node.P = null;
	      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
	      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
	      if (parent) {
	        if (parent.L === node) parent.L = next; else parent.R = next;
	      } else {
	        this._ = next;
	      }
	      if (left && right) {
	        red = next.C;
	        next.C = node.C;
	        next.L = left;
	        left.U = next;
	        if (next !== right) {
	          parent = next.U;
	          next.U = node.U;
	          node = next.R;
	          parent.L = node;
	          next.R = right;
	          right.U = next;
	        } else {
	          next.U = parent;
	          parent = next;
	          node = next.R;
	        }
	      } else {
	        red = node.C;
	        node = next;
	      }
	      if (node) node.U = parent;
	      if (red) return;
	      if (node && node.C) {
	        node.C = false;
	        return;
	      }
	      do {
	        if (node === this._) break;
	        if (node === parent.L) {
	          sibling = parent.R;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            sibling = parent.R;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.R || !sibling.R.C) {
	              sibling.L.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateRight(this, sibling);
	              sibling = parent.R;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.R.C = false;
	            d3_geom_voronoiRedBlackRotateLeft(this, parent);
	            node = this._;
	            break;
	          }
	        } else {
	          sibling = parent.L;
	          if (sibling.C) {
	            sibling.C = false;
	            parent.C = true;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            sibling = parent.L;
	          }
	          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
	            if (!sibling.L || !sibling.L.C) {
	              sibling.R.C = false;
	              sibling.C = true;
	              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
	              sibling = parent.L;
	            }
	            sibling.C = parent.C;
	            parent.C = sibling.L.C = false;
	            d3_geom_voronoiRedBlackRotateRight(this, parent);
	            node = this._;
	            break;
	          }
	        }
	        sibling.C = true;
	        node = parent;
	        parent = parent.U;
	      } while (!node.C);
	      if (node) node.C = false;
	    }
	  };
	  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
	    var p = node, q = node.R, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.R = q.L;
	    if (p.R) p.R.U = p;
	    q.L = p;
	  }
	  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
	    var p = node, q = node.L, parent = p.U;
	    if (parent) {
	      if (parent.L === p) parent.L = q; else parent.R = q;
	    } else {
	      tree._ = q;
	    }
	    q.U = parent;
	    p.U = q;
	    p.L = q.R;
	    if (p.L) p.L.U = p;
	    q.R = p;
	  }
	  function d3_geom_voronoiRedBlackFirst(node) {
	    while (node.L) node = node.L;
	    return node;
	  }
	  function d3_geom_voronoi(sites, bbox) {
	    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
	    d3_geom_voronoiEdges = [];
	    d3_geom_voronoiCells = new Array(sites.length);
	    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
	    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
	    while (true) {
	      circle = d3_geom_voronoiFirstCircle;
	      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
	        if (site.x !== x0 || site.y !== y0) {
	          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
	          d3_geom_voronoiAddBeach(site);
	          x0 = site.x, y0 = site.y;
	        }
	        site = sites.pop();
	      } else if (circle) {
	        d3_geom_voronoiRemoveBeach(circle.arc);
	      } else {
	        break;
	      }
	    }
	    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
	    var diagram = {
	      cells: d3_geom_voronoiCells,
	      edges: d3_geom_voronoiEdges
	    };
	    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
	    return diagram;
	  }
	  function d3_geom_voronoiVertexOrder(a, b) {
	    return b.y - a.y || b.x - a.x;
	  }
	  d3.geom.voronoi = function(points) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
	    if (points) return voronoi(points);
	    function voronoi(data) {
	      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
	      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
	        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
	          var s = e.start();
	          return [ s.x, s.y ];
	        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
	        polygon.point = data[i];
	      });
	      return polygons;
	    }
	    function sites(data) {
	      return data.map(function(d, i) {
	        return {
	          x: Math.round(fx(d, i) / ε) * ε,
	          y: Math.round(fy(d, i) / ε) * ε,
	          i: i
	        };
	      });
	    }
	    voronoi.links = function(data) {
	      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
	        return edge.l && edge.r;
	      }).map(function(edge) {
	        return {
	          source: data[edge.l.i],
	          target: data[edge.r.i]
	        };
	      });
	    };
	    voronoi.triangles = function(data) {
	      var triangles = [];
	      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
	        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
	        while (++j < m) {
	          e0 = e1;
	          s0 = s1;
	          e1 = edges[j].edge;
	          s1 = e1.l === site ? e1.r : e1.l;
	          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
	            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
	          }
	        }
	      });
	      return triangles;
	    };
	    voronoi.x = function(_) {
	      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
	    };
	    voronoi.y = function(_) {
	      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
	    };
	    voronoi.clipExtent = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
	      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
	      return voronoi;
	    };
	    voronoi.size = function(_) {
	      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
	      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
	    };
	    return voronoi;
	  };
	  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
	  function d3_geom_voronoiTriangleArea(a, b, c) {
	    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
	  }
	  d3.geom.delaunay = function(vertices) {
	    return d3.geom.voronoi().triangles(vertices);
	  };
	  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
	    if (compat = arguments.length) {
	      x = d3_geom_quadtreeCompatX;
	      y = d3_geom_quadtreeCompatY;
	      if (compat === 3) {
	        y2 = y1;
	        x2 = x1;
	        y1 = x1 = 0;
	      }
	      return quadtree(points);
	    }
	    function quadtree(data) {
	      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
	      if (x1 != null) {
	        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
	      } else {
	        x2_ = y2_ = -(x1_ = y1_ = Infinity);
	        xs = [], ys = [];
	        n = data.length;
	        if (compat) for (i = 0; i < n; ++i) {
	          d = data[i];
	          if (d.x < x1_) x1_ = d.x;
	          if (d.y < y1_) y1_ = d.y;
	          if (d.x > x2_) x2_ = d.x;
	          if (d.y > y2_) y2_ = d.y;
	          xs.push(d.x);
	          ys.push(d.y);
	        } else for (i = 0; i < n; ++i) {
	          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
	          if (x_ < x1_) x1_ = x_;
	          if (y_ < y1_) y1_ = y_;
	          if (x_ > x2_) x2_ = x_;
	          if (y_ > y2_) y2_ = y_;
	          xs.push(x_);
	          ys.push(y_);
	        }
	      }
	      var dx = x2_ - x1_, dy = y2_ - y1_;
	      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
	      function insert(n, d, x, y, x1, y1, x2, y2) {
	        if (isNaN(x) || isNaN(y)) return;
	        if (n.leaf) {
	          var nx = n.x, ny = n.y;
	          if (nx != null) {
	            if (abs(nx - x) + abs(ny - y) < .01) {
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            } else {
	              var nPoint = n.point;
	              n.x = n.y = n.point = null;
	              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
	              insertChild(n, d, x, y, x1, y1, x2, y2);
	            }
	          } else {
	            n.x = x, n.y = y, n.point = d;
	          }
	        } else {
	          insertChild(n, d, x, y, x1, y1, x2, y2);
	        }
	      }
	      function insertChild(n, d, x, y, x1, y1, x2, y2) {
	        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
	        n.leaf = false;
	        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
	        if (right) x1 = xm; else x2 = xm;
	        if (below) y1 = ym; else y2 = ym;
	        insert(n, d, x, y, x1, y1, x2, y2);
	      }
	      var root = d3_geom_quadtreeNode();
	      root.add = function(d) {
	        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
	      };
	      root.visit = function(f) {
	        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
	      };
	      root.find = function(point) {
	        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
	      };
	      i = -1;
	      if (x1 == null) {
	        while (++i < n) {
	          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
	        }
	        --i;
	      } else data.forEach(root.add);
	      xs = ys = data = d = null;
	      return root;
	    }
	    quadtree.x = function(_) {
	      return arguments.length ? (x = _, quadtree) : x;
	    };
	    quadtree.y = function(_) {
	      return arguments.length ? (y = _, quadtree) : y;
	    };
	    quadtree.extent = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
	      y2 = +_[1][1];
	      return quadtree;
	    };
	    quadtree.size = function(_) {
	      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
	      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
	      return quadtree;
	    };
	    return quadtree;
	  };
	  function d3_geom_quadtreeCompatX(d) {
	    return d.x;
	  }
	  function d3_geom_quadtreeCompatY(d) {
	    return d.y;
	  }
	  function d3_geom_quadtreeNode() {
	    return {
	      leaf: true,
	      nodes: [],
	      point: null,
	      x: null,
	      y: null
	    };
	  }
	  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
	    if (!f(node, x1, y1, x2, y2)) {
	      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
	      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
	      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
	      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
	      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
	    }
	  }
	  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
	    var minDistance2 = Infinity, closestPoint;
	    (function find(node, x1, y1, x2, y2) {
	      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
	      if (point = node.point) {
	        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
	        if (distance2 < minDistance2) {
	          var distance = Math.sqrt(minDistance2 = distance2);
	          x0 = x - distance, y0 = y - distance;
	          x3 = x + distance, y3 = y + distance;
	          closestPoint = point;
	        }
	      }
	      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
	      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
	        if (node = children[i & 3]) switch (i & 3) {
	         case 0:
	          find(node, x1, y1, xm, ym);
	          break;
	
	         case 1:
	          find(node, xm, y1, x2, ym);
	          break;
	
	         case 2:
	          find(node, x1, ym, xm, y2);
	          break;
	
	         case 3:
	          find(node, xm, ym, x2, y2);
	          break;
	        }
	      }
	    })(root, x0, y0, x3, y3);
	    return closestPoint;
	  }
	  d3.interpolateRgb = d3_interpolateRgb;
	  function d3_interpolateRgb(a, b) {
	    a = d3.rgb(a);
	    b = d3.rgb(b);
	    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
	    return function(t) {
	      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
	    };
	  }
	  d3.interpolateObject = d3_interpolateObject;
	  function d3_interpolateObject(a, b) {
	    var i = {}, c = {}, k;
	    for (k in a) {
	      if (k in b) {
	        i[k] = d3_interpolate(a[k], b[k]);
	      } else {
	        c[k] = a[k];
	      }
	    }
	    for (k in b) {
	      if (!(k in a)) {
	        c[k] = b[k];
	      }
	    }
	    return function(t) {
	      for (k in i) c[k] = i[k](t);
	      return c;
	    };
	  }
	  d3.interpolateNumber = d3_interpolateNumber;
	  function d3_interpolateNumber(a, b) {
	    a = +a, b = +b;
	    return function(t) {
	      return a * (1 - t) + b * t;
	    };
	  }
	  d3.interpolateString = d3_interpolateString;
	  function d3_interpolateString(a, b) {
	    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
	    a = a + "", b = b + "";
	    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
	      if ((bs = bm.index) > bi) {
	        bs = b.slice(bi, bs);
	        if (s[i]) s[i] += bs; else s[++i] = bs;
	      }
	      if ((am = am[0]) === (bm = bm[0])) {
	        if (s[i]) s[i] += bm; else s[++i] = bm;
	      } else {
	        s[++i] = null;
	        q.push({
	          i: i,
	          x: d3_interpolateNumber(am, bm)
	        });
	      }
	      bi = d3_interpolate_numberB.lastIndex;
	    }
	    if (bi < b.length) {
	      bs = b.slice(bi);
	      if (s[i]) s[i] += bs; else s[++i] = bs;
	    }
	    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
	      return b(t) + "";
	    }) : function() {
	      return b;
	    } : (b = q.length, function(t) {
	      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    });
	  }
	  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
	  d3.interpolate = d3_interpolate;
	  function d3_interpolate(a, b) {
	    var i = d3.interpolators.length, f;
	    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
	    return f;
	  }
	  d3.interpolators = [ function(a, b) {
	    var t = typeof b;
	    return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
	  } ];
	  d3.interpolateArray = d3_interpolateArray;
	  function d3_interpolateArray(a, b) {
	    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
	    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
	    for (;i < na; ++i) c[i] = a[i];
	    for (;i < nb; ++i) c[i] = b[i];
	    return function(t) {
	      for (i = 0; i < n0; ++i) c[i] = x[i](t);
	      return c;
	    };
	  }
	  var d3_ease_default = function() {
	    return d3_identity;
	  };
	  var d3_ease = d3.map({
	    linear: d3_ease_default,
	    poly: d3_ease_poly,
	    quad: function() {
	      return d3_ease_quad;
	    },
	    cubic: function() {
	      return d3_ease_cubic;
	    },
	    sin: function() {
	      return d3_ease_sin;
	    },
	    exp: function() {
	      return d3_ease_exp;
	    },
	    circle: function() {
	      return d3_ease_circle;
	    },
	    elastic: d3_ease_elastic,
	    back: d3_ease_back,
	    bounce: function() {
	      return d3_ease_bounce;
	    }
	  });
	  var d3_ease_mode = d3.map({
	    "in": d3_identity,
	    out: d3_ease_reverse,
	    "in-out": d3_ease_reflect,
	    "out-in": function(f) {
	      return d3_ease_reflect(d3_ease_reverse(f));
	    }
	  });
	  d3.ease = function(name) {
	    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
	    t = d3_ease.get(t) || d3_ease_default;
	    m = d3_ease_mode.get(m) || d3_identity;
	    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
	  };
	  function d3_ease_clamp(f) {
	    return function(t) {
	      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
	    };
	  }
	  function d3_ease_reverse(f) {
	    return function(t) {
	      return 1 - f(1 - t);
	    };
	  }
	  function d3_ease_reflect(f) {
	    return function(t) {
	      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
	    };
	  }
	  function d3_ease_quad(t) {
	    return t * t;
	  }
	  function d3_ease_cubic(t) {
	    return t * t * t;
	  }
	  function d3_ease_cubicInOut(t) {
	    if (t <= 0) return 0;
	    if (t >= 1) return 1;
	    var t2 = t * t, t3 = t2 * t;
	    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
	  }
	  function d3_ease_poly(e) {
	    return function(t) {
	      return Math.pow(t, e);
	    };
	  }
	  function d3_ease_sin(t) {
	    return 1 - Math.cos(t * halfπ);
	  }
	  function d3_ease_exp(t) {
	    return Math.pow(2, 10 * (t - 1));
	  }
	  function d3_ease_circle(t) {
	    return 1 - Math.sqrt(1 - t * t);
	  }
	  function d3_ease_elastic(a, p) {
	    var s;
	    if (arguments.length < 2) p = .45;
	    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
	    return function(t) {
	      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
	    };
	  }
	  function d3_ease_back(s) {
	    if (!s) s = 1.70158;
	    return function(t) {
	      return t * t * ((s + 1) * t - s);
	    };
	  }
	  function d3_ease_bounce(t) {
	    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
	  }
	  d3.interpolateHcl = d3_interpolateHcl;
	  function d3_interpolateHcl(a, b) {
	    a = d3.hcl(a);
	    b = d3.hcl(b);
	    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
	    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateHsl = d3_interpolateHsl;
	  function d3_interpolateHsl(a, b) {
	    a = d3.hsl(a);
	    b = d3.hsl(b);
	    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
	    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
	    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
	    return function(t) {
	      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
	    };
	  }
	  d3.interpolateLab = d3_interpolateLab;
	  function d3_interpolateLab(a, b) {
	    a = d3.lab(a);
	    b = d3.lab(b);
	    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
	    return function(t) {
	      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
	    };
	  }
	  d3.interpolateRound = d3_interpolateRound;
	  function d3_interpolateRound(a, b) {
	    b -= a;
	    return function(t) {
	      return Math.round(a + b * t);
	    };
	  }
	  d3.transform = function(string) {
	    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
	    return (d3.transform = function(string) {
	      if (string != null) {
	        g.setAttribute("transform", string);
	        var t = g.transform.baseVal.consolidate();
	      }
	      return new d3_transform(t ? t.matrix : d3_transformIdentity);
	    })(string);
	  };
	  function d3_transform(m) {
	    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
	    if (r0[0] * r1[1] < r1[0] * r0[1]) {
	      r0[0] *= -1;
	      r0[1] *= -1;
	      kx *= -1;
	      kz *= -1;
	    }
	    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
	    this.translate = [ m.e, m.f ];
	    this.scale = [ kx, ky ];
	    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
	  }
	  d3_transform.prototype.toString = function() {
	    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
	  };
	  function d3_transformDot(a, b) {
	    return a[0] * b[0] + a[1] * b[1];
	  }
	  function d3_transformNormalize(a) {
	    var k = Math.sqrt(d3_transformDot(a, a));
	    if (k) {
	      a[0] /= k;
	      a[1] /= k;
	    }
	    return k;
	  }
	  function d3_transformCombine(a, b, k) {
	    a[0] += k * b[0];
	    a[1] += k * b[1];
	    return a;
	  }
	  var d3_transformIdentity = {
	    a: 1,
	    b: 0,
	    c: 0,
	    d: 1,
	    e: 0,
	    f: 0
	  };
	  d3.interpolateTransform = d3_interpolateTransform;
	  function d3_interpolateTransform(a, b) {
	    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
	    if (ta[0] != tb[0] || ta[1] != tb[1]) {
	      s.push("translate(", null, ",", null, ")");
	      q.push({
	        i: 1,
	        x: d3_interpolateNumber(ta[0], tb[0])
	      }, {
	        i: 3,
	        x: d3_interpolateNumber(ta[1], tb[1])
	      });
	    } else if (tb[0] || tb[1]) {
	      s.push("translate(" + tb + ")");
	    } else {
	      s.push("");
	    }
	    if (ra != rb) {
	      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
	      q.push({
	        i: s.push(s.pop() + "rotate(", null, ")") - 2,
	        x: d3_interpolateNumber(ra, rb)
	      });
	    } else if (rb) {
	      s.push(s.pop() + "rotate(" + rb + ")");
	    }
	    if (wa != wb) {
	      q.push({
	        i: s.push(s.pop() + "skewX(", null, ")") - 2,
	        x: d3_interpolateNumber(wa, wb)
	      });
	    } else if (wb) {
	      s.push(s.pop() + "skewX(" + wb + ")");
	    }
	    if (ka[0] != kb[0] || ka[1] != kb[1]) {
	      n = s.push(s.pop() + "scale(", null, ",", null, ")");
	      q.push({
	        i: n - 4,
	        x: d3_interpolateNumber(ka[0], kb[0])
	      }, {
	        i: n - 2,
	        x: d3_interpolateNumber(ka[1], kb[1])
	      });
	    } else if (kb[0] != 1 || kb[1] != 1) {
	      s.push(s.pop() + "scale(" + kb + ")");
	    }
	    n = q.length;
	    return function(t) {
	      var i = -1, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  }
	  function d3_uninterpolateNumber(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return (x - a) / b;
	    };
	  }
	  function d3_uninterpolateClamp(a, b) {
	    b = (b -= a = +a) || 1 / b;
	    return function(x) {
	      return Math.max(0, Math.min(1, (x - a) / b));
	    };
	  }
	  d3.layout = {};
	  d3.layout.bundle = function() {
	    return function(links) {
	      var paths = [], i = -1, n = links.length;
	      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
	      return paths;
	    };
	  };
	  function d3_layout_bundlePath(link) {
	    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
	    while (start !== lca) {
	      start = start.parent;
	      points.push(start);
	    }
	    var k = points.length;
	    while (end !== lca) {
	      points.splice(k, 0, end);
	      end = end.parent;
	    }
	    return points;
	  }
	  function d3_layout_bundleAncestors(node) {
	    var ancestors = [], parent = node.parent;
	    while (parent != null) {
	      ancestors.push(node);
	      node = parent;
	      parent = parent.parent;
	    }
	    ancestors.push(node);
	    return ancestors;
	  }
	  function d3_layout_bundleLeastCommonAncestor(a, b) {
	    if (a === b) return a;
	    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
	    while (aNode === bNode) {
	      sharedNode = aNode;
	      aNode = aNodes.pop();
	      bNode = bNodes.pop();
	    }
	    return sharedNode;
	  }
	  d3.layout.chord = function() {
	    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
	    function relayout() {
	      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
	      chords = [];
	      groups = [];
	      k = 0, i = -1;
	      while (++i < n) {
	        x = 0, j = -1;
	        while (++j < n) {
	          x += matrix[i][j];
	        }
	        groupSums.push(x);
	        subgroupIndex.push(d3.range(n));
	        k += x;
	      }
	      if (sortGroups) {
	        groupIndex.sort(function(a, b) {
	          return sortGroups(groupSums[a], groupSums[b]);
	        });
	      }
	      if (sortSubgroups) {
	        subgroupIndex.forEach(function(d, i) {
	          d.sort(function(a, b) {
	            return sortSubgroups(matrix[i][a], matrix[i][b]);
	          });
	        });
	      }
	      k = (τ - padding * n) / k;
	      x = 0, i = -1;
	      while (++i < n) {
	        x0 = x, j = -1;
	        while (++j < n) {
	          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
	          subgroups[di + "-" + dj] = {
	            index: di,
	            subindex: dj,
	            startAngle: a0,
	            endAngle: a1,
	            value: v
	          };
	        }
	        groups[di] = {
	          index: di,
	          startAngle: x0,
	          endAngle: x,
	          value: (x - x0) / k
	        };
	        x += padding;
	      }
	      i = -1;
	      while (++i < n) {
	        j = i - 1;
	        while (++j < n) {
	          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
	          if (source.value || target.value) {
	            chords.push(source.value < target.value ? {
	              source: target,
	              target: source
	            } : {
	              source: source,
	              target: target
	            });
	          }
	        }
	      }
	      if (sortChords) resort();
	    }
	    function resort() {
	      chords.sort(function(a, b) {
	        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
	      });
	    }
	    chord.matrix = function(x) {
	      if (!arguments.length) return matrix;
	      n = (matrix = x) && matrix.length;
	      chords = groups = null;
	      return chord;
	    };
	    chord.padding = function(x) {
	      if (!arguments.length) return padding;
	      padding = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortGroups = function(x) {
	      if (!arguments.length) return sortGroups;
	      sortGroups = x;
	      chords = groups = null;
	      return chord;
	    };
	    chord.sortSubgroups = function(x) {
	      if (!arguments.length) return sortSubgroups;
	      sortSubgroups = x;
	      chords = null;
	      return chord;
	    };
	    chord.sortChords = function(x) {
	      if (!arguments.length) return sortChords;
	      sortChords = x;
	      if (chords) resort();
	      return chord;
	    };
	    chord.chords = function() {
	      if (!chords) relayout();
	      return chords;
	    };
	    chord.groups = function() {
	      if (!groups) relayout();
	      return groups;
	    };
	    return chord;
	  };
	  d3.layout.force = function() {
	    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
	    function repulse(node) {
	      return function(quad, x1, _, x2) {
	        if (quad.point !== node) {
	          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
	          if (dw * dw / theta2 < dn) {
	            if (dn < chargeDistance2) {
	              var k = quad.charge / dn;
	              node.px -= dx * k;
	              node.py -= dy * k;
	            }
	            return true;
	          }
	          if (quad.point && dn && dn < chargeDistance2) {
	            var k = quad.pointCharge / dn;
	            node.px -= dx * k;
	            node.py -= dy * k;
	          }
	        }
	        return !quad.charge;
	      };
	    }
	    force.tick = function() {
	      if ((alpha *= .99) < .005) {
	        event.end({
	          type: "end",
	          alpha: alpha = 0
	        });
	        return true;
	      }
	      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        s = o.source;
	        t = o.target;
	        x = t.x - s.x;
	        y = t.y - s.y;
	        if (l = x * x + y * y) {
	          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
	          x *= l;
	          y *= l;
	          t.x -= x * (k = s.weight / (t.weight + s.weight));
	          t.y -= y * k;
	          s.x += x * (k = 1 - k);
	          s.y += y * k;
	        }
	      }
	      if (k = alpha * gravity) {
	        x = size[0] / 2;
	        y = size[1] / 2;
	        i = -1;
	        if (k) while (++i < n) {
	          o = nodes[i];
	          o.x += (x - o.x) * k;
	          o.y += (y - o.y) * k;
	        }
	      }
	      if (charge) {
	        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
	        i = -1;
	        while (++i < n) {
	          if (!(o = nodes[i]).fixed) {
	            q.visit(repulse(o));
	          }
	        }
	      }
	      i = -1;
	      while (++i < n) {
	        o = nodes[i];
	        if (o.fixed) {
	          o.x = o.px;
	          o.y = o.py;
	        } else {
	          o.x -= (o.px - (o.px = o.x)) * friction;
	          o.y -= (o.py - (o.py = o.y)) * friction;
	        }
	      }
	      event.tick({
	        type: "tick",
	        alpha: alpha
	      });
	    };
	    force.nodes = function(x) {
	      if (!arguments.length) return nodes;
	      nodes = x;
	      return force;
	    };
	    force.links = function(x) {
	      if (!arguments.length) return links;
	      links = x;
	      return force;
	    };
	    force.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return force;
	    };
	    force.linkDistance = function(x) {
	      if (!arguments.length) return linkDistance;
	      linkDistance = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.distance = force.linkDistance;
	    force.linkStrength = function(x) {
	      if (!arguments.length) return linkStrength;
	      linkStrength = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.friction = function(x) {
	      if (!arguments.length) return friction;
	      friction = +x;
	      return force;
	    };
	    force.charge = function(x) {
	      if (!arguments.length) return charge;
	      charge = typeof x === "function" ? x : +x;
	      return force;
	    };
	    force.chargeDistance = function(x) {
	      if (!arguments.length) return Math.sqrt(chargeDistance2);
	      chargeDistance2 = x * x;
	      return force;
	    };
	    force.gravity = function(x) {
	      if (!arguments.length) return gravity;
	      gravity = +x;
	      return force;
	    };
	    force.theta = function(x) {
	      if (!arguments.length) return Math.sqrt(theta2);
	      theta2 = x * x;
	      return force;
	    };
	    force.alpha = function(x) {
	      if (!arguments.length) return alpha;
	      x = +x;
	      if (alpha) {
	        if (x > 0) alpha = x; else alpha = 0;
	      } else if (x > 0) {
	        event.start({
	          type: "start",
	          alpha: alpha = x
	        });
	        d3.timer(force.tick);
	      }
	      return force;
	    };
	    force.start = function() {
	      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
	      for (i = 0; i < n; ++i) {
	        (o = nodes[i]).index = i;
	        o.weight = 0;
	      }
	      for (i = 0; i < m; ++i) {
	        o = links[i];
	        if (typeof o.source == "number") o.source = nodes[o.source];
	        if (typeof o.target == "number") o.target = nodes[o.target];
	        ++o.source.weight;
	        ++o.target.weight;
	      }
	      for (i = 0; i < n; ++i) {
	        o = nodes[i];
	        if (isNaN(o.x)) o.x = position("x", w);
	        if (isNaN(o.y)) o.y = position("y", h);
	        if (isNaN(o.px)) o.px = o.x;
	        if (isNaN(o.py)) o.py = o.y;
	      }
	      distances = [];
	      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
	      strengths = [];
	      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
	      charges = [];
	      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
	      function position(dimension, size) {
	        if (!neighbors) {
	          neighbors = new Array(n);
	          for (j = 0; j < n; ++j) {
	            neighbors[j] = [];
	          }
	          for (j = 0; j < m; ++j) {
	            var o = links[j];
	            neighbors[o.source.index].push(o.target);
	            neighbors[o.target.index].push(o.source);
	          }
	        }
	        var candidates = neighbors[i], j = -1, l = candidates.length, x;
	        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
	        return Math.random() * size;
	      }
	      return force.resume();
	    };
	    force.resume = function() {
	      return force.alpha(.1);
	    };
	    force.stop = function() {
	      return force.alpha(0);
	    };
	    force.drag = function() {
	      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
	      if (!arguments.length) return drag;
	      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
	    };
	    function dragmove(d) {
	      d.px = d3.event.x, d.py = d3.event.y;
	      force.resume();
	    }
	    return d3.rebind(force, event, "on");
	  };
	  function d3_layout_forceDragstart(d) {
	    d.fixed |= 2;
	  }
	  function d3_layout_forceDragend(d) {
	    d.fixed &= ~6;
	  }
	  function d3_layout_forceMouseover(d) {
	    d.fixed |= 4;
	    d.px = d.x, d.py = d.y;
	  }
	  function d3_layout_forceMouseout(d) {
	    d.fixed &= ~4;
	  }
	  function d3_layout_forceAccumulate(quad, alpha, charges) {
	    var cx = 0, cy = 0;
	    quad.charge = 0;
	    if (!quad.leaf) {
	      var nodes = quad.nodes, n = nodes.length, i = -1, c;
	      while (++i < n) {
	        c = nodes[i];
	        if (c == null) continue;
	        d3_layout_forceAccumulate(c, alpha, charges);
	        quad.charge += c.charge;
	        cx += c.charge * c.cx;
	        cy += c.charge * c.cy;
	      }
	    }
	    if (quad.point) {
	      if (!quad.leaf) {
	        quad.point.x += Math.random() - .5;
	        quad.point.y += Math.random() - .5;
	      }
	      var k = alpha * charges[quad.point.index];
	      quad.charge += quad.pointCharge = k;
	      cx += k * quad.point.x;
	      cy += k * quad.point.y;
	    }
	    quad.cx = cx / quad.charge;
	    quad.cy = cy / quad.charge;
	  }
	  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
	  d3.layout.hierarchy = function() {
	    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
	    function hierarchy(root) {
	      var stack = [ root ], nodes = [], node;
	      root.depth = 0;
	      while ((node = stack.pop()) != null) {
	        nodes.push(node);
	        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
	          var n, childs, child;
	          while (--n >= 0) {
	            stack.push(child = childs[n]);
	            child.parent = node;
	            child.depth = node.depth + 1;
	          }
	          if (value) node.value = 0;
	          node.children = childs;
	        } else {
	          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          delete node.children;
	        }
	      }
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var childs, parent;
	        if (sort && (childs = node.children)) childs.sort(sort);
	        if (value && (parent = node.parent)) parent.value += node.value;
	      });
	      return nodes;
	    }
	    hierarchy.sort = function(x) {
	      if (!arguments.length) return sort;
	      sort = x;
	      return hierarchy;
	    };
	    hierarchy.children = function(x) {
	      if (!arguments.length) return children;
	      children = x;
	      return hierarchy;
	    };
	    hierarchy.value = function(x) {
	      if (!arguments.length) return value;
	      value = x;
	      return hierarchy;
	    };
	    hierarchy.revalue = function(root) {
	      if (value) {
	        d3_layout_hierarchyVisitBefore(root, function(node) {
	          if (node.children) node.value = 0;
	        });
	        d3_layout_hierarchyVisitAfter(root, function(node) {
	          var parent;
	          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
	          if (parent = node.parent) parent.value += node.value;
	        });
	      }
	      return root;
	    };
	    return hierarchy;
	  };
	  function d3_layout_hierarchyRebind(object, hierarchy) {
	    d3.rebind(object, hierarchy, "sort", "children", "value");
	    object.nodes = object;
	    object.links = d3_layout_hierarchyLinks;
	    return object;
	  }
	  function d3_layout_hierarchyVisitBefore(node, callback) {
	    var nodes = [ node ];
	    while ((node = nodes.pop()) != null) {
	      callback(node);
	      if ((children = node.children) && (n = children.length)) {
	        var n, children;
	        while (--n >= 0) nodes.push(children[n]);
	      }
	    }
	  }
	  function d3_layout_hierarchyVisitAfter(node, callback) {
	    var nodes = [ node ], nodes2 = [];
	    while ((node = nodes.pop()) != null) {
	      nodes2.push(node);
	      if ((children = node.children) && (n = children.length)) {
	        var i = -1, n, children;
	        while (++i < n) nodes.push(children[i]);
	      }
	    }
	    while ((node = nodes2.pop()) != null) {
	      callback(node);
	    }
	  }
	  function d3_layout_hierarchyChildren(d) {
	    return d.children;
	  }
	  function d3_layout_hierarchyValue(d) {
	    return d.value;
	  }
	  function d3_layout_hierarchySort(a, b) {
	    return b.value - a.value;
	  }
	  function d3_layout_hierarchyLinks(nodes) {
	    return d3.merge(nodes.map(function(parent) {
	      return (parent.children || []).map(function(child) {
	        return {
	          source: parent,
	          target: child
	        };
	      });
	    }));
	  }
	  d3.layout.partition = function() {
	    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
	    function position(node, x, dx, dy) {
	      var children = node.children;
	      node.x = x;
	      node.y = node.depth * dy;
	      node.dx = dx;
	      node.dy = dy;
	      if (children && (n = children.length)) {
	        var i = -1, n, c, d;
	        dx = node.value ? dx / node.value : 0;
	        while (++i < n) {
	          position(c = children[i], x, d = c.value * dx, dy);
	          x += d;
	        }
	      }
	    }
	    function depth(node) {
	      var children = node.children, d = 0;
	      if (children && (n = children.length)) {
	        var i = -1, n;
	        while (++i < n) d = Math.max(d, depth(children[i]));
	      }
	      return 1 + d;
	    }
	    function partition(d, i) {
	      var nodes = hierarchy.call(this, d, i);
	      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
	      return nodes;
	    }
	    partition.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return partition;
	    };
	    return d3_layout_hierarchyRebind(partition, hierarchy);
	  };
	  d3.layout.pie = function() {
	    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
	    function pie(data) {
	      var n = data.length, values = data.map(function(d, i) {
	        return +value.call(pie, d, i);
	      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
	      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
	        return values[j] - values[i];
	      } : function(i, j) {
	        return sort(data[i], data[j]);
	      });
	      index.forEach(function(i) {
	        arcs[i] = {
	          data: data[i],
	          value: v = values[i],
	          startAngle: a,
	          endAngle: a += v * k + pa,
	          padAngle: p
	        };
	      });
	      return arcs;
	    }
	    pie.value = function(_) {
	      if (!arguments.length) return value;
	      value = _;
	      return pie;
	    };
	    pie.sort = function(_) {
	      if (!arguments.length) return sort;
	      sort = _;
	      return pie;
	    };
	    pie.startAngle = function(_) {
	      if (!arguments.length) return startAngle;
	      startAngle = _;
	      return pie;
	    };
	    pie.endAngle = function(_) {
	      if (!arguments.length) return endAngle;
	      endAngle = _;
	      return pie;
	    };
	    pie.padAngle = function(_) {
	      if (!arguments.length) return padAngle;
	      padAngle = _;
	      return pie;
	    };
	    return pie;
	  };
	  var d3_layout_pieSortByValue = {};
	  d3.layout.stack = function() {
	    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
	    function stack(data, index) {
	      if (!(n = data.length)) return data;
	      var series = data.map(function(d, i) {
	        return values.call(stack, d, i);
	      });
	      var points = series.map(function(d) {
	        return d.map(function(v, i) {
	          return [ x.call(stack, v, i), y.call(stack, v, i) ];
	        });
	      });
	      var orders = order.call(stack, points, index);
	      series = d3.permute(series, orders);
	      points = d3.permute(points, orders);
	      var offsets = offset.call(stack, points, index);
	      var m = series[0].length, n, i, j, o;
	      for (j = 0; j < m; ++j) {
	        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
	        for (i = 1; i < n; ++i) {
	          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
	        }
	      }
	      return data;
	    }
	    stack.values = function(x) {
	      if (!arguments.length) return values;
	      values = x;
	      return stack;
	    };
	    stack.order = function(x) {
	      if (!arguments.length) return order;
	      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
	      return stack;
	    };
	    stack.offset = function(x) {
	      if (!arguments.length) return offset;
	      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
	      return stack;
	    };
	    stack.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      return stack;
	    };
	    stack.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      return stack;
	    };
	    stack.out = function(z) {
	      if (!arguments.length) return out;
	      out = z;
	      return stack;
	    };
	    return stack;
	  };
	  function d3_layout_stackX(d) {
	    return d.x;
	  }
	  function d3_layout_stackY(d) {
	    return d.y;
	  }
	  function d3_layout_stackOut(d, y0, y) {
	    d.y0 = y0;
	    d.y = y;
	  }
	  var d3_layout_stackOrders = d3.map({
	    "inside-out": function(data) {
	      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
	        return max[a] - max[b];
	      }), top = 0, bottom = 0, tops = [], bottoms = [];
	      for (i = 0; i < n; ++i) {
	        j = index[i];
	        if (top < bottom) {
	          top += sums[j];
	          tops.push(j);
	        } else {
	          bottom += sums[j];
	          bottoms.push(j);
	        }
	      }
	      return bottoms.reverse().concat(tops);
	    },
	    reverse: function(data) {
	      return d3.range(data.length).reverse();
	    },
	    "default": d3_layout_stackOrderDefault
	  });
	  var d3_layout_stackOffsets = d3.map({
	    silhouette: function(data) {
	      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o > max) max = o;
	        sums.push(o);
	      }
	      for (j = 0; j < m; ++j) {
	        y0[j] = (max - sums[j]) / 2;
	      }
	      return y0;
	    },
	    wiggle: function(data) {
	      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
	      y0[0] = o = o0 = 0;
	      for (j = 1; j < m; ++j) {
	        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
	        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
	          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
	            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
	          }
	          s2 += s3 * data[i][j][1];
	        }
	        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
	        if (o < o0) o0 = o;
	      }
	      for (j = 0; j < m; ++j) y0[j] -= o0;
	      return y0;
	    },
	    expand: function(data) {
	      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
	      for (j = 0; j < m; ++j) {
	        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
	        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
	      }
	      for (j = 0; j < m; ++j) y0[j] = 0;
	      return y0;
	    },
	    zero: d3_layout_stackOffsetZero
	  });
	  function d3_layout_stackOrderDefault(data) {
	    return d3.range(data.length);
	  }
	  function d3_layout_stackOffsetZero(data) {
	    var j = -1, m = data[0].length, y0 = [];
	    while (++j < m) y0[j] = 0;
	    return y0;
	  }
	  function d3_layout_stackMaxIndex(array) {
	    var i = 1, j = 0, v = array[0][1], k, n = array.length;
	    for (;i < n; ++i) {
	      if ((k = array[i][1]) > v) {
	        j = i;
	        v = k;
	      }
	    }
	    return j;
	  }
	  function d3_layout_stackReduceSum(d) {
	    return d.reduce(d3_layout_stackSum, 0);
	  }
	  function d3_layout_stackSum(p, d) {
	    return p + d[1];
	  }
	  d3.layout.histogram = function() {
	    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
	    function histogram(data, i) {
	      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
	      while (++i < m) {
	        bin = bins[i] = [];
	        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
	        bin.y = 0;
	      }
	      if (m > 0) {
	        i = -1;
	        while (++i < n) {
	          x = values[i];
	          if (x >= range[0] && x <= range[1]) {
	            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
	            bin.y += k;
	            bin.push(data[i]);
	          }
	        }
	      }
	      return bins;
	    }
	    histogram.value = function(x) {
	      if (!arguments.length) return valuer;
	      valuer = x;
	      return histogram;
	    };
	    histogram.range = function(x) {
	      if (!arguments.length) return ranger;
	      ranger = d3_functor(x);
	      return histogram;
	    };
	    histogram.bins = function(x) {
	      if (!arguments.length) return binner;
	      binner = typeof x === "number" ? function(range) {
	        return d3_layout_histogramBinFixed(range, x);
	      } : d3_functor(x);
	      return histogram;
	    };
	    histogram.frequency = function(x) {
	      if (!arguments.length) return frequency;
	      frequency = !!x;
	      return histogram;
	    };
	    return histogram;
	  };
	  function d3_layout_histogramBinSturges(range, values) {
	    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
	  }
	  function d3_layout_histogramBinFixed(range, n) {
	    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
	    while (++x <= n) f[x] = m * x + b;
	    return f;
	  }
	  function d3_layout_histogramRange(values) {
	    return [ d3.min(values), d3.max(values) ];
	  }
	  d3.layout.pack = function() {
	    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
	    function pack(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
	        return radius;
	      };
	      root.x = root.y = 0;
	      d3_layout_hierarchyVisitAfter(root, function(d) {
	        d.r = +r(d.value);
	      });
	      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	      if (padding) {
	        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r += dr;
	        });
	        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
	        d3_layout_hierarchyVisitAfter(root, function(d) {
	          d.r -= dr;
	        });
	      }
	      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
	      return nodes;
	    }
	    pack.size = function(_) {
	      if (!arguments.length) return size;
	      size = _;
	      return pack;
	    };
	    pack.radius = function(_) {
	      if (!arguments.length) return radius;
	      radius = _ == null || typeof _ === "function" ? _ : +_;
	      return pack;
	    };
	    pack.padding = function(_) {
	      if (!arguments.length) return padding;
	      padding = +_;
	      return pack;
	    };
	    return d3_layout_hierarchyRebind(pack, hierarchy);
	  };
	  function d3_layout_packSort(a, b) {
	    return a.value - b.value;
	  }
	  function d3_layout_packInsert(a, b) {
	    var c = a._pack_next;
	    a._pack_next = b;
	    b._pack_prev = a;
	    b._pack_next = c;
	    c._pack_prev = b;
	  }
	  function d3_layout_packSplice(a, b) {
	    a._pack_next = b;
	    b._pack_prev = a;
	  }
	  function d3_layout_packIntersects(a, b) {
	    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
	    return .999 * dr * dr > dx * dx + dy * dy;
	  }
	  function d3_layout_packSiblings(node) {
	    if (!(nodes = node.children) || !(n = nodes.length)) return;
	    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
	    function bound(node) {
	      xMin = Math.min(node.x - node.r, xMin);
	      xMax = Math.max(node.x + node.r, xMax);
	      yMin = Math.min(node.y - node.r, yMin);
	      yMax = Math.max(node.y + node.r, yMax);
	    }
	    nodes.forEach(d3_layout_packLink);
	    a = nodes[0];
	    a.x = -a.r;
	    a.y = 0;
	    bound(a);
	    if (n > 1) {
	      b = nodes[1];
	      b.x = b.r;
	      b.y = 0;
	      bound(b);
	      if (n > 2) {
	        c = nodes[2];
	        d3_layout_packPlace(a, b, c);
	        bound(c);
	        d3_layout_packInsert(a, c);
	        a._pack_prev = c;
	        d3_layout_packInsert(c, b);
	        b = a._pack_next;
	        for (i = 3; i < n; i++) {
	          d3_layout_packPlace(a, b, c = nodes[i]);
	          var isect = 0, s1 = 1, s2 = 1;
	          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
	            if (d3_layout_packIntersects(j, c)) {
	              isect = 1;
	              break;
	            }
	          }
	          if (isect == 1) {
	            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
	              if (d3_layout_packIntersects(k, c)) {
	                break;
	              }
	            }
	          }
	          if (isect) {
	            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
	            i--;
	          } else {
	            d3_layout_packInsert(a, c);
	            b = c;
	            bound(c);
	          }
	        }
	      }
	    }
	    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
	    for (i = 0; i < n; i++) {
	      c = nodes[i];
	      c.x -= cx;
	      c.y -= cy;
	      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
	    }
	    node.r = cr;
	    nodes.forEach(d3_layout_packUnlink);
	  }
	  function d3_layout_packLink(node) {
	    node._pack_next = node._pack_prev = node;
	  }
	  function d3_layout_packUnlink(node) {
	    delete node._pack_next;
	    delete node._pack_prev;
	  }
	  function d3_layout_packTransform(node, x, y, k) {
	    var children = node.children;
	    node.x = x += k * node.x;
	    node.y = y += k * node.y;
	    node.r *= k;
	    if (children) {
	      var i = -1, n = children.length;
	      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
	    }
	  }
	  function d3_layout_packPlace(a, b, c) {
	    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
	    if (db && (dx || dy)) {
	      var da = b.r + c.r, dc = dx * dx + dy * dy;
	      da *= da;
	      db *= db;
	      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
	      c.x = a.x + x * dx + y * dy;
	      c.y = a.y + x * dy - y * dx;
	    } else {
	      c.x = a.x + db;
	      c.y = a.y;
	    }
	  }
	  d3.layout.tree = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
	    function tree(d, i) {
	      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
	      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
	      d3_layout_hierarchyVisitBefore(root1, secondWalk);
	      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
	        var left = root0, right = root0, bottom = root0;
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          if (node.x < left.x) left = node;
	          if (node.x > right.x) right = node;
	          if (node.depth > bottom.depth) bottom = node;
	        });
	        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
	        d3_layout_hierarchyVisitBefore(root0, function(node) {
	          node.x = (node.x + tx) * kx;
	          node.y = node.depth * ky;
	        });
	      }
	      return nodes;
	    }
	    function wrapTree(root0) {
	      var root1 = {
	        A: null,
	        children: [ root0 ]
	      }, queue = [ root1 ], node1;
	      while ((node1 = queue.pop()) != null) {
	        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
	          queue.push((children[i] = child = {
	            _: children[i],
	            parent: node1,
	            children: (child = children[i].children) && child.slice() || [],
	            A: null,
	            a: null,
	            z: 0,
	            m: 0,
	            c: 0,
	            s: 0,
	            t: null,
	            i: i
	          }).a = child);
	        }
	      }
	      return root1.children[0];
	    }
	    function firstWalk(v) {
	      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
	      if (children.length) {
	        d3_layout_treeShift(v);
	        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	        if (w) {
	          v.z = w.z + separation(v._, w._);
	          v.m = v.z - midpoint;
	        } else {
	          v.z = midpoint;
	        }
	      } else if (w) {
	        v.z = w.z + separation(v._, w._);
	      }
	      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	    }
	    function secondWalk(v) {
	      v._.x = v.z + v.parent.m;
	      v.m += v.parent.m;
	    }
	    function apportion(v, w, ancestor) {
	      if (w) {
	        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
	        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
	          vom = d3_layout_treeLeft(vom);
	          vop = d3_layout_treeRight(vop);
	          vop.a = v;
	          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	          if (shift > 0) {
	            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
	            sip += shift;
	            sop += shift;
	          }
	          sim += vim.m;
	          sip += vip.m;
	          som += vom.m;
	          sop += vop.m;
	        }
	        if (vim && !d3_layout_treeRight(vop)) {
	          vop.t = vim;
	          vop.m += sim - sop;
	        }
	        if (vip && !d3_layout_treeLeft(vom)) {
	          vom.t = vip;
	          vom.m += sip - som;
	          ancestor = v;
	        }
	      }
	      return ancestor;
	    }
	    function sizeNode(node) {
	      node.x *= size[0];
	      node.y = node.depth * size[1];
	    }
	    tree.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return tree;
	    };
	    tree.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null ? sizeNode : null;
	      return tree;
	    };
	    tree.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) == null ? null : sizeNode;
	      return tree;
	    };
	    return d3_layout_hierarchyRebind(tree, hierarchy);
	  };
	  function d3_layout_treeSeparation(a, b) {
	    return a.parent == b.parent ? 1 : 2;
	  }
	  function d3_layout_treeLeft(v) {
	    var children = v.children;
	    return children.length ? children[0] : v.t;
	  }
	  function d3_layout_treeRight(v) {
	    var children = v.children, n;
	    return (n = children.length) ? children[n - 1] : v.t;
	  }
	  function d3_layout_treeMove(wm, wp, shift) {
	    var change = shift / (wp.i - wm.i);
	    wp.c -= change;
	    wp.s += shift;
	    wm.c += change;
	    wp.z += shift;
	    wp.m += shift;
	  }
	  function d3_layout_treeShift(v) {
	    var shift = 0, change = 0, children = v.children, i = children.length, w;
	    while (--i >= 0) {
	      w = children[i];
	      w.z += shift;
	      w.m += shift;
	      shift += w.s + (change += w.c);
	    }
	  }
	  function d3_layout_treeAncestor(vim, v, ancestor) {
	    return vim.a.parent === v.parent ? vim.a : ancestor;
	  }
	  d3.layout.cluster = function() {
	    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
	    function cluster(d, i) {
	      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
	      d3_layout_hierarchyVisitAfter(root, function(node) {
	        var children = node.children;
	        if (children && children.length) {
	          node.x = d3_layout_clusterX(children);
	          node.y = d3_layout_clusterY(children);
	        } else {
	          node.x = previousNode ? x += separation(node, previousNode) : 0;
	          node.y = 0;
	          previousNode = node;
	        }
	      });
	      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
	      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
	        node.x = (node.x - root.x) * size[0];
	        node.y = (root.y - node.y) * size[1];
	      } : function(node) {
	        node.x = (node.x - x0) / (x1 - x0) * size[0];
	        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
	      });
	      return nodes;
	    }
	    cluster.separation = function(x) {
	      if (!arguments.length) return separation;
	      separation = x;
	      return cluster;
	    };
	    cluster.size = function(x) {
	      if (!arguments.length) return nodeSize ? null : size;
	      nodeSize = (size = x) == null;
	      return cluster;
	    };
	    cluster.nodeSize = function(x) {
	      if (!arguments.length) return nodeSize ? size : null;
	      nodeSize = (size = x) != null;
	      return cluster;
	    };
	    return d3_layout_hierarchyRebind(cluster, hierarchy);
	  };
	  function d3_layout_clusterY(children) {
	    return 1 + d3.max(children, function(child) {
	      return child.y;
	    });
	  }
	  function d3_layout_clusterX(children) {
	    return children.reduce(function(x, child) {
	      return x + child.x;
	    }, 0) / children.length;
	  }
	  function d3_layout_clusterLeft(node) {
	    var children = node.children;
	    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
	  }
	  function d3_layout_clusterRight(node) {
	    var children = node.children, n;
	    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
	  }
	  d3.layout.treemap = function() {
	    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
	    function scale(children, k) {
	      var i = -1, n = children.length, child, area;
	      while (++i < n) {
	        area = (child = children[i]).value * (k < 0 ? 0 : k);
	        child.area = isNaN(area) || area <= 0 ? 0 : area;
	      }
	    }
	    function squarify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while ((n = remaining.length) > 0) {
	          row.push(child = remaining[n - 1]);
	          row.area += child.area;
	          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
	            remaining.pop();
	            best = score;
	          } else {
	            row.area -= row.pop().area;
	            position(row, u, rect, false);
	            u = Math.min(rect.dx, rect.dy);
	            row.length = row.area = 0;
	            best = Infinity;
	          }
	        }
	        if (row.length) {
	          position(row, u, rect, true);
	          row.length = row.area = 0;
	        }
	        children.forEach(squarify);
	      }
	    }
	    function stickify(node) {
	      var children = node.children;
	      if (children && children.length) {
	        var rect = pad(node), remaining = children.slice(), child, row = [];
	        scale(remaining, rect.dx * rect.dy / node.value);
	        row.area = 0;
	        while (child = remaining.pop()) {
	          row.push(child);
	          row.area += child.area;
	          if (child.z != null) {
	            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
	            row.length = row.area = 0;
	          }
	        }
	        children.forEach(stickify);
	      }
	    }
	    function worst(row, u) {
	      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
	      while (++i < n) {
	        if (!(r = row[i].area)) continue;
	        if (r < rmin) rmin = r;
	        if (r > rmax) rmax = r;
	      }
	      s *= s;
	      u *= u;
	      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
	    }
	    function position(row, u, rect, flush) {
	      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
	      if (u == rect.dx) {
	        if (flush || v > rect.dy) v = rect.dy;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dy = v;
	          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
	        }
	        o.z = true;
	        o.dx += rect.x + rect.dx - x;
	        rect.y += v;
	        rect.dy -= v;
	      } else {
	        if (flush || v > rect.dx) v = rect.dx;
	        while (++i < n) {
	          o = row[i];
	          o.x = x;
	          o.y = y;
	          o.dx = v;
	          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
	        }
	        o.z = false;
	        o.dy += rect.y + rect.dy - y;
	        rect.x += v;
	        rect.dx -= v;
	      }
	    }
	    function treemap(d) {
	      var nodes = stickies || hierarchy(d), root = nodes[0];
	      root.x = 0;
	      root.y = 0;
	      root.dx = size[0];
	      root.dy = size[1];
	      if (stickies) hierarchy.revalue(root);
	      scale([ root ], root.dx * root.dy / root.value);
	      (stickies ? stickify : squarify)(root);
	      if (sticky) stickies = nodes;
	      return nodes;
	    }
	    treemap.size = function(x) {
	      if (!arguments.length) return size;
	      size = x;
	      return treemap;
	    };
	    treemap.padding = function(x) {
	      if (!arguments.length) return padding;
	      function padFunction(node) {
	        var p = x.call(treemap, node, node.depth);
	        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
	      }
	      function padConstant(node) {
	        return d3_layout_treemapPad(node, x);
	      }
	      var type;
	      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
	      padConstant) : padConstant;
	      return treemap;
	    };
	    treemap.round = function(x) {
	      if (!arguments.length) return round != Number;
	      round = x ? Math.round : Number;
	      return treemap;
	    };
	    treemap.sticky = function(x) {
	      if (!arguments.length) return sticky;
	      sticky = x;
	      stickies = null;
	      return treemap;
	    };
	    treemap.ratio = function(x) {
	      if (!arguments.length) return ratio;
	      ratio = x;
	      return treemap;
	    };
	    treemap.mode = function(x) {
	      if (!arguments.length) return mode;
	      mode = x + "";
	      return treemap;
	    };
	    return d3_layout_hierarchyRebind(treemap, hierarchy);
	  };
	  function d3_layout_treemapPadNull(node) {
	    return {
	      x: node.x,
	      y: node.y,
	      dx: node.dx,
	      dy: node.dy
	    };
	  }
	  function d3_layout_treemapPad(node, padding) {
	    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
	    if (dx < 0) {
	      x += dx / 2;
	      dx = 0;
	    }
	    if (dy < 0) {
	      y += dy / 2;
	      dy = 0;
	    }
	    return {
	      x: x,
	      y: y,
	      dx: dx,
	      dy: dy
	    };
	  }
	  d3.random = {
	    normal: function(µ, σ) {
	      var n = arguments.length;
	      if (n < 2) σ = 1;
	      if (n < 1) µ = 0;
	      return function() {
	        var x, y, r;
	        do {
	          x = Math.random() * 2 - 1;
	          y = Math.random() * 2 - 1;
	          r = x * x + y * y;
	        } while (!r || r > 1);
	        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
	      };
	    },
	    logNormal: function() {
	      var random = d3.random.normal.apply(d3, arguments);
	      return function() {
	        return Math.exp(random());
	      };
	    },
	    bates: function(m) {
	      var random = d3.random.irwinHall(m);
	      return function() {
	        return random() / m;
	      };
	    },
	    irwinHall: function(m) {
	      return function() {
	        for (var s = 0, j = 0; j < m; j++) s += Math.random();
	        return s;
	      };
	    }
	  };
	  d3.scale = {};
	  function d3_scaleExtent(domain) {
	    var start = domain[0], stop = domain[domain.length - 1];
	    return start < stop ? [ start, stop ] : [ stop, start ];
	  }
	  function d3_scaleRange(scale) {
	    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
	  }
	  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
	    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
	    return function(x) {
	      return i(u(x));
	    };
	  }
	  function d3_scale_nice(domain, nice) {
	    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
	    if (x1 < x0) {
	      dx = i0, i0 = i1, i1 = dx;
	      dx = x0, x0 = x1, x1 = dx;
	    }
	    domain[i0] = nice.floor(x0);
	    domain[i1] = nice.ceil(x1);
	    return domain;
	  }
	  function d3_scale_niceStep(step) {
	    return step ? {
	      floor: function(x) {
	        return Math.floor(x / step) * step;
	      },
	      ceil: function(x) {
	        return Math.ceil(x / step) * step;
	      }
	    } : d3_scale_niceIdentity;
	  }
	  var d3_scale_niceIdentity = {
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
	    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
	    if (domain[k] < domain[0]) {
	      domain = domain.slice().reverse();
	      range = range.slice().reverse();
	    }
	    while (++j <= k) {
	      u.push(uninterpolate(domain[j - 1], domain[j]));
	      i.push(interpolate(range[j - 1], range[j]));
	    }
	    return function(x) {
	      var j = d3.bisect(domain, x, 1, k) - 1;
	      return i[j](u[j](x));
	    };
	  }
	  d3.scale.linear = function() {
	    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
	  };
	  function d3_scale_linear(domain, range, interpolate, clamp) {
	    var output, input;
	    function rescale() {
	      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
	      output = linear(domain, range, uninterpolate, interpolate);
	      input = linear(range, domain, uninterpolate, d3_interpolate);
	      return scale;
	    }
	    function scale(x) {
	      return output(x);
	    }
	    scale.invert = function(y) {
	      return input(y);
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(Number);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.rangeRound = function(x) {
	      return scale.range(x).interpolate(d3_interpolateRound);
	    };
	    scale.clamp = function(x) {
	      if (!arguments.length) return clamp;
	      clamp = x;
	      return rescale();
	    };
	    scale.interpolate = function(x) {
	      if (!arguments.length) return interpolate;
	      interpolate = x;
	      return rescale();
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      d3_scale_linearNice(domain, m);
	      return rescale();
	    };
	    scale.copy = function() {
	      return d3_scale_linear(domain, range, interpolate, clamp);
	    };
	    return rescale();
	  }
	  function d3_scale_linearRebind(scale, linear) {
	    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
	  }
	  function d3_scale_linearNice(domain, m) {
	    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
	  }
	  function d3_scale_linearTickRange(domain, m) {
	    if (m == null) m = 10;
	    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
	    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
	    extent[0] = Math.ceil(extent[0] / step) * step;
	    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
	    extent[2] = step;
	    return extent;
	  }
	  function d3_scale_linearTicks(domain, m) {
	    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
	  }
	  function d3_scale_linearTickFormat(domain, m, format) {
	    var range = d3_scale_linearTickRange(domain, m);
	    if (format) {
	      var match = d3_format_re.exec(format);
	      match.shift();
	      if (match[8] === "s") {
	        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
	        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
	        match[8] = "f";
	        format = d3.format(match.join(""));
	        return function(d) {
	          return format(prefix.scale(d)) + prefix.symbol;
	        };
	      }
	      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
	      format = match.join("");
	    } else {
	      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
	    }
	    return d3.format(format);
	  }
	  var d3_scale_linearFormatSignificant = {
	    s: 1,
	    g: 1,
	    p: 1,
	    r: 1,
	    e: 1
	  };
	  function d3_scale_linearPrecision(value) {
	    return -Math.floor(Math.log(value) / Math.LN10 + .01);
	  }
	  function d3_scale_linearFormatPrecision(type, range) {
	    var p = d3_scale_linearPrecision(range[2]);
	    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
	  }
	  d3.scale.log = function() {
	    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
	  };
	  function d3_scale_log(linear, base, positive, domain) {
	    function log(x) {
	      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
	    }
	    function pow(x) {
	      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
	    }
	    function scale(x) {
	      return linear(log(x));
	    }
	    scale.invert = function(x) {
	      return pow(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      positive = x[0] >= 0;
	      linear.domain((domain = x.map(Number)).map(log));
	      return scale;
	    };
	    scale.base = function(_) {
	      if (!arguments.length) return base;
	      base = +_;
	      linear.domain(domain.map(log));
	      return scale;
	    };
	    scale.nice = function() {
	      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
	      linear.domain(niced);
	      domain = niced.map(pow);
	      return scale;
	    };
	    scale.ticks = function() {
	      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
	      if (isFinite(j - i)) {
	        if (positive) {
	          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
	          ticks.push(pow(i));
	        } else {
	          ticks.push(pow(i));
	          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
	        }
	        for (i = 0; ticks[i] < u; i++) {}
	        for (j = ticks.length; ticks[j - 1] > v; j--) {}
	        ticks = ticks.slice(i, j);
	      }
	      return ticks;
	    };
	    scale.tickFormat = function(n, format) {
	      if (!arguments.length) return d3_scale_logFormat;
	      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
	      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
	      Math.floor), e;
	      return function(d) {
	        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
	      };
	    };
	    scale.copy = function() {
	      return d3_scale_log(linear.copy(), base, positive, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
	    floor: function(x) {
	      return -Math.ceil(-x);
	    },
	    ceil: function(x) {
	      return -Math.floor(-x);
	    }
	  };
	  d3.scale.pow = function() {
	    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
	  };
	  function d3_scale_pow(linear, exponent, domain) {
	    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
	    function scale(x) {
	      return linear(powp(x));
	    }
	    scale.invert = function(x) {
	      return powb(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      linear.domain((domain = x.map(Number)).map(powp));
	      return scale;
	    };
	    scale.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    scale.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    scale.nice = function(m) {
	      return scale.domain(d3_scale_linearNice(domain, m));
	    };
	    scale.exponent = function(x) {
	      if (!arguments.length) return exponent;
	      powp = d3_scale_powPow(exponent = x);
	      powb = d3_scale_powPow(1 / exponent);
	      linear.domain(domain.map(powp));
	      return scale;
	    };
	    scale.copy = function() {
	      return d3_scale_pow(linear.copy(), exponent, domain);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_scale_powPow(e) {
	    return function(x) {
	      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
	    };
	  }
	  d3.scale.sqrt = function() {
	    return d3.scale.pow().exponent(.5);
	  };
	  d3.scale.ordinal = function() {
	    return d3_scale_ordinal([], {
	      t: "range",
	      a: [ [] ]
	    });
	  };
	  function d3_scale_ordinal(domain, ranger) {
	    var index, range, rangeBand;
	    function scale(x) {
	      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
	    }
	    function steps(start, step) {
	      return d3.range(domain.length).map(function(i) {
	        return start + step * i;
	      });
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = [];
	      index = new d3_Map();
	      var i = -1, n = x.length, xi;
	      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
	      return scale[ranger.t].apply(scale, ranger.a);
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      rangeBand = 0;
	      ranger = {
	        t: "range",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangePoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
	      0) : (stop - start) / (domain.length - 1 + padding);
	      range = steps(start + step * padding / 2, step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangePoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundPoints = function(x, padding) {
	      if (arguments.length < 2) padding = 0;
	      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
	      0) : (stop - start) / (domain.length - 1 + padding) | 0;
	      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
	      rangeBand = 0;
	      ranger = {
	        t: "rangeRoundPoints",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
	      range = steps(start + step * outerPadding, step);
	      if (reverse) range.reverse();
	      rangeBand = step * (1 - padding);
	      ranger = {
	        t: "rangeBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeRoundBands = function(x, padding, outerPadding) {
	      if (arguments.length < 2) padding = 0;
	      if (arguments.length < 3) outerPadding = padding;
	      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
	      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
	      if (reverse) range.reverse();
	      rangeBand = Math.round(step * (1 - padding));
	      ranger = {
	        t: "rangeRoundBands",
	        a: arguments
	      };
	      return scale;
	    };
	    scale.rangeBand = function() {
	      return rangeBand;
	    };
	    scale.rangeExtent = function() {
	      return d3_scaleExtent(ranger.a[0]);
	    };
	    scale.copy = function() {
	      return d3_scale_ordinal(domain, ranger);
	    };
	    return scale.domain(domain);
	  }
	  d3.scale.category10 = function() {
	    return d3.scale.ordinal().range(d3_category10);
	  };
	  d3.scale.category20 = function() {
	    return d3.scale.ordinal().range(d3_category20);
	  };
	  d3.scale.category20b = function() {
	    return d3.scale.ordinal().range(d3_category20b);
	  };
	  d3.scale.category20c = function() {
	    return d3.scale.ordinal().range(d3_category20c);
	  };
	  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
	  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
	  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
	  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
	  d3.scale.quantile = function() {
	    return d3_scale_quantile([], []);
	  };
	  function d3_scale_quantile(domain, range) {
	    var thresholds;
	    function rescale() {
	      var k = 0, q = range.length;
	      thresholds = [];
	      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
	      return scale;
	    }
	    function scale(x) {
	      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.quantiles = function() {
	      return thresholds;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantile(domain, range);
	    };
	    return rescale();
	  }
	  d3.scale.quantize = function() {
	    return d3_scale_quantize(0, 1, [ 0, 1 ]);
	  };
	  function d3_scale_quantize(x0, x1, range) {
	    var kx, i;
	    function scale(x) {
	      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
	    }
	    function rescale() {
	      kx = range.length / (x1 - x0);
	      i = range.length - 1;
	      return scale;
	    }
	    scale.domain = function(x) {
	      if (!arguments.length) return [ x0, x1 ];
	      x0 = +x[0];
	      x1 = +x[x.length - 1];
	      return rescale();
	    };
	    scale.range = function(x) {
	      if (!arguments.length) return range;
	      range = x;
	      return rescale();
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      y = y < 0 ? NaN : y / kx + x0;
	      return [ y, y + 1 / kx ];
	    };
	    scale.copy = function() {
	      return d3_scale_quantize(x0, x1, range);
	    };
	    return rescale();
	  }
	  d3.scale.threshold = function() {
	    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
	  };
	  function d3_scale_threshold(domain, range) {
	    function scale(x) {
	      if (x <= x) return range[d3.bisect(domain, x)];
	    }
	    scale.domain = function(_) {
	      if (!arguments.length) return domain;
	      domain = _;
	      return scale;
	    };
	    scale.range = function(_) {
	      if (!arguments.length) return range;
	      range = _;
	      return scale;
	    };
	    scale.invertExtent = function(y) {
	      y = range.indexOf(y);
	      return [ domain[y - 1], domain[y] ];
	    };
	    scale.copy = function() {
	      return d3_scale_threshold(domain, range);
	    };
	    return scale;
	  }
	  d3.scale.identity = function() {
	    return d3_scale_identity([ 0, 1 ]);
	  };
	  function d3_scale_identity(domain) {
	    function identity(x) {
	      return +x;
	    }
	    identity.invert = identity;
	    identity.domain = identity.range = function(x) {
	      if (!arguments.length) return domain;
	      domain = x.map(identity);
	      return identity;
	    };
	    identity.ticks = function(m) {
	      return d3_scale_linearTicks(domain, m);
	    };
	    identity.tickFormat = function(m, format) {
	      return d3_scale_linearTickFormat(domain, m, format);
	    };
	    identity.copy = function() {
	      return d3_scale_identity(domain);
	    };
	    return identity;
	  }
	  d3.svg = {};
	  function d3_zero() {
	    return 0;
	  }
	  d3.svg.arc = function() {
	    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
	    function arc() {
	      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
	      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
	      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
	      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
	      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
	        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
	        if (!cw) p1 *= -1;
	        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
	        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
	      }
	      if (r1) {
	        x0 = r1 * Math.cos(a0 + p1);
	        y0 = r1 * Math.sin(a0 + p1);
	        x1 = r1 * Math.cos(a1 - p1);
	        y1 = r1 * Math.sin(a1 - p1);
	        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
	        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
	          var h1 = (a0 + a1) / 2;
	          x0 = r1 * Math.cos(h1);
	          y0 = r1 * Math.sin(h1);
	          x1 = y1 = null;
	        }
	      } else {
	        x0 = y0 = 0;
	      }
	      if (r0) {
	        x2 = r0 * Math.cos(a1 - p0);
	        y2 = r0 * Math.sin(a1 - p0);
	        x3 = r0 * Math.cos(a0 + p0);
	        y3 = r0 * Math.sin(a0 + p0);
	        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
	        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
	          var h0 = (a0 + a1) / 2;
	          x2 = r0 * Math.cos(h0);
	          y2 = r0 * Math.sin(h0);
	          x3 = y3 = null;
	        }
	      } else {
	        x2 = y2 = 0;
	      }
	      if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
	        cr = r0 < r1 ^ cw ? 0 : 1;
	        var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	        if (x1 != null) {
	          var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
	          if (rc === rc1) {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
	          } else {
	            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
	          }
	        } else {
	          path.push("M", x0, ",", y0);
	        }
	        if (x3 != null) {
	          var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
	          if (rc === rc0) {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          } else {
	            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
	          }
	        } else {
	          path.push("L", x2, ",", y2);
	        }
	      } else {
	        path.push("M", x0, ",", y0);
	        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
	        path.push("L", x2, ",", y2);
	        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
	      }
	      path.push("Z");
	      return path.join("");
	    }
	    function circleSegment(r1, cw) {
	      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
	    }
	    arc.innerRadius = function(v) {
	      if (!arguments.length) return innerRadius;
	      innerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.outerRadius = function(v) {
	      if (!arguments.length) return outerRadius;
	      outerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.cornerRadius = function(v) {
	      if (!arguments.length) return cornerRadius;
	      cornerRadius = d3_functor(v);
	      return arc;
	    };
	    arc.padRadius = function(v) {
	      if (!arguments.length) return padRadius;
	      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
	      return arc;
	    };
	    arc.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return arc;
	    };
	    arc.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return arc;
	    };
	    arc.padAngle = function(v) {
	      if (!arguments.length) return padAngle;
	      padAngle = d3_functor(v);
	      return arc;
	    };
	    arc.centroid = function() {
	      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
	      return [ Math.cos(a) * r, Math.sin(a) * r ];
	    };
	    return arc;
	  };
	  var d3_svg_arcAuto = "auto";
	  function d3_svg_arcInnerRadius(d) {
	    return d.innerRadius;
	  }
	  function d3_svg_arcOuterRadius(d) {
	    return d.outerRadius;
	  }
	  function d3_svg_arcStartAngle(d) {
	    return d.startAngle;
	  }
	  function d3_svg_arcEndAngle(d) {
	    return d.endAngle;
	  }
	  function d3_svg_arcPadAngle(d) {
	    return d && d.padAngle;
	  }
	  function d3_svg_arcSweep(x0, y0, x1, y1) {
	    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
	  }
	  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
	    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
	    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
	    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
	  }
	  function d3_svg_line(projection) {
	    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
	    function line(data) {
	      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
	      function segment() {
	        segments.push("M", interpolate(projection(points), tension));
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
	        } else if (points.length) {
	          segment();
	          points = [];
	        }
	      }
	      if (points.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    line.x = function(_) {
	      if (!arguments.length) return x;
	      x = _;
	      return line;
	    };
	    line.y = function(_) {
	      if (!arguments.length) return y;
	      y = _;
	      return line;
	    };
	    line.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return line;
	    };
	    line.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      return line;
	    };
	    line.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return line;
	    };
	    return line;
	  }
	  d3.svg.line = function() {
	    return d3_svg_line(d3_identity);
	  };
	  var d3_svg_lineInterpolators = d3.map({
	    linear: d3_svg_lineLinear,
	    "linear-closed": d3_svg_lineLinearClosed,
	    step: d3_svg_lineStep,
	    "step-before": d3_svg_lineStepBefore,
	    "step-after": d3_svg_lineStepAfter,
	    basis: d3_svg_lineBasis,
	    "basis-open": d3_svg_lineBasisOpen,
	    "basis-closed": d3_svg_lineBasisClosed,
	    bundle: d3_svg_lineBundle,
	    cardinal: d3_svg_lineCardinal,
	    "cardinal-open": d3_svg_lineCardinalOpen,
	    "cardinal-closed": d3_svg_lineCardinalClosed,
	    monotone: d3_svg_lineMonotone
	  });
	  d3_svg_lineInterpolators.forEach(function(key, value) {
	    value.key = key;
	    value.closed = /-closed$/.test(key);
	  });
	  function d3_svg_lineLinear(points) {
	    return points.join("L");
	  }
	  function d3_svg_lineLinearClosed(points) {
	    return d3_svg_lineLinear(points) + "Z";
	  }
	  function d3_svg_lineStep(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
	    if (n > 1) path.push("H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepBefore(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
	    return path.join("");
	  }
	  function d3_svg_lineStepAfter(points) {
	    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
	    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
	    return path.join("");
	  }
	  function d3_svg_lineCardinalOpen(points, tension) {
	    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineCardinalClosed(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
	    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
	  }
	  function d3_svg_lineCardinal(points, tension) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
	  }
	  function d3_svg_lineHermite(points, tangents) {
	    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
	      return d3_svg_lineLinear(points);
	    }
	    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
	    if (quad) {
	      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
	      p0 = points[1];
	      pi = 2;
	    }
	    if (tangents.length > 1) {
	      t = tangents[1];
	      p = points[pi];
	      pi++;
	      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      for (var i = 2; i < tangents.length; i++, pi++) {
	        p = points[pi];
	        t = tangents[i];
	        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
	      }
	    }
	    if (quad) {
	      var lp = points[pi];
	      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
	    }
	    return path;
	  }
	  function d3_svg_lineCardinalTangents(points, tension) {
	    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
	    while (++i < n) {
	      p0 = p1;
	      p1 = p2;
	      p2 = points[i];
	      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineBasis(points) {
	    if (points.length < 3) return d3_svg_lineLinear(points);
	    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    points.push(points[n - 1]);
	    while (++i <= n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    points.pop();
	    path.push("L", pi);
	    return path.join("");
	  }
	  function d3_svg_lineBasisOpen(points) {
	    if (points.length < 4) return d3_svg_lineLinear(points);
	    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
	    while (++i < 3) {
	      pi = points[i];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
	    --i;
	    while (++i < n) {
	      pi = points[i];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBasisClosed(points) {
	    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
	    while (++i < 4) {
	      pi = points[i % n];
	      px.push(pi[0]);
	      py.push(pi[1]);
	    }
	    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
	    --i;
	    while (++i < m) {
	      pi = points[i % n];
	      px.shift();
	      px.push(pi[0]);
	      py.shift();
	      py.push(pi[1]);
	      d3_svg_lineBasisBezier(path, px, py);
	    }
	    return path.join("");
	  }
	  function d3_svg_lineBundle(points, tension) {
	    var n = points.length - 1;
	    if (n) {
	      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
	      while (++i <= n) {
	        p = points[i];
	        t = i / n;
	        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
	        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
	      }
	    }
	    return d3_svg_lineBasis(points);
	  }
	  function d3_svg_lineDot4(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
	  }
	  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
	  function d3_svg_lineBasisBezier(path, x, y) {
	    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
	  }
	  function d3_svg_lineSlope(p0, p1) {
	    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
	  }
	  function d3_svg_lineFiniteDifferences(points) {
	    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
	    while (++i < j) {
	      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
	    }
	    m[i] = d;
	    return m;
	  }
	  function d3_svg_lineMonotoneTangents(points) {
	    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
	    while (++i < j) {
	      d = d3_svg_lineSlope(points[i], points[i + 1]);
	      if (abs(d) < ε) {
	        m[i] = m[i + 1] = 0;
	      } else {
	        a = m[i] / d;
	        b = m[i + 1] / d;
	        s = a * a + b * b;
	        if (s > 9) {
	          s = d * 3 / Math.sqrt(s);
	          m[i] = s * a;
	          m[i + 1] = s * b;
	        }
	      }
	    }
	    i = -1;
	    while (++i <= j) {
	      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
	      tangents.push([ s || 0, m[i] * s || 0 ]);
	    }
	    return tangents;
	  }
	  function d3_svg_lineMonotone(points) {
	    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
	  }
	  d3.svg.line.radial = function() {
	    var line = d3_svg_line(d3_svg_lineRadial);
	    line.radius = line.x, delete line.x;
	    line.angle = line.y, delete line.y;
	    return line;
	  };
	  function d3_svg_lineRadial(points) {
	    var point, i = -1, n = points.length, r, a;
	    while (++i < n) {
	      point = points[i];
	      r = point[0];
	      a = point[1] - halfπ;
	      point[0] = r * Math.cos(a);
	      point[1] = r * Math.sin(a);
	    }
	    return points;
	  }
	  function d3_svg_area(projection) {
	    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
	    function area(data) {
	      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
	        return x;
	      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
	        return y;
	      } : d3_functor(y1), x, y;
	      function segment() {
	        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
	      }
	      while (++i < n) {
	        if (defined.call(this, d = data[i], i)) {
	          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
	          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
	        } else if (points0.length) {
	          segment();
	          points0 = [];
	          points1 = [];
	        }
	      }
	      if (points0.length) segment();
	      return segments.length ? segments.join("") : null;
	    }
	    area.x = function(_) {
	      if (!arguments.length) return x1;
	      x0 = x1 = _;
	      return area;
	    };
	    area.x0 = function(_) {
	      if (!arguments.length) return x0;
	      x0 = _;
	      return area;
	    };
	    area.x1 = function(_) {
	      if (!arguments.length) return x1;
	      x1 = _;
	      return area;
	    };
	    area.y = function(_) {
	      if (!arguments.length) return y1;
	      y0 = y1 = _;
	      return area;
	    };
	    area.y0 = function(_) {
	      if (!arguments.length) return y0;
	      y0 = _;
	      return area;
	    };
	    area.y1 = function(_) {
	      if (!arguments.length) return y1;
	      y1 = _;
	      return area;
	    };
	    area.defined = function(_) {
	      if (!arguments.length) return defined;
	      defined = _;
	      return area;
	    };
	    area.interpolate = function(_) {
	      if (!arguments.length) return interpolateKey;
	      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
	      interpolateReverse = interpolate.reverse || interpolate;
	      L = interpolate.closed ? "M" : "L";
	      return area;
	    };
	    area.tension = function(_) {
	      if (!arguments.length) return tension;
	      tension = _;
	      return area;
	    };
	    return area;
	  }
	  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
	  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
	  d3.svg.area = function() {
	    return d3_svg_area(d3_identity);
	  };
	  d3.svg.area.radial = function() {
	    var area = d3_svg_area(d3_svg_lineRadial);
	    area.radius = area.x, delete area.x;
	    area.innerRadius = area.x0, delete area.x0;
	    area.outerRadius = area.x1, delete area.x1;
	    area.angle = area.y, delete area.y;
	    area.startAngle = area.y0, delete area.y0;
	    area.endAngle = area.y1, delete area.y1;
	    return area;
	  };
	  d3.svg.chord = function() {
	    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
	    function chord(d, i) {
	      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
	      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
	    }
	    function subgroup(self, f, d, i) {
	      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
	      return {
	        r: r,
	        a0: a0,
	        a1: a1,
	        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
	        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
	      };
	    }
	    function equals(a, b) {
	      return a.a0 == b.a0 && a.a1 == b.a1;
	    }
	    function arc(r, p, a) {
	      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
	    }
	    function curve(r0, p0, r1, p1) {
	      return "Q 0,0 " + p1;
	    }
	    chord.radius = function(v) {
	      if (!arguments.length) return radius;
	      radius = d3_functor(v);
	      return chord;
	    };
	    chord.source = function(v) {
	      if (!arguments.length) return source;
	      source = d3_functor(v);
	      return chord;
	    };
	    chord.target = function(v) {
	      if (!arguments.length) return target;
	      target = d3_functor(v);
	      return chord;
	    };
	    chord.startAngle = function(v) {
	      if (!arguments.length) return startAngle;
	      startAngle = d3_functor(v);
	      return chord;
	    };
	    chord.endAngle = function(v) {
	      if (!arguments.length) return endAngle;
	      endAngle = d3_functor(v);
	      return chord;
	    };
	    return chord;
	  };
	  function d3_svg_chordRadius(d) {
	    return d.radius;
	  }
	  d3.svg.diagonal = function() {
	    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
	    function diagonal(d, i) {
	      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
	        x: p0.x,
	        y: m
	      }, {
	        x: p3.x,
	        y: m
	      }, p3 ];
	      p = p.map(projection);
	      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
	    }
	    diagonal.source = function(x) {
	      if (!arguments.length) return source;
	      source = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.target = function(x) {
	      if (!arguments.length) return target;
	      target = d3_functor(x);
	      return diagonal;
	    };
	    diagonal.projection = function(x) {
	      if (!arguments.length) return projection;
	      projection = x;
	      return diagonal;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalProjection(d) {
	    return [ d.x, d.y ];
	  }
	  d3.svg.diagonal.radial = function() {
	    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
	    diagonal.projection = function(x) {
	      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
	    };
	    return diagonal;
	  };
	  function d3_svg_diagonalRadialProjection(projection) {
	    return function() {
	      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
	      return [ r * Math.cos(a), r * Math.sin(a) ];
	    };
	  }
	  d3.svg.symbol = function() {
	    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
	    function symbol(d, i) {
	      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
	    }
	    symbol.type = function(x) {
	      if (!arguments.length) return type;
	      type = d3_functor(x);
	      return symbol;
	    };
	    symbol.size = function(x) {
	      if (!arguments.length) return size;
	      size = d3_functor(x);
	      return symbol;
	    };
	    return symbol;
	  };
	  function d3_svg_symbolSize() {
	    return 64;
	  }
	  function d3_svg_symbolType() {
	    return "circle";
	  }
	  function d3_svg_symbolCircle(size) {
	    var r = Math.sqrt(size / π);
	    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
	  }
	  var d3_svg_symbols = d3.map({
	    circle: d3_svg_symbolCircle,
	    cross: function(size) {
	      var r = Math.sqrt(size / 5) / 2;
	      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
	    },
	    diamond: function(size) {
	      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
	      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
	    },
	    square: function(size) {
	      var r = Math.sqrt(size) / 2;
	      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
	    },
	    "triangle-down": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
	    },
	    "triangle-up": function(size) {
	      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
	      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
	    }
	  });
	  d3.svg.symbolTypes = d3_svg_symbols.keys();
	  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
	  d3_selectionPrototype.transition = function(name) {
	    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
	      time: Date.now(),
	      ease: d3_ease_cubicInOut,
	      delay: 0,
	      duration: 250
	    };
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_selectionPrototype.interrupt = function(name) {
	    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
	  };
	  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
	  function d3_selection_interruptNS(ns) {
	    return function() {
	      var lock, active;
	      if ((lock = this[ns]) && (active = lock[lock.active])) {
	        if (--lock.count) delete lock[lock.active]; else delete this[ns];
	        lock.active += .5;
	        active.event && active.event.interrupt.call(this, this.__data__, active.index);
	      }
	    };
	  }
	  function d3_transition(groups, ns, id) {
	    d3_subclass(groups, d3_transitionPrototype);
	    groups.namespace = ns;
	    groups.id = id;
	    return groups;
	  }
	  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
	  d3_transitionPrototype.call = d3_selectionPrototype.call;
	  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
	  d3_transitionPrototype.node = d3_selectionPrototype.node;
	  d3_transitionPrototype.size = d3_selectionPrototype.size;
	  d3.transition = function(selection, name) {
	    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
	  };
	  d3.transition.prototype = d3_transitionPrototype;
	  d3_transitionPrototype.select = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
	    selector = d3_selection_selector(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
	          if ("__data__" in node) subnode.__data__ = node.__data__;
	          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
	          subgroup.push(subnode);
	        } else {
	          subgroup.push(null);
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.selectAll = function(selector) {
	    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
	    selector = d3_selection_selectorAll(selector);
	    for (var j = -1, m = this.length; ++j < m; ) {
	      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
	        if (node = group[i]) {
	          transition = node[ns][id];
	          subnodes = selector.call(node, node.__data__, i, j);
	          subgroups.push(subgroup = []);
	          for (var k = -1, o = subnodes.length; ++k < o; ) {
	            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
	            subgroup.push(subnode);
	          }
	        }
	      }
	    }
	    return d3_transition(subgroups, ns, id);
	  };
	  d3_transitionPrototype.filter = function(filter) {
	    var subgroups = [], subgroup, group, node;
	    if (typeof filter !== "function") filter = d3_selection_filter(filter);
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
	          subgroup.push(node);
	        }
	      }
	    }
	    return d3_transition(subgroups, this.namespace, this.id);
	  };
	  d3_transitionPrototype.tween = function(name, tween) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
	    return d3_selection_each(this, tween == null ? function(node) {
	      node[ns][id].tween.remove(name);
	    } : function(node) {
	      node[ns][id].tween.set(name, tween);
	    });
	  };
	  function d3_transition_tween(groups, name, value, tween) {
	    var id = groups.id, ns = groups.namespace;
	    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
	    } : (value = tween(value), function(node) {
	      node[ns][id].tween.set(name, value);
	    }));
	  }
	  d3_transitionPrototype.attr = function(nameNS, value) {
	    if (arguments.length < 2) {
	      for (value in nameNS) this.attr(value, nameNS[value]);
	      return this;
	    }
	    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
	    function attrNull() {
	      this.removeAttribute(name);
	    }
	    function attrNullNS() {
	      this.removeAttributeNS(name.space, name.local);
	    }
	    function attrTween(b) {
	      return b == null ? attrNull : (b += "", function() {
	        var a = this.getAttribute(name), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttribute(name, i(t));
	        });
	      });
	    }
	    function attrTweenNS(b) {
	      return b == null ? attrNullNS : (b += "", function() {
	        var a = this.getAttributeNS(name.space, name.local), i;
	        return a !== b && (i = interpolate(a, b), function(t) {
	          this.setAttributeNS(name.space, name.local, i(t));
	        });
	      });
	    }
	    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.attrTween = function(nameNS, tween) {
	    var name = d3.ns.qualify(nameNS);
	    function attrTween(d, i) {
	      var f = tween.call(this, d, i, this.getAttribute(name));
	      return f && function(t) {
	        this.setAttribute(name, f(t));
	      };
	    }
	    function attrTweenNS(d, i) {
	      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
	      return f && function(t) {
	        this.setAttributeNS(name.space, name.local, f(t));
	      };
	    }
	    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
	  };
	  d3_transitionPrototype.style = function(name, value, priority) {
	    var n = arguments.length;
	    if (n < 3) {
	      if (typeof name !== "string") {
	        if (n < 2) value = "";
	        for (priority in name) this.style(priority, name[priority], value);
	        return this;
	      }
	      priority = "";
	    }
	    function styleNull() {
	      this.style.removeProperty(name);
	    }
	    function styleString(b) {
	      return b == null ? styleNull : (b += "", function() {
	        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
	        return a !== b && (i = d3_interpolate(a, b), function(t) {
	          this.style.setProperty(name, i(t), priority);
	        });
	      });
	    }
	    return d3_transition_tween(this, "style." + name, value, styleString);
	  };
	  d3_transitionPrototype.styleTween = function(name, tween, priority) {
	    if (arguments.length < 3) priority = "";
	    function styleTween(d, i) {
	      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
	      return f && function(t) {
	        this.style.setProperty(name, f(t), priority);
	      };
	    }
	    return this.tween("style." + name, styleTween);
	  };
	  d3_transitionPrototype.text = function(value) {
	    return d3_transition_tween(this, "text", value, d3_transition_text);
	  };
	  function d3_transition_text(b) {
	    if (b == null) b = "";
	    return function() {
	      this.textContent = b;
	    };
	  }
	  d3_transitionPrototype.remove = function() {
	    var ns = this.namespace;
	    return this.each("end.transition", function() {
	      var p;
	      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
	    });
	  };
	  d3_transitionPrototype.ease = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].ease;
	    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
	    return d3_selection_each(this, function(node) {
	      node[ns][id].ease = value;
	    });
	  };
	  d3_transitionPrototype.delay = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].delay;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].delay = +value.call(node, node.__data__, i, j);
	    } : (value = +value, function(node) {
	      node[ns][id].delay = value;
	    }));
	  };
	  d3_transitionPrototype.duration = function(value) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 1) return this.node()[ns][id].duration;
	    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
	      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
	    } : (value = Math.max(1, value), function(node) {
	      node[ns][id].duration = value;
	    }));
	  };
	  d3_transitionPrototype.each = function(type, listener) {
	    var id = this.id, ns = this.namespace;
	    if (arguments.length < 2) {
	      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
	      try {
	        d3_transitionInheritId = id;
	        d3_selection_each(this, function(node, i, j) {
	          d3_transitionInherit = node[ns][id];
	          type.call(node, node.__data__, i, j);
	        });
	      } finally {
	        d3_transitionInherit = inherit;
	        d3_transitionInheritId = inheritId;
	      }
	    } else {
	      d3_selection_each(this, function(node) {
	        var transition = node[ns][id];
	        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
	      });
	    }
	    return this;
	  };
	  d3_transitionPrototype.transition = function() {
	    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
	    for (var j = 0, m = this.length; j < m; j++) {
	      subgroups.push(subgroup = []);
	      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
	        if (node = group[i]) {
	          transition = node[ns][id0];
	          d3_transitionNode(node, i, ns, id1, {
	            time: transition.time,
	            ease: transition.ease,
	            delay: transition.delay + transition.duration,
	            duration: transition.duration
	          });
	        }
	        subgroup.push(node);
	      }
	    }
	    return d3_transition(subgroups, ns, id1);
	  };
	  function d3_transitionNamespace(name) {
	    return name == null ? "__transition__" : "__transition_" + name + "__";
	  }
	  function d3_transitionNode(node, i, ns, id, inherit) {
	    var lock = node[ns] || (node[ns] = {
	      active: 0,
	      count: 0
	    }), transition = lock[id];
	    if (!transition) {
	      var time = inherit.time;
	      transition = lock[id] = {
	        tween: new d3_Map(),
	        time: time,
	        delay: inherit.delay,
	        duration: inherit.duration,
	        ease: inherit.ease,
	        index: i
	      };
	      inherit = null;
	      ++lock.count;
	      d3.timer(function(elapsed) {
	        var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
	        timer.t = delay + time;
	        if (delay <= elapsed) return start(elapsed - delay);
	        timer.c = start;
	        function start(elapsed) {
	          if (lock.active > id) return stop();
	          var active = lock[lock.active];
	          if (active) {
	            --lock.count;
	            delete lock[lock.active];
	            active.event && active.event.interrupt.call(node, node.__data__, active.index);
	          }
	          lock.active = id;
	          transition.event && transition.event.start.call(node, node.__data__, i);
	          transition.tween.forEach(function(key, value) {
	            if (value = value.call(node, node.__data__, i)) {
	              tweened.push(value);
	            }
	          });
	          ease = transition.ease;
	          duration = transition.duration;
	          d3.timer(function() {
	            timer.c = tick(elapsed || 1) ? d3_true : tick;
	            return 1;
	          }, 0, time);
	        }
	        function tick(elapsed) {
	          if (lock.active !== id) return 1;
	          var t = elapsed / duration, e = ease(t), n = tweened.length;
	          while (n > 0) {
	            tweened[--n].call(node, e);
	          }
	          if (t >= 1) {
	            transition.event && transition.event.end.call(node, node.__data__, i);
	            return stop();
	          }
	        }
	        function stop() {
	          if (--lock.count) delete lock[id]; else delete node[ns];
	          return 1;
	        }
	      }, 0, time);
	    }
	  }
	  d3.svg.axis = function() {
	    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
	    function axis(g) {
	      g.each(function() {
	        var g = d3.select(this);
	        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
	        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
	        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
	        d3.transition(path));
	        tickEnter.append("line");
	        tickEnter.append("text");
	        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
	        if (orient === "bottom" || orient === "top") {
	          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
	          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
	          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
	        } else {
	          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
	          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
	          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
	        }
	        lineEnter.attr(y2, sign * innerTickSize);
	        textEnter.attr(y1, sign * tickSpacing);
	        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
	        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
	        if (scale1.rangeBand) {
	          var x = scale1, dx = x.rangeBand() / 2;
	          scale0 = scale1 = function(d) {
	            return x(d) + dx;
	          };
	        } else if (scale0.rangeBand) {
	          scale0 = scale1;
	        } else {
	          tickExit.call(tickTransform, scale1, scale0);
	        }
	        tickEnter.call(tickTransform, scale0, scale1);
	        tickUpdate.call(tickTransform, scale1, scale1);
	      });
	    }
	    axis.scale = function(x) {
	      if (!arguments.length) return scale;
	      scale = x;
	      return axis;
	    };
	    axis.orient = function(x) {
	      if (!arguments.length) return orient;
	      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
	      return axis;
	    };
	    axis.ticks = function() {
	      if (!arguments.length) return tickArguments_;
	      tickArguments_ = arguments;
	      return axis;
	    };
	    axis.tickValues = function(x) {
	      if (!arguments.length) return tickValues;
	      tickValues = x;
	      return axis;
	    };
	    axis.tickFormat = function(x) {
	      if (!arguments.length) return tickFormat_;
	      tickFormat_ = x;
	      return axis;
	    };
	    axis.tickSize = function(x) {
	      var n = arguments.length;
	      if (!n) return innerTickSize;
	      innerTickSize = +x;
	      outerTickSize = +arguments[n - 1];
	      return axis;
	    };
	    axis.innerTickSize = function(x) {
	      if (!arguments.length) return innerTickSize;
	      innerTickSize = +x;
	      return axis;
	    };
	    axis.outerTickSize = function(x) {
	      if (!arguments.length) return outerTickSize;
	      outerTickSize = +x;
	      return axis;
	    };
	    axis.tickPadding = function(x) {
	      if (!arguments.length) return tickPadding;
	      tickPadding = +x;
	      return axis;
	    };
	    axis.tickSubdivide = function() {
	      return arguments.length && axis;
	    };
	    return axis;
	  };
	  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
	    top: 1,
	    right: 1,
	    bottom: 1,
	    left: 1
	  };
	  function d3_svg_axisX(selection, x0, x1) {
	    selection.attr("transform", function(d) {
	      var v0 = x0(d);
	      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
	    });
	  }
	  function d3_svg_axisY(selection, y0, y1) {
	    selection.attr("transform", function(d) {
	      var v0 = y0(d);
	      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
	    });
	  }
	  d3.svg.brush = function() {
	    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
	    function brush(g) {
	      g.each(function() {
	        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
	        var background = g.selectAll(".background").data([ 0 ]);
	        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
	        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
	        var resize = g.selectAll(".resize").data(resizes, d3_identity);
	        resize.exit().remove();
	        resize.enter().append("g").attr("class", function(d) {
	          return "resize " + d;
	        }).style("cursor", function(d) {
	          return d3_svg_brushCursor[d];
	        }).append("rect").attr("x", function(d) {
	          return /[ew]$/.test(d) ? -3 : null;
	        }).attr("y", function(d) {
	          return /^[ns]/.test(d) ? -3 : null;
	        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
	        resize.style("display", brush.empty() ? "none" : null);
	        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
	        if (x) {
	          range = d3_scaleRange(x);
	          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
	          redrawX(gUpdate);
	        }
	        if (y) {
	          range = d3_scaleRange(y);
	          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
	          redrawY(gUpdate);
	        }
	        redraw(gUpdate);
	      });
	    }
	    brush.event = function(g) {
	      g.each(function() {
	        var event_ = event.of(this, arguments), extent1 = {
	          x: xExtent,
	          y: yExtent,
	          i: xExtentDomain,
	          j: yExtentDomain
	        }, extent0 = this.__chart__ || extent1;
	        this.__chart__ = extent1;
	        if (d3_transitionInheritId) {
	          d3.select(this).transition().each("start.brush", function() {
	            xExtentDomain = extent0.i;
	            yExtentDomain = extent0.j;
	            xExtent = extent0.x;
	            yExtent = extent0.y;
	            event_({
	              type: "brushstart"
	            });
	          }).tween("brush:brush", function() {
	            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
	            xExtentDomain = yExtentDomain = null;
	            return function(t) {
	              xExtent = extent1.x = xi(t);
	              yExtent = extent1.y = yi(t);
	              event_({
	                type: "brush",
	                mode: "resize"
	              });
	            };
	          }).each("end.brush", function() {
	            xExtentDomain = extent1.i;
	            yExtentDomain = extent1.j;
	            event_({
	              type: "brush",
	              mode: "resize"
	            });
	            event_({
	              type: "brushend"
	            });
	          });
	        } else {
	          event_({
	            type: "brushstart"
	          });
	          event_({
	            type: "brush",
	            mode: "resize"
	          });
	          event_({
	            type: "brushend"
	          });
	        }
	      });
	    };
	    function redraw(g) {
	      g.selectAll(".resize").attr("transform", function(d) {
	        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
	      });
	    }
	    function redrawX(g) {
	      g.select(".extent").attr("x", xExtent[0]);
	      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
	    }
	    function redrawY(g) {
	      g.select(".extent").attr("y", yExtent[0]);
	      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
	    }
	    function brushstart() {
	      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
	      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
	      if (d3.event.changedTouches) {
	        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
	      } else {
	        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
	      }
	      g.interrupt().selectAll("*").interrupt();
	      if (dragging) {
	        origin[0] = xExtent[0] - origin[0];
	        origin[1] = yExtent[0] - origin[1];
	      } else if (resizing) {
	        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
	        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
	        origin[0] = xExtent[ex];
	        origin[1] = yExtent[ey];
	      } else if (d3.event.altKey) center = origin.slice();
	      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
	      d3.select("body").style("cursor", eventTarget.style("cursor"));
	      event_({
	        type: "brushstart"
	      });
	      brushmove();
	      function keydown() {
	        if (d3.event.keyCode == 32) {
	          if (!dragging) {
	            center = null;
	            origin[0] -= xExtent[1];
	            origin[1] -= yExtent[1];
	            dragging = 2;
	          }
	          d3_eventPreventDefault();
	        }
	      }
	      function keyup() {
	        if (d3.event.keyCode == 32 && dragging == 2) {
	          origin[0] += xExtent[1];
	          origin[1] += yExtent[1];
	          dragging = 0;
	          d3_eventPreventDefault();
	        }
	      }
	      function brushmove() {
	        var point = d3.mouse(target), moved = false;
	        if (offset) {
	          point[0] += offset[0];
	          point[1] += offset[1];
	        }
	        if (!dragging) {
	          if (d3.event.altKey) {
	            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
	            origin[0] = xExtent[+(point[0] < center[0])];
	            origin[1] = yExtent[+(point[1] < center[1])];
	          } else center = null;
	        }
	        if (resizingX && move1(point, x, 0)) {
	          redrawX(g);
	          moved = true;
	        }
	        if (resizingY && move1(point, y, 1)) {
	          redrawY(g);
	          moved = true;
	        }
	        if (moved) {
	          redraw(g);
	          event_({
	            type: "brush",
	            mode: dragging ? "move" : "resize"
	          });
	        }
	      }
	      function move1(point, scale, i) {
	        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
	        if (dragging) {
	          r0 -= position;
	          r1 -= size + position;
	        }
	        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
	        if (dragging) {
	          max = (min += position) + size;
	        } else {
	          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
	          if (position < min) {
	            max = min;
	            min = position;
	          } else {
	            max = position;
	          }
	        }
	        if (extent[0] != min || extent[1] != max) {
	          if (i) yExtentDomain = null; else xExtentDomain = null;
	          extent[0] = min;
	          extent[1] = max;
	          return true;
	        }
	      }
	      function brushend() {
	        brushmove();
	        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
	        d3.select("body").style("cursor", null);
	        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
	        dragRestore();
	        event_({
	          type: "brushend"
	        });
	      }
	    }
	    brush.x = function(z) {
	      if (!arguments.length) return x;
	      x = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.y = function(z) {
	      if (!arguments.length) return y;
	      y = z;
	      resizes = d3_svg_brushResizes[!x << 1 | !y];
	      return brush;
	    };
	    brush.clamp = function(z) {
	      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
	      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
	      return brush;
	    };
	    brush.extent = function(z) {
	      var x0, x1, y0, y1, t;
	      if (!arguments.length) {
	        if (x) {
	          if (xExtentDomain) {
	            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
	          } else {
	            x0 = xExtent[0], x1 = xExtent[1];
	            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
	            if (x1 < x0) t = x0, x0 = x1, x1 = t;
	          }
	        }
	        if (y) {
	          if (yExtentDomain) {
	            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
	          } else {
	            y0 = yExtent[0], y1 = yExtent[1];
	            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
	            if (y1 < y0) t = y0, y0 = y1, y1 = t;
	          }
	        }
	        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
	      }
	      if (x) {
	        x0 = z[0], x1 = z[1];
	        if (y) x0 = x0[0], x1 = x1[0];
	        xExtentDomain = [ x0, x1 ];
	        if (x.invert) x0 = x(x0), x1 = x(x1);
	        if (x1 < x0) t = x0, x0 = x1, x1 = t;
	        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
	      }
	      if (y) {
	        y0 = z[0], y1 = z[1];
	        if (x) y0 = y0[1], y1 = y1[1];
	        yExtentDomain = [ y0, y1 ];
	        if (y.invert) y0 = y(y0), y1 = y(y1);
	        if (y1 < y0) t = y0, y0 = y1, y1 = t;
	        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
	      }
	      return brush;
	    };
	    brush.clear = function() {
	      if (!brush.empty()) {
	        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
	        xExtentDomain = yExtentDomain = null;
	      }
	      return brush;
	    };
	    brush.empty = function() {
	      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
	    };
	    return d3.rebind(brush, event, "on");
	  };
	  var d3_svg_brushCursor = {
	    n: "ns-resize",
	    e: "ew-resize",
	    s: "ns-resize",
	    w: "ew-resize",
	    nw: "nwse-resize",
	    ne: "nesw-resize",
	    se: "nwse-resize",
	    sw: "nesw-resize"
	  };
	  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
	  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
	  var d3_time_formatUtc = d3_time_format.utc;
	  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
	  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
	  function d3_time_formatIsoNative(date) {
	    return date.toISOString();
	  }
	  d3_time_formatIsoNative.parse = function(string) {
	    var date = new Date(string);
	    return isNaN(date) ? null : date;
	  };
	  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
	  d3_time.second = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 1e3) * 1e3);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
	  }, function(date) {
	    return date.getSeconds();
	  });
	  d3_time.seconds = d3_time.second.range;
	  d3_time.seconds.utc = d3_time.second.utc.range;
	  d3_time.minute = d3_time_interval(function(date) {
	    return new d3_date(Math.floor(date / 6e4) * 6e4);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
	  }, function(date) {
	    return date.getMinutes();
	  });
	  d3_time.minutes = d3_time.minute.range;
	  d3_time.minutes.utc = d3_time.minute.utc.range;
	  d3_time.hour = d3_time_interval(function(date) {
	    var timezone = date.getTimezoneOffset() / 60;
	    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
	  }, function(date, offset) {
	    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
	  }, function(date) {
	    return date.getHours();
	  });
	  d3_time.hours = d3_time.hour.range;
	  d3_time.hours.utc = d3_time.hour.utc.range;
	  d3_time.month = d3_time_interval(function(date) {
	    date = d3_time.day(date);
	    date.setDate(1);
	    return date;
	  }, function(date, offset) {
	    date.setMonth(date.getMonth() + offset);
	  }, function(date) {
	    return date.getMonth();
	  });
	  d3_time.months = d3_time.month.range;
	  d3_time.months.utc = d3_time.month.utc.range;
	  function d3_time_scale(linear, methods, format) {
	    function scale(x) {
	      return linear(x);
	    }
	    scale.invert = function(x) {
	      return d3_time_scaleDate(linear.invert(x));
	    };
	    scale.domain = function(x) {
	      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
	      linear.domain(x);
	      return scale;
	    };
	    function tickMethod(extent, count) {
	      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
	      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
	        return d / 31536e6;
	      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
	    }
	    scale.nice = function(interval, skip) {
	      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
	      if (method) interval = method[0], skip = method[1];
	      function skipped(date) {
	        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
	      }
	      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
	        floor: function(date) {
	          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
	          return date;
	        },
	        ceil: function(date) {
	          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
	          return date;
	        }
	      } : interval));
	    };
	    scale.ticks = function(interval, skip) {
	      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
	        range: interval
	      }, skip ];
	      if (method) interval = method[0], skip = method[1];
	      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
	    };
	    scale.tickFormat = function() {
	      return format;
	    };
	    scale.copy = function() {
	      return d3_time_scale(linear.copy(), methods, format);
	    };
	    return d3_scale_linearRebind(scale, linear);
	  }
	  function d3_time_scaleDate(t) {
	    return new Date(t);
	  }
	  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
	  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
	  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
	    return d.getMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getHours();
	  } ], [ "%a %d", function(d) {
	    return d.getDay() && d.getDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getMonth();
	  } ], [ "%Y", d3_true ] ]);
	  var d3_time_scaleMilliseconds = {
	    range: function(start, stop, step) {
	      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
	    },
	    floor: d3_identity,
	    ceil: d3_identity
	  };
	  d3_time_scaleLocalMethods.year = d3_time.year;
	  d3_time.scale = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
	  };
	  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
	    return [ m[0].utc, m[1] ];
	  });
	  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
	    return d.getUTCMilliseconds();
	  } ], [ ":%S", function(d) {
	    return d.getUTCSeconds();
	  } ], [ "%I:%M", function(d) {
	    return d.getUTCMinutes();
	  } ], [ "%I %p", function(d) {
	    return d.getUTCHours();
	  } ], [ "%a %d", function(d) {
	    return d.getUTCDay() && d.getUTCDate() != 1;
	  } ], [ "%b %d", function(d) {
	    return d.getUTCDate() != 1;
	  } ], [ "%B", function(d) {
	    return d.getUTCMonth();
	  } ], [ "%Y", d3_true ] ]);
	  d3_time_scaleUtcMethods.year = d3_time.year.utc;
	  d3_time.scale.utc = function() {
	    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
	  };
	  d3.text = d3_xhrType(function(request) {
	    return request.responseText;
	  });
	  d3.json = function(url, callback) {
	    return d3_xhr(url, "application/json", d3_json, callback);
	  };
	  function d3_json(request) {
	    return JSON.parse(request.responseText);
	  }
	  d3.html = function(url, callback) {
	    return d3_xhr(url, "text/html", d3_html, callback);
	  };
	  function d3_html(request) {
	    var range = d3_document.createRange();
	    range.selectNode(d3_document.body);
	    return range.createContextualFragment(request.responseText);
	  }
	  d3.xml = d3_xhrType(function(request) {
	    return request.responseXML;
	  });
	  if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3;
	  this.d3 = d3;
	}();

/***/ },
/* 6 */
/*!**************************!*\
  !*** ./lib/sailgauge.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	var Bacon = __webpack_require__(/*! baconjs */ 1);
	var StreamBundle = __webpack_require__(/*! ./baconsignalkstream.js */ 7);
	var navi = __webpack_require__(/*! ./naviutils.js */ 11);
	var signalKUtils = __webpack_require__(/*! ./signalkutils.js */ 12);
	
	function SailGauge(treeData) {
	  this.visible = true;
	  this.dispatchers =  {};
	}
	
	SailGauge.prototype = {
	  init: function (selector, size) {
	    this.drawSvg(selector, size);
	    this.startPeriodicTask();
	    this.streamBundle = new StreamBundle(function(msg) {
	      return msg.path;
	    });
	    this.initStreams();
	    return this.dispatch.bind(this);
	  },
	  initStreams: function () {
	    this.on('navigation.courseOverGroundTrue', this.updateCourse.bind(this));
	    this.on('navigation.speedOverGround', this.updateSpeedOverGround.bind(this));
	
	    var sanitizedDepthStream = this.getTypeValueStream('environment.depth.belowTransducer')
	      .filter(function(depth){return depth < 200;});
	    sanitizedDepthStream.onValue(this.updateDepthDisplay.bind(this));
	    var doDrawSparkLine = this.drawSparkline.bind(this);
	    sanitizedDepthStream.slidingTimeWindow(60 * 1000).onValue(function (data) {
	      doDrawSparkLine("#depthSpark", data, 100, 50);
	    });
	
	    this.on('environment.wind.speedApparent', this.updateApparentWindSpeed.bind(this));
	    this.on('environment.wind.angleApparent', this.updateApparentWindAngle.bind(this));
	
	    navi.createTrueWindSpeedStream(
	      this.getTypeValueStream('navigation.speedOverGround'),
	      this.getTypeValueStream('environment.wind.speedApparent'),
	      this.getTypeValueStream('environment.wind.angleApparent'),
	      this.getTypeValueStream('environment.wind.speedTrue')
	    ).onValue(this.updateTrueWindSpeed.bind(this));
	
	    var trueWindAngleStream = navi.createTrueWindAngleStream(
	      this.getTypeValueStream('navigation.speedOverGround'),
	      this.getTypeValueStream('environment.wind.speedApparent'),
	      this.getTypeValueStream('environment.wind.angleApparent'),
	      this.getTypeValueStream('environment.wind.speedTrue')
	    );
	    trueWindAngleStream.onValue(this.updateTrueWindAngle.bind(this));
	    var groundWindAngleStream = trueWindAngleStream.combine(
	      this.streamBundle.getTypeValueStream('navigation.courseOverGroundTrue'),
	      function (trueWind, course) { return trueWind + course;}
	    );
	
	    var that = this;
	    groundWindAngleStream.slidingTimeWindow(30 * 1000).throttle(1000).onValue(function (data) {
	      if (data.length < 5) return;
	      var copyData = data.slice(0).sort(function(a,b){return a.value - b.value;});
	      var twa_max = copyData[copyData.length -1].value;
	      var twa_min = copyData[0].value;
	      d3.select("#portwindsector").attr("d", that.arcForAngle(twa_max - twa_min));
	      d3.select("#gportwindsector").attr("transform", "rotate(" + (twa_min - 30 ) + " 400 400)");
	      d3.select("#starboardwindsector").attr("d", that.arcForAngle(twa_max - twa_min));
	      d3.select("#gstarboardwindsector").attr("transform", "rotate(" + (twa_min + 30 ) + " 400 400)");
	    });
	  },
	  dispatch: function(signalK) {
	    if (typeof signalK.path != 'undefined') {
	      this.streamBundle.push(signalK);
	    } else {
	      signalKUtils.dispatchInTree(signalK, this.dispatchers);
	    }
	  },
	  on: function(item, callback) {
	    this.getTypeValueStream(item).onValue(callback);    
	  },
	  getTypeValueStream: function(item) {
	    this.registerToStreamDispatcher(this.dispatchers, item.split('.'), this.streamBundle.getTypeStream(item));
	    return this.streamBundle.getTypeValueStream(item);
	  },
	  registerToStreamDispatcher: function(dispatcherBranch, itemKeysArray, stream) {
	    if (itemKeysArray.length === 1) {
	      dispatcherBranch[itemKeysArray[0]] = stream.push;
	    } else {
	      if (typeof dispatcherBranch[itemKeysArray[0]] === 'undefined') {
	        dispatcherBranch[itemKeysArray[0]] = {};
	      }
	      this.registerToStreamDispatcher(dispatcherBranch[itemKeysArray[0]], itemKeysArray.slice(1), stream);
	    }
	  },
	  updateSpeedOverGround: function(speed) {
	    if (speed != null) {
	      d3.select('#speed').text(speed.toFixed(1));
	    }
	  },
	  updateApparentWindAngle: function (angle) {
	    this.rotateAnimated('#apparentwindmarker', angle, 400, 400, 20);
	    d3.select("#apparentwindmarkertext")
	      .attr("transform", "rotate(" + (-1 * angle) + " 400 60)");
	  },
	  updateApparentWindSpeed: function (speed) {
	    d3.select("#apparentwindmarkertext")
	      .text(Number(speed).toFixed(1));
	  },
	  updateTrueWindAngle: function (angle) {
	    this.rotateAnimated('#windmarker', angle, 400, 400, 20);
	    d3.select("#windmarkertext")
	      .attr("transform", "rotate(" + (-1 * angle) + " 400 140)")
	  },
	  updateTrueWindSpeed: function (speed) {
	    d3.select("#windmarkertext")
	      .text(Number(speed).toFixed(1));
	  },
	  updateMark: function (msg) {
	    d3.select('#markdistance').text(Number(msg.distance).toFixed(1));
	    this.bearingToMark = msg.bearing;
	    d3.select("#mark").attr("display", "inline");
	    d3.select('#marktext').attr("transform", "rotate(" + (-1 * this.bearingToMark + this.trackTrue) + " 400 118)");
	    d3.select('#markdistance').attr("transform", "rotate(" + (-1 * this.bearingToMark + this.trackTrue) + " 400 70)");
	    d3.select('#marktext').text(msg.bearing.toFixed(0));
	    this.rotateAnimated('#mark', this.bearingToMark, 400, 400, 200);
	    this.lastAutopilotReceiveTime = Date.now();
	  },
	  trackTrue: 0,
	  bearingToMark: 45,
	  updateCourse: function (value) {
	    this.trackTrue = value;
	    d3.select('#tracktruetext').text(this.trackTrue.toFixed(0) + '°');
	    this.rotateAnimated('#rose', -1 * this.trackTrue, 400, 400, 200);
	    d3.select('#marktext').attr("transform", "rotate(" + (-1 * this.bearingToMark + this.trackTrue) + " 400 118)");
	    d3.select('#markdistance').attr("transform", "rotate(" + (-1 * this.bearingToMark + this.trackTrue) + " 400 70)");
	  },
	  lastDepthReceiveTime: 0,
	  lastAutopilotReceiveTime: 0,
	  updateDepthDisplay: function (depth) {
	    var depthText = d3.select('#depth');
	    depthText.text(depth.toFixed(1) + 'm').attr("display", "inline");
	    var fontSize = this.depthFontSize(depth);
	    depthText.attr('font-size', fontSize);
	    depthText.attr('dy', (fontSize * 0.7 ) - 60);
	    depthText.attr('fill', depth < 6 ? 'red' : null);
	    depthText.attr('font-weight', depth < 6 ? 'bold' : null);
	    this.lastDepthReceiveTime = Date.now();
	  },  
	  startPeriodicTask: function () {
	    var that = this;
	    setInterval(function hideInactiveElements() {
	      if (Date.now() - that.lastAutopilotReceiveTime > 60 * 1000) {
	        d3.select("#mark").attr("display", "none");
	      }
	      if (Date.now() - that.lastDepthReceiveTime > 5 * 1000) {
	        d3.select("#depth").attr("display", "none");
	      }
	    }, 5000);
	  },
	  setVisible: function(flag) {
	    this.visible = flag;
	  },
	  drawWindMarkers: function (chart) {
	    var windmarker = chart.append("g")
	      .attr("id", "windmarker")
	      .attr("class", "truewind");
	    windmarker.append("path").attr("d", "M 400,100 L  385,130  a 20,20 0 1,0 30,0 z");
	    windmarker.append("path").attr("d", "M 390,400 l 10,-300 10,300 z")
	      .attr("style", "fill:#00FF00;stroke:#00FF00;stroke-width:1")
	      .attr("transform", "rotate(30 400 400)");
	    windmarker.append("path").attr("d", "M 390,400 l 10,-300 10,300 z")
	      .attr("style", "fill:#ff0000;stroke:#ff0000;stroke-width:1")
	      .attr("transform", "rotate(-30 400 400)");
	    windmarker.append("text").attr("id", "windmarkertext").attr("x", "400").attr("y", "140")
	      .attr("text-anchor", "middle").attr("dominant-baseline", "middle")
	      .attr("class", "text").text("0");
	
	    var apparentwindmarker = chart.append("g")
	      .attr("id", "apparentwindmarker").attr("class", "apparentwind");
	    apparentwindmarker.append("path").attr("d", "M 400,100 L  385,70  a 20,20 0 1,1 30,0 z");
	    apparentwindmarker.append("text").attr("id", "apparentwindmarkertext").attr("x", "400").attr("y", "60")
	      .attr("text-anchor", "middle").attr("dominant-baseline", "middle")
	      .attr("class", "text").text("0");
	  }, 
	  drawTrackLabel: function (chart) {
	    chart.append('rect')
	      .attr('x', '370').attr('y', '60')
	      .attr('rx', '5').attr('ry', '5')
	      .attr('width', '60').attr('height', '40')
	      .attr('class', 'rose');
	    chart.append('text')
	      .attr('id', 'tracktruetext')
	      .attr('x', '400').attr('y', '80')
	      .attr('text-anchor', 'middle').attr('dominant-baseline', 'middle')
	      .attr('font-size', '25').text('000');
	  },
	  drawCompassRose: function (chart, size) {
	    var rose = chart.append('g').attr('id', 'rose').attr('class', 'rose');
	    rose.append('g').attr('id', 'edge').attr('class', 'p1');
	    rose.append('circle').attr('cx', size / 2).attr('cy', size / 2).attr('r', size / 2 - 80).attr('fill', 'gray').attr('stroke-width', '2px');
	    rose.append('path')
	      .attr('d', "M 700 400 A 300 300 0 1 1  100,400 A 300 300 0 1 1  700 400 z")
	      .attr('class', 'p-1')
	      .attr('fill', 'url(#rosegradient)')
	      .attr('opacity', '0.8')
	      .attr('stroke-width', '2px');
	    rose.append('g').attr('id', 'tickmarks');
	    rose.append('g').attr('id', 'tickmarksTop');
	    return rose;
	  },
	  drawMark: function (rose) {
	    var mark = rose.append('g').attr('id', 'mark');
	    mark.append('path').attr('d', "M 385,60 L 415,60 400,90 z").attr('class', 'mark');
	    mark.append('circle').attr('cx', '400').attr('cy', '70').attr('r', '14').attr('stroke', 'none').attr('fill', 'white');
	    mark.append('text')
	      .attr('id','markdistance')
	      .attr('x', '400').attr('y', '70')
	      .attr('class', 'marktext')
	      .attr('text-anchor', 'middle').attr('dominant-baseline', 'middle').text('000');
	    mark.append('circle').attr('cx', '400').attr('cy', '118').attr('r', '14').attr('stroke', 'none').attr('fill', 'white');
	    mark.append('text')
	      .attr('id','marktext')
	      .attr('x', '400').attr('y', '118').attr('class', 'marktext')
	      .attr('text-anchor', 'middle').attr('dominant-baseline', 'middle').text('0.0');
	  },
	  drawBackground: function (chart, selector, size) {
	    chart = d3.select(selector)
	      .append('svg:svg')
	      .attr('viewBox', "0 0 " + size + " " + size)
	      .attr('preserveAspectRatio', "xMidYMid meet")
	      .attr('class', 'chart');
	    var defs = chart.append('defs');
	    var gradient = defs.append('linearGradient')
	      .attr('id', 'rosegradient')
	      .attr('x1', '0')
	      .attr('x2', '0')
	      .attr('y1', '0')
	      .attr('y2', '1')
	    gradient.append('stop').attr('offset', '0%').attr('stop-color', '#0c5da5');
	    gradient.append('stop').attr('offset', '100%').attr('stop-color', '#ff4f00');
	    return chart;
	  },
	  drawDepthIndicator: function (chart) {
	    chart.append('text')
	      .attr('x', '800').attr('y', '60')
	      .attr('text-anchor', 'end').attr('dominant-baseline', 'text-after-edge')
	      .attr('class', 'positivegaugetext')
	      .append('tspan')
	      .attr('id', 'depth').attr('dy', '0px').attr('font-size', '60').text('99.9');
	    chart.append("g").attr("transform","translate(700 80)")
	      .append("path").attr("id","depthSpark").attr("class","sparkline").attr("d","M 5,5 l 10,10 -10,0 z");
	  },
	  drawSpeedLabel: function (chart) {
	    chart.append("text")
	      .attr("id", "speed").attr("x", "400").attr("y", "400")
	      .attr("text-anchor", "middle").attr("dominant-baseline", "middle")
	      .attr("font-size", "60").text("-");
	  },
	  drawWindSectors: function (chart) {
	    chart.append("g").attr("id","gportwindsector").attr("transform","rotate(0 400 400)")
	      .append("path")
	        .attr("id","portwindsector").attr("d","M400,400 v-300 a300,300 1 0,1 0,0 z")
	        .attr("fill","#ffdddd").attr("stroke","none");
	    chart.append("g").attr("id","gstarboardwindsector").attr("transform","rotate(0 400 400)")
	      .append("path")
	        .attr("id","starboardwindsector").attr("d","M400,400 v-300 a300,300 1 0,1 0,0 z")
	        .attr("fill","#ddffdd").attr("stroke","none");
	  },
	  drawSvg: function (selector, size) {
	    var chart = this.drawBackground(chart, selector, size);
	    var rose = this.drawCompassRose(chart, size);
	    this.drawTicks();
	    this.drawTrackLabel(chart);
	    this.drawWindSectors(rose);
	    this.drawMark(rose);
	    this.drawWindMarkers(chart);
	    this.drawBoat(chart);
	    this.drawSpeedLabel(chart);
	    this.drawDepthIndicator(chart);
	  },
	  drawTicks: function () {
	    var tickmarks = d3.select("#tickmarks");
	    var tickmarksTop = d3.select("#tickmarksTop");
	    for (var i = 10; i < 360; i += 10) {
	      tickmarks.append("path").attr("id", "id10-" + i)
	        .attr("d", "m 400,80 L 400,100")
	        .attr("stroke-width", "1")
	        .attr("transform", "rotate(" + i + " 400 400)");
	    }
	    for (var i = 5; i < 360; i += 5) {
	      tickmarks.append("path").attr("id", "id5-" + i)
	        .attr("d", "m 400,90 L 400,100")
	        .attr("stroke-width", "1")
	        .attr("transform", "rotate(" + i + " 400 400)");
	    }
	    var dirs = ['N', 'E', 'S', 'W' ];
	    for (var i = 0; i < 360; i += 90) {
	      tickmarksTop.append("rect").attr("id", "box" + i)
	        .attr("x", "380")
	        .attr("y", "100")
	        .attr("width", "40")
	        .attr("height", "30")
	        .attr("transform", "rotate(" + i + " 400 400)")
	        .text(i);
	      tickmarksTop.append("text").attr("id", "bearing" + i)
	        .attr("x", "400")
	        .attr("y", "120")
	        .attr("text-anchor", "middle")
	        .attr("transform", "rotate(" + i + " 400 400)")
	        .attr("class", "text")
	        .text(dirs[0]);
	      dirs = dirs.splice(1);
	    }
	    var dirs = ['NE', 'SE', 'SW', 'NW'];
	    for (var i = 45; i < 360; i += 90) {
	      tickmarks.append("rect").attr("id", "box" + i)
	        .attr("x", "385")
	        .attr("y", "100")
	        .attr("width", "30")
	        .attr("height", "20")
	        .attr("transform", "rotate(" + i + " 400 400)")
	        .text(i);
	      tickmarks.append("text").attr("id", "bearing" + i)
	        .attr("x", "400")
	        .attr("y", "115")
	        .attr("font-size", "80%")
	        .attr("text-anchor", "middle")
	        .attr("transform", "rotate(" + i + " 400 400)")
	        .attr("class", "text")
	        .text(dirs[0]);
	      dirs = dirs.splice(1);
	    }
	  },
	  drawSparkline: function (selector, data, width, height) {
	    if (data.length > 0) {
	      var now = Date.now();
	      var x = d3.scale.linear().domain([
	        d3.min(data, function (d) { return d.timestamp - now;}),
	        d3.max(data, function (d) {return d.timestamp - now;})])
	        .range([0, width]);
	      var y = d3.scale.linear().domain([
	        d3.min(data, function (d) {return d.value}),
	        d3.max(data, function (d) {return d.value})])
	        .range([0, height]);
	      var line = d3.svg.line()
	        .x(function (d) {return x(d.timestamp - now);})
	        .y(function (d) {return y(d.value);});
	      d3.select(selector).attr("d", line(data));
	    }
	  },
	  drawBoat: function (chart) {
	    var boat = chart.append('g').attr('id', 'boat').attr('transform', 'rotate(90 100 100) translate(150 -450) scale(2.5)')
	    boat.append('path')
	      .attr('style', 'stroke:#00ff00;stroke-width:2px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1')
	      .attr('d', 'm 0,100 c 150,-100 200,-35 200,-35 0,35 0,35 0,35')
	      .attr('class', 'boat sp');
	    boat.append('path')
	      .attr('style', 'stroke:#dd0000;stroke-width:2px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1')
	      .attr('d', 'm 200,100 c 0,35 0,35 0,35  0,0 -70,65 -200,-35')
	      .attr('class', 'boat');
	  },
	  depthFontSize: function (depth) {
	    var minFontSize = 60;
	    var maxFontSize = 300;
	    var shallowThreshold = 6;
	    var minThreshold = 3;
	    if (depth > shallowThreshold) {
	      return minFontSize
	    }
	    if (depth < minThreshold) {
	      return maxFontSize;
	    }
	    return minFontSize + (shallowThreshold - depth) / (shallowThreshold - minThreshold) * (maxFontSize - minFontSize);
	  },
	  arcForAngle: function (angle) {
	    return 'M400,400 v-300 a300,300 1 0,1 ' +
	      Math.sin(angle * Math.PI / 180) * 300 + ',' +
	      (1 - Math.cos(angle * Math.PI / 180)) * 300 + ' z';
	  },
	  rotateAnimated: function (selector, angleTo, x, y, millis) {
	    var d3g = d3.select(selector);
	    var previousTransform = d3g.attr('transform');
	    var tween = function (d, i, a) {
	      return d3.interpolateString(previousTransform, 'rotate(' + angleTo + " " + x + " " + y + ")");
	    }
	    d3g.transition().duration(this.visible ? millis : 0).attrTween('transform', tween);
	  }  
	}
	
	module.exports = SailGauge;

/***/ },
/* 7 */
/*!***********************************!*\
  !*** ./lib/baconsignalkstream.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var Bacon = __webpack_require__(/*! baconjs */ 1);
	debug = __webpack_require__(/*! debug */ 8);
	
	function StreamBundle(extractTypeFunction) {
	  this.extractTypeFunction = extractTypeFunction;
	};
	
	StreamBundle.prototype = {
	  getTypeStream: function (type) {
	    if (this[type] === undefined) {
	      this[type] = new Bacon.Bus();
	    }
	    return this[type];
	  },
	  getTypeValueStream: function (type) {
	    return this.getTypeStream(type).map('.value');
	  },
	  push: function (msg) {
	    this.getTypeStream(this.extractTypeFunction(msg)).push(msg);
	    debug('signalk:' + this.extractTypeFunction(msg))(msg.value);
	  },
	}
	
	module.exports = StreamBundle;


/***/ },
/* 8 */
/*!****************************!*\
  !*** ./~/debug/browser.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(/*! ./debug */ 9);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 9 */
/*!**************************!*\
  !*** ./~/debug/debug.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(/*! ms */ 10);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 10 */
/*!*******************************!*\
  !*** ./~/debug/~/ms/index.js ***!
  \*******************************/
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 11 */
/*!**************************!*\
  !*** ./lib/naviutils.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	var Bacon = __webpack_require__(/*! baconjs */ 1);
	
	function getTrueWindAngle(speed, windSpeed, windAngle) {
	  var apparentX = Math.cos(Math.PI / 180 * windAngle) * windSpeed;
	  var apparentY = Math.sin(Math.PI / 180 * windAngle) * windSpeed;
	  return Math.atan2(apparentY, -speed + apparentX) / (Math.PI / 180);
	};
	module.exports.getTrueWindAngle = getTrueWindAngle;
	
	function getTrueWindSpeed(speed, windSpeed, windAngle) {
	  var apparentX = Math.cos(Math.PI / 180 * windAngle) * windSpeed;
	  var apparentY = Math.sin(Math.PI / 180 * windAngle) * windSpeed;
	  return Math.sqrt(Math.pow(apparentY, 2) + Math.pow(-speed + apparentX, 2));
	};
	module.exports.getTrueWindSpeed = getTrueWindSpeed;
	
	module.exports.knots2MetersPerSecond = function (knots) {
	  return knots * 0.514444;
	};
	
	module.exports.metersPerSecond2knots = function (mps) {
	  return mps / 0.514444;
	};
	
	function toRadian(degreeAngle) {
	  return Math.PI / 180 * degreeAngle;
	};
	
	
	module.exports.createTrueWindSpeedStream = 
	  function(sogStream, apparentWindSpeedStream, apparentWindAngleStream, trueWindSpeedStream) {
	    var lastTrueWindTimestamp = trueWindSpeedStream.map(function(){return Date.now();}).toProperty(0);
	    var trueWindSpeedAvailable = Bacon.interval(5 * 1000, false).combine(
	      lastTrueWindTimestamp,
	      function(signal, lastTime) {
	       return lastTime > Date.now() - 30 * 1000;
	      });
	    var calculated = Bacon.combineWith(
	      getTrueWindSpeed,
	      sogStream, apparentWindSpeedStream, apparentWindAngleStream)
	      .filter(trueWindSpeedAvailable.not());
	    return Bacon.mergeAll(calculated, trueWindSpeedStream);
	  }
	
	module.exports.createTrueWindAngleStream = 
	  function(sogStream, apparentWindSpeedStream, apparentWindAngleStream, trueWindSpeedStream) {
	    var lastTrueWindTimestamp = trueWindSpeedStream.map(function(){return Date.now();}).toProperty(0);
	    var repeatingTimestamp = Bacon.fromPoll(5 * 1000, function(){return Date.now()});
	    var isStale = function(timestamp, now) {return timestamp < now - 30 * 1000};
	    var trueWindSpeedisStale = Bacon.combineWith(isStale, lastTrueWindTimestamp, repeatingTimestamp);
	    var calculated = Bacon.combineWith(
	      getTrueWindAngle,
	      sogStream, apparentWindSpeedStream, apparentWindAngleStream)
	      .filter(trueWindSpeedisStale);
	    return Bacon.mergeAll(calculated, trueWindSpeedStream);
	  }  
	
	/*
	sog = Bacon.interval(2000, 1);
	windspeed = Bacon.interval(2100,3)
	windAngle = Bacon.interval(2200, 90)
	truewind = Bacon.interval(10 * 1000, 5)
	module.exports.createTrueWindAngleStream(sog, windspeed, windAngle, truewind).log(' result')
	*/

/***/ },
/* 12 */
/*!*****************************!*\
  !*** ./lib/signalkutils.js ***!
  \*****************************/
/***/ function(module, exports) {

	function dispatchInTree(singleSignalK, eventHandlerTree) {
	  var branchName = Object.keys(singleSignalK)[0];
	  if (typeof eventHandlerTree[branchName] === 'function') {
	    eventHandlerTree[branchName](singleSignalK[branchName])
	  } else if (typeof eventHandlerTree[branchName] === 'undefined') {
	  } else {
	    dispatchInTree(singleSignalK[branchName], eventHandlerTree[branchName]);
	  }
	}
	function dispatch(data) {
	  dispatchInTree(data, eventHandlers);
	}
	
	module.exports.dispatchInTree = dispatchInTree;
	
	/* Walks directly down the hierarchy of a single SignalK message and if 
	  property name X is found in the array calls method handleX in the 
	  objectWithDispatchMethods*/
	function byNameDispatcher(keysArray, objectWithDispatchMethods) {
	  return function handleOrRecurse(singleSignalK) {
	    if (typeof singleSignalK === 'object' && singleSignalKx !== null) {
	    var branchName = Object.keys(singleSignalK)[0];
	    if (keysArray.indexOf(branchName) != -1) {
	      var dispatcherFunction = objectWithDispatchMethods['handle_' + branchName];
	      if (typeof dispatcherFunction === 'function') {
	        dispatcherFunction.bind(objectWithDispatchMethods);
	        dispatcherFunction.call(objectWithDispatchMethods, singleSignalK[branchName].value);
	      } else {
	        console.error("No method named handle_" + branchName + " found");
	        console.error(JSON.stringify(objectWithDispatchMethods));
	      }
	    } else {
	      handleOrRecurse(singleSignalK[branchName]);
	    }
	  }
	  }
	}
	
	module.exports.byNameDispatcher = byNameDispatcher;
	
	/*
	var keys = ['a','b'];
	var objectWithDispatchMethods = {handle_a :function(x){console.log(x + this.y)}, y: 100};
	byNameDispatcher(keys, objectWithDispatchMethods)({q:{a:{value: 77}}});
	byNameDispatcher(keys, objectWithDispatchMethods)({q:{b:{value: 77}}});
	byNameDispatcher(keys, objectWithDispatchMethods)({q:{c:{value: 77}}});
	*/


/***/ },
/* 13 */
/*!***************************************!*\
  !*** ./lib/baconslidingtimewindow.js ***!
  \***************************************/
/***/ function(module, exports) {

	Bacon.Observable.prototype.slidingTimeWindow = function (windowDuration) {
	    var addToWindow, now, withTimeStamp;
	    now = function () {
	        return Date.now();
	    };
	    withTimeStamp = function (value) {
	        return {
	            value: value,
	            timestamp: now()
	        };
	    };
	    addToWindow = function (window, value) {
	        window.push(value);
	        var ref = window[0];
	        while (ref != null && ref.timestamp < now() - windowDuration) {
	            window = window.splice(1);
	            ref = window[0];
	        }
	        return window;
	    };
	    return this.map(withTimeStamp).scan([], addToWindow);
	};


/***/ },
/* 14 */
/*!*****************************!*\
  !*** ./~/ws/lib/browser.js ***!
  \*****************************/
/***/ function(module, exports) {

	
	/**
	 * Module dependencies.
	 */
	
	var global = (function() { return this; })();
	
	/**
	 * WebSocket constructor.
	 */
	
	var WebSocket = global.WebSocket || global.MozWebSocket;
	
	/**
	 * Module exports.
	 */
	
	module.exports = WebSocket ? ws : null;
	
	/**
	 * WebSocket constructor.
	 *
	 * The third `opts` options object gets ignored in web browsers, since it's
	 * non-standard, and throws a TypeError if passed to the constructor.
	 * See: https://github.com/einaros/ws/issues/227
	 *
	 * @param {String} uri
	 * @param {Array} protocols (optional)
	 * @param {Object) opts (optional)
	 * @api public
	 */
	
	function ws(uri, protocols, opts) {
	  var instance;
	  if (protocols) {
	    instance = new WebSocket(uri, protocols);
	  } else {
	    instance = new WebSocket(uri);
	  }
	  return instance;
	}
	
	if (WebSocket) ws.prototype = WebSocket.prototype;


/***/ },
/* 15 */
/*!*************************************!*\
  !*** ../signalk-js-client/index.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var EventEmitter = __webpack_require__(/*! eventemitter3 */ 16);
	var WebSocket = __webpack_require__(/*! ws */ 17);
	var debug = __webpack_require__(/*! debug */ 18)('signalk:client');
	
	var Promise = __webpack_require__(/*! bluebird */ 21);
	var agent = __webpack_require__(/*! superagent-promise */ 24)(__webpack_require__(/*! superagent */ 25), Promise);
	
	var Qty = __webpack_require__(/*! js-quantities */ 28);
	var signalkSchema = __webpack_require__(/*! signalk-schema */ 29);
	
	var conversions = {
	  "rad": {
	    convert: Qty.swiftConverter('rad', 'deg'),
	    to: "deg"
	  },
	  "K": {
	    convert: Qty.swiftConverter("tempK", "tempC"),
	    to: "tempC"
	  }
	}
	
	
	function Client(host, port) {
	  this.host = host;
	  this.port = port;
	}
	
	
	__webpack_require__(/*! util */ 57).inherits(Client, EventEmitter);
	
	
	Client.prototype.get = function(path) {
	  return agent('GET', 'http://' + this.host + ':' + this.port + '/signalk/v1/api' + path).then(function(result) {
	    return result.res.body;
	  });
	}
	
	Client.prototype.connect = function(options) {
	  debug('connect');
	  var host = this.host;
	  var port = this.port;
	  if (options) {
	    host = options.host || host;
	    port = options.port || port;
	  }
	  if (host && port) {
	    return this.connectDelta(options.host + ":" + options.port, options, options.onData, options.onConnect, options.onDisconnect, options.onError)
	  }
	  return this.discoverAndConnect(options);
	}
	
	Client.prototype.discoverAndConnect = function(options) {
	  debug('discoverAndConnect');
	  var that = this;
	  try {
	    var mdns = __webpack_require__(/*! mdns */ 60);
	  } catch(ex) {
	    console.log("Discovery requires mdns, please install it with 'npm install mdns' or specify host and port");
	    return
	  }
	  return new Promise(function(resolve, reject) {
	    var browser = mdns.createBrowser(mdns.tcp('signalk-ws'));
	    browser.on('serviceUp', function(service) {
	      debug("Discovered signalk-ws with txtRecord:" + JSON.stringify(service.txtRecord, null, 2));
	      //TODO handle multiple discoveries
	      resolve(service);
	    });
	    debug("Starting mdns discovery");
	    browser.start();
	  }).then(function(service) {
	    that.host = service.host;
	    that.port = service.port;
	    debug("Discovered " + that.host + ":" + that.port)
	    that.emit('discovery', service);
	    return that.connectDelta(service.host + ":" + service.port, options,  options.onData, options.onConnect, options.onDisconnect, options.onError);
	  });
	}
	
	
	Client.prototype.connectDelta = function(hostname, options, callback, onConnect, onDisconnect, onError) {
	  debug("Connecting to " + hostname);
	  var url = "ws://" + hostname + "/signalk/v1/stream?stream=delta&context=self";
	  if (typeof Primus != 'undefined') {
	    debug("Using Primus");
	    var signalKStream = Primus.connect(url, {
	      reconnect: {
	        maxDelay: 15000,
	        minDelay: 500,
	        retries: Infinity
	      }
	    });
	    if (onConnect) {
	      signalKStream.on('open', onConnect);
	    }
	    var onData = options.convertToHumanUnits ?
	      function(msg) {
	        if(msg.updates) {
	          msg.updates.forEach(convertUpdateToHumanUnits)
	        }
	        callback(msg);
	      }
	    : callback;
	    signalKStream.on('data', onData);
	    return {
	      disconnect: function() {
	        signalKStream.destroy();
	        debug('Disconnected');
	      }
	    }
	  } else {
	    debug("Using ws");
	    var connection = new WebSocket(url);
	    connection.onopen = function(msg) {
	      debug("open");
	      if (onConnect) {
	        onConnect(connection)
	      } else {
	        var sub = '{"context":"vessels.self","subscribe":[{"path":"*"}]}';
	        connection.send(sub);
	      }
	    };
	    connection.onerror = function(error) {
	      debug("error:" + error);
	      if (onError) {
	        onError(error)
	      }
	    };
	    connection.onmessage = options.convertToHumanUnits ? 
	      function(msg) {
	        var msg = JSON.parse(msg.data);
	        if (msg.updates) {
	          msg.updates.forEach(convertUpdateToHumanUnits);
	        }
	        callback(msg);
	      }
	    : function(msg) {
	        callback(JSON.parse(msg.data));
	      };
	    return {
	      disconnect: function() {
	        connection.close();
	        debug('Disconnected');
	      }
	    }
	  }
	}
	
	Client.prototype.getSelf = function (host) {
	  return agent('GET', "http://" + (host || this.host + ":" + this.port) + "/signalk/v1/api/vessels/self");
	}
	
	Client.prototype.getSelfMatcher = function(host) {
	  return this.getSelf(host || this.host + ":" + this.port).then(function(result) {
	    var selfData = result.body;
	    var selfId = selfData.mmsi || selfData.uuid;
	    if (selfId) {
	      var selfContext = 'vessels.' + selfId;
	      return function(delta) {
	        return delta.context === 'self' || delta.context === 'vessels.self' || delta.context === selfContext;
	      }
	    } else {
	      return function(delta) {
	        return true;
	      }
	    }
	  });
	}  
	
	function convertUpdateToHumanUnits(update) {
	  if (update.values) {
	    update.values.forEach(convertPathValueToHumanUnits)
	  }
	}
	
	function convertPathValueToHumanUnits(pathValue) {
	  if (signalkSchema.metadata[pathValue.path] && conversions[signalkSchema.metadata[pathValue.path].units]) {
	    pathValue.value = conversions[signalkSchema.metadata[pathValue.path].units].convert(pathValue.value); 
	    pathValue.units = conversions[signalkSchema.metadata[pathValue.path].units].to;
	  }
	}
	
	
	
	module.exports = {
	  Client: Client
	}

/***/ },
/* 16 */
/*!*****************************************************!*\
  !*** ../signalk-js-client/~/eventemitter3/index.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	//
	// We store our EE objects in a plain object whose properties are event names.
	// If `Object.create(null)` is not supported we prefix the event names with a
	// `~` to make sure that the built-in object properties are not overridden or
	// used as an attack vector.
	// We also assume that `Object.create(null)` is available when the event name
	// is an ES6 Symbol.
	//
	var prefix = typeof Object.create !== 'function' ? '~' : false;
	
	/**
	 * Representation of a single EventEmitter function.
	 *
	 * @param {Function} fn Event handler to be called.
	 * @param {Mixed} context Context for function execution.
	 * @param {Boolean} once Only emit once
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}
	
	/**
	 * Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() { /* Nothing to set */ }
	
	/**
	 * Holds the assigned EventEmitters by name.
	 *
	 * @type {Object}
	 * @private
	 */
	EventEmitter.prototype._events = undefined;
	
	/**
	 * Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @param {Boolean} exists We only need to know if there are listeners.
	 * @returns {Array|Boolean}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event, exists) {
	  var evt = prefix ? prefix + event : event
	    , available = this._events && this._events[evt];
	
	  if (exists) return !!available;
	  if (!available) return [];
	  if (available.fn) return [available.fn];
	
	  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {
	    ee[i] = available[i].fn;
	  }
	
	  return ee;
	};
	
	/**
	 * Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events || !this._events[evt]) return false;
	
	  var listeners = this._events[evt]
	    , len = arguments.length
	    , args
	    , i;
	
	  if ('function' === typeof listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
	
	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }
	
	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }
	
	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;
	
	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
	
	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }
	
	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }
	
	  return true;
	};
	
	/**
	 * Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Functon} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }
	
	  return this;
	};
	
	/**
	 * Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true)
	    , evt = prefix ? prefix + event : event;
	
	  if (!this._events) this._events = prefix ? {} : Object.create(null);
	  if (!this._events[evt]) this._events[evt] = listener;
	  else {
	    if (!this._events[evt].fn) this._events[evt].push(listener);
	    else this._events[evt] = [
	      this._events[evt], listener
	    ];
	  }
	
	  return this;
	};
	
	/**
	 * Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Mixed} context Only remove listeners matching this context.
	 * @param {Boolean} once Only remove once listeners.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
	  var evt = prefix ? prefix + event : event;
	
	  if (!this._events || !this._events[evt]) return this;
	
	  var listeners = this._events[evt]
	    , events = [];
	
	  if (fn) {
	    if (listeners.fn) {
	      if (
	           listeners.fn !== fn
	        || (once && !listeners.once)
	        || (context && listeners.context !== context)
	      ) {
	        events.push(listeners);
	      }
	    } else {
	      for (var i = 0, length = listeners.length; i < length; i++) {
	        if (
	             listeners[i].fn !== fn
	          || (once && !listeners[i].once)
	          || (context && listeners[i].context !== context)
	        ) {
	          events.push(listeners[i]);
	        }
	      }
	    }
	  }
	
	  //
	  // Reset the array, or remove it completely if we have no more listeners.
	  //
	  if (events.length) {
	    this._events[evt] = events.length === 1 ? events[0] : events;
	  } else {
	    delete this._events[evt];
	  }
	
	  return this;
	};
	
	/**
	 * Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  if (!this._events) return this;
	
	  if (event) delete this._events[prefix ? prefix + event : event];
	  else this._events = prefix ? {} : Object.create(null);
	
	  return this;
	};
	
	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;
	
	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};
	
	//
	// Expose the prefix.
	//
	EventEmitter.prefixed = prefix;
	
	//
	// Expose the module.
	//
	if (true) {
	  module.exports = EventEmitter;
	}


/***/ },
/* 17 */
/*!************************************************!*\
  !*** ../signalk-js-client/~/ws/lib/browser.js ***!
  \************************************************/
/***/ function(module, exports) {

	
	/**
	 * Module dependencies.
	 */
	
	var global = (function() { return this; })();
	
	/**
	 * WebSocket constructor.
	 */
	
	var WebSocket = global.WebSocket || global.MozWebSocket;
	
	/**
	 * Module exports.
	 */
	
	module.exports = WebSocket ? ws : null;
	
	/**
	 * WebSocket constructor.
	 *
	 * The third `opts` options object gets ignored in web browsers, since it's
	 * non-standard, and throws a TypeError if passed to the constructor.
	 * See: https://github.com/einaros/ws/issues/227
	 *
	 * @param {String} uri
	 * @param {Array} protocols (optional)
	 * @param {Object) opts (optional)
	 * @api public
	 */
	
	function ws(uri, protocols, opts) {
	  var instance;
	  if (protocols) {
	    instance = new WebSocket(uri, protocols);
	  } else {
	    instance = new WebSocket(uri);
	  }
	  return instance;
	}
	
	if (WebSocket) ws.prototype = WebSocket.prototype;


/***/ },
/* 18 */
/*!***********************************************!*\
  !*** ../signalk-js-client/~/debug/browser.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(/*! ./debug */ 19);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 19 */
/*!*********************************************!*\
  !*** ../signalk-js-client/~/debug/debug.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(/*! ms */ 20);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 20 */
/*!**************************************************!*\
  !*** ../signalk-js-client/~/debug/~/ms/index.js ***!
  \**************************************************/
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 21 */
/*!**************************************************************!*\
  !*** ../signalk-js-client/~/bluebird/js/browser/bluebird.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2014 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 2.9.34
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}
	
	Promise.any = function (promises) {
	    return any(promises);
	};
	
	Promise.prototype.any = function () {
	    return any(this);
	};
	
	};
	
	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule.js");
	var Queue = _dereq_("./queue.js");
	var util = _dereq_("./util.js");
	
	function Async() {
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule =
	        schedule.isStatic ? schedule(this.drainQueues) : schedule;
	}
	
	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};
	
	Async.prototype.enableTrampoline = function() {
	    if (!this._trampolineEnabled) {
	        this._trampolineEnabled = true;
	        this._schedule = function(fn) {
	            setTimeout(fn, 0);
	        };
	    }
	};
	
	Async.prototype.haveItemsQueued = function () {
	    return this._normalQueue.length() > 0;
	};
	
	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	    }
	};
	
	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}
	
	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}
	
	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    if (schedule.isStatic) {
	        schedule = function(fn) { setTimeout(fn, 0); };
	    }
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };
	
	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };
	
	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}
	
	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};
	
	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};
	
	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._drainQueue(this._lateQueue);
	};
	
	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};
	
	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};
	
	module.exports = new Async();
	module.exports.firstLineError = firstLineError;
	
	},{"./queue.js":28,"./schedule.js":31,"./util.js":38}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
	var rejectThis = function(_, e) {
	    this._reject(e);
	};
	
	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};
	
	var bindingResolved = function(thisArg, context) {
	    if (this._isPending()) {
	        this._resolveCallback(context.target);
	    }
	};
	
	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};
	
	Promise.prototype.bind = function (thisArg) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, ret._progress, ret, context);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};
	
	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 131072;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~131072);
	    }
	};
	
	Promise.prototype._isBound = function () {
	    return (this._bitField & 131072) === 131072;
	};
	
	Promise.bind = function (thisArg, value) {
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        maybePromise._then(function() {
	            ret._resolveCallback(value);
	        }, ret._reject, ret._progress, ret, null);
	    } else {
	        ret._resolveCallback(value);
	    }
	    return ret;
	};
	};
	
	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise.js")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;
	
	},{"./promise.js":23}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}
	
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;
	
	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};
	
	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};
	
	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};
	
	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};
	
	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}
	
	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}
	
	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};
	
	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};
	
	},{"./util.js":38}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var errors = _dereq_("./errors.js");
	var async = _dereq_("./async.js");
	var CancellationError = errors.CancellationError;
	
	Promise.prototype._cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    var parent;
	    var promiseToReject = this;
	    while ((parent = promiseToReject._cancellationParent) !== undefined &&
	        parent.isCancellable()) {
	        promiseToReject = parent;
	    }
	    this._unsetCancellable();
	    promiseToReject._target()._rejectCallback(reason, false, true);
	};
	
	Promise.prototype.cancel = function (reason) {
	    if (!this.isCancellable()) return this;
	    if (reason === undefined) reason = new CancellationError();
	    async.invokeLater(this._cancel, this, reason);
	    return this;
	};
	
	Promise.prototype.cancellable = function () {
	    if (this._cancellable()) return this;
	    async.enableTrampoline();
	    this._setCancellable();
	    this._cancellationParent = undefined;
	    return this;
	};
	
	Promise.prototype.uncancellable = function () {
	    var ret = this.then();
	    ret._unsetCancellable();
	    return ret;
	};
	
	Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
	    var ret = this._then(didFulfill, didReject, didProgress,
	                         undefined, undefined);
	
	    ret._setCancellable();
	    ret._cancellationParent = undefined;
	    return ret;
	};
	};
	
	},{"./async.js":2,"./errors.js":13}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var warn;
	
	function CapturedTrace(parent) {
	    this._parent = parent;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	
	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};
	
	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
	
	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};
	
	CapturedTrace.prototype.parent = function() {
	    return this._parent;
	};
	
	CapturedTrace.prototype.hasParent = function() {
	    return this._parent !== undefined;
	};
	
	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = CapturedTrace.parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];
	
	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};
	
	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}
	
	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}
	
	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;
	
	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }
	
	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}
	
	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = stackFramePattern.test(line) ||
	            "    (No stack trace)" === line;
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}
	
	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}
	
	CapturedTrace.parseStackAndMessage = function(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	};
	
	CapturedTrace.formatAndLogError = function(error, title) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (typeof error === "object" || typeof error === "function") {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof warn === "function") {
	            warn(message);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	};
	
	CapturedTrace.unhandledRejection = function (reason) {
	    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
	};
	
	CapturedTrace.isSupported = function () {
	    return typeof captureStackTrace === "function";
	};
	
	CapturedTrace.fireRejectionEvent =
	function(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }
	
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent(name, reason, promise);
	    } catch (e) {
	        globalEventFired = true;
	        async.throwLater(e);
	    }
	
	    var domEventFired = false;
	    if (fireDomEvent) {
	        try {
	            domEventFired = fireDomEvent(name.toLowerCase(), {
	                reason: reason,
	                promise: promise
	            });
	        } catch (e) {
	            domEventFired = true;
	            async.throwLater(e);
	        }
	    }
	
	    if (!globalEventFired && !localEventFired && !domEventFired &&
	        name === "unhandledRejection") {
	        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
	    }
	};
	
	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj.toString();
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {
	
	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}
	
	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}
	
	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}
	CapturedTrace.setBounds = function(firstLineError, lastLineError) {
	    if (!CapturedTrace.isSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }
	
	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	};
	
	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit = Error.stackTraceLimit + 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;
	
	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	    var err = new Error();
	
	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }
	
	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit = Error.stackTraceLimit + 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit = Error.stackTraceLimit - 6;
	        };
	    }
	
	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;
	
	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };
	
	    return null;
	
	})([]);
	
	var fireDomEvent;
	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function(name, reason, promise) {
	            if (name === "rejectionHandled") {
	                return process.emit(name, promise);
	            } else {
	                return process.emit(name, reason, promise);
	            }
	        };
	    } else {
	        var customEventWorks = false;
	        var anyEventWorks = true;
	        try {
	            var ev = new self.CustomEvent("test");
	            customEventWorks = ev instanceof CustomEvent;
	        } catch (e) {}
	        if (!customEventWorks) {
	            try {
	                var event = document.createEvent("CustomEvent");
	                event.initCustomEvent("testingtheevent", false, true, {});
	                self.dispatchEvent(event);
	            } catch (e) {
	                anyEventWorks = false;
	            }
	        }
	        if (anyEventWorks) {
	            fireDomEvent = function(type, detail) {
	                var event;
	                if (customEventWorks) {
	                    event = new self.CustomEvent(type, {
	                        detail: detail,
	                        bubbles: false,
	                        cancelable: true
	                    });
	                } else if (self.dispatchEvent) {
	                    event = document.createEvent("CustomEvent");
	                    event.initCustomEvent(type, false, true, detail);
	                }
	
	                return event ? !self.dispatchEvent(event) : false;
	            };
	        }
	
	        var toWindowMethodNameMap = {};
	        toWindowMethodNameMap["unhandledRejection"] = ("on" +
	            "unhandledRejection").toLowerCase();
	        toWindowMethodNameMap["rejectionHandled"] = ("on" +
	            "rejectionHandled").toLowerCase();
	
	        return function(name, reason, promise) {
	            var methodName = toWindowMethodNameMap[name];
	            var method = self[methodName];
	            if (!method) return false;
	            if (name === "rejectionHandled") {
	                method.call(self, promise);
	            } else {
	                method.call(self, reason, promise);
	            }
	            return true;
	        };
	    }
	})();
	
	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    warn = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        warn = function(message) {
	            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        warn = function(message) {
	            console.warn("%c" + message, "color: red");
	        };
	    }
	}
	
	return CapturedTrace;
	};
	
	},{"./async.js":2,"./util.js":38}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util.js");
	var errors = _dereq_("./errors.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var keys = _dereq_("./es5.js").keys;
	var TypeError = errors.TypeError;
	
	function CatchFilter(instances, callback, promise) {
	    this._instances = instances;
	    this._callback = callback;
	    this._promise = promise;
	}
	
	function safePredicate(predicate, e) {
	    var safeObject = {};
	    var retfilter = tryCatch(predicate).call(safeObject, e);
	
	    if (retfilter === errorObj) return retfilter;
	
	    var safeKeys = keys(safeObject);
	    if (safeKeys.length) {
	        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
	        return errorObj;
	    }
	    return retfilter;
	}
	
	CatchFilter.prototype.doFilter = function (e) {
	    var cb = this._callback;
	    var promise = this._promise;
	    var boundTo = promise._boundValue();
	    for (var i = 0, len = this._instances.length; i < len; ++i) {
	        var item = this._instances[i];
	        var itemIsErrorType = item === Error ||
	            (item != null && item.prototype instanceof Error);
	
	        if (itemIsErrorType && e instanceof item) {
	            var ret = tryCatch(cb).call(boundTo, e);
	            if (ret === errorObj) {
	                NEXT_FILTER.e = ret.e;
	                return NEXT_FILTER;
	            }
	            return ret;
	        } else if (typeof item === "function" && !itemIsErrorType) {
	            var shouldHandle = safePredicate(item, e);
	            if (shouldHandle === errorObj) {
	                e = errorObj.e;
	                break;
	            } else if (shouldHandle) {
	                var ret = tryCatch(cb).call(boundTo, e);
	                if (ret === errorObj) {
	                    NEXT_FILTER.e = ret.e;
	                    return NEXT_FILTER;
	                }
	                return ret;
	            }
	        }
	    }
	    NEXT_FILTER.e = e;
	    return NEXT_FILTER;
	};
	
	return CatchFilter;
	};
	
	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace, isDebugging) {
	var contextStack = [];
	function Context() {
	    this._trace = new CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.push(this._trace);
	    }
	};
	
	Context.prototype._popContext = function () {
	    if (!isDebugging()) return;
	    if (this._trace !== undefined) {
	        contextStack.pop();
	    }
	};
	
	function createContext() {
	    if (isDebugging()) return new Context();
	}
	
	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	
	Promise.prototype._peekContext = peekContext;
	Promise.prototype._pushContext = Context.prototype._pushContext;
	Promise.prototype._popContext = Context.prototype._popContext;
	
	return createContext;
	};
	
	},{}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, CapturedTrace) {
	var getDomain = Promise._getDomain;
	var async = _dereq_("./async.js");
	var Warning = _dereq_("./errors.js").Warning;
	var util = _dereq_("./util.js");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var debugging = false || (util.isNode &&
	                    (!!process.env["BLUEBIRD_DEBUG"] ||
	                     process.env["NODE_ENV"] === "development"));
	
	if (debugging) {
	    async.disableTrampolineIfNecessary();
	}
	
	Promise.prototype._ignoreRejections = function() {
	    this._unsetRejectionIsUnhandled();
	    this._bitField = this._bitField | 16777216;
	};
	
	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 16777216) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};
	
	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    CapturedTrace.fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};
	
	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._getCarriedStackTrace() || this._settledValue;
	        this._setUnhandledRejectionIsNotified();
	        CapturedTrace.fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};
	
	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 524288;
	};
	
	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~524288);
	};
	
	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 524288) > 0;
	};
	
	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 2097152;
	};
	
	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~2097152);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};
	
	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 2097152) > 0;
	};
	
	Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
	    this._bitField = this._bitField | 1048576;
	    this._fulfillmentHandler0 = capturedTrace;
	};
	
	Promise.prototype._isCarryingStackTrace = function () {
	    return (this._bitField & 1048576) > 0;
	};
	
	Promise.prototype._getCarriedStackTrace = function () {
	    return this._isCarryingStackTrace()
	        ? this._fulfillmentHandler0
	        : undefined;
	};
	
	Promise.prototype._captureStackTrace = function () {
	    if (debugging) {
	        this._trace = new CapturedTrace(this._peekContext());
	    }
	    return this;
	};
	
	Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
	    if (debugging && canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = CapturedTrace.parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	};
	
	Promise.prototype._warn = function(message) {
	    var warning = new Warning(message);
	    var ctx = this._peekContext();
	    if (ctx) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = CapturedTrace.parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }
	    CapturedTrace.formatAndLogError(warning, "");
	};
	
	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
	                                 : undefined;
	};
	
	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
	                                 : undefined;
	};
	
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() &&
	        debugging === false
	   ) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
	    }
	    debugging = CapturedTrace.isSupported();
	    if (debugging) {
	        async.disableTrampolineIfNecessary();
	    }
	};
	
	Promise.hasLongStackTraces = function () {
	    return debugging && CapturedTrace.isSupported();
	};
	
	if (!CapturedTrace.isSupported()) {
	    Promise.longStackTraces = function(){};
	    debugging = false;
	}
	
	return function() {
	    return debugging;
	};
	};
	
	},{"./async.js":2,"./errors.js":13,"./util.js":38}],11:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var isPrimitive = util.isPrimitive;
	
	module.exports = function(Promise) {
	var returner = function () {
	    return this;
	};
	var thrower = function () {
	    throw this;
	};
	var returnUndefined = function() {};
	var throwUndefined = function() {
	    throw undefined;
	};
	
	var wrapper = function (value, action) {
	    if (action === 1) {
	        return function () {
	            throw value;
	        };
	    } else if (action === 2) {
	        return function () {
	            return value;
	        };
	    }
	};
	
	
	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value === undefined) return this.then(returnUndefined);
	
	    if (isPrimitive(value)) {
	        return this._then(
	            wrapper(value, 2),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(returner, undefined, undefined, value, undefined);
	};
	
	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    if (reason === undefined) return this.then(throwUndefined);
	
	    if (isPrimitive(reason)) {
	        return this._then(
	            wrapper(reason, 1),
	            undefined,
	            undefined,
	            undefined,
	            undefined
	       );
	    }
	    return this._then(thrower, undefined, undefined, reason, undefined);
	};
	};
	
	},{"./util.js":38}],12:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	
	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, null, INTERNAL);
	};
	
	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, null, INTERNAL);
	};
	};
	
	},{}],13:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util.js");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;
	
	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}
	
	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}
	
	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");
	
	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}
	
	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};
	
	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;
	
	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }
	
	}
	inherits(OperationalError, Error);
	
	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
	}
	
	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};
	
	},{"./es5.js":14,"./util.js":38}],14:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();
	
	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;
	
	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };
	
	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };
	
	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };
	
	    var ObjectFreeze = function (obj) {
	        return obj;
	    };
	
	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };
	
	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };
	
	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}
	
	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;
	
	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};
	
	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};
	
	},{}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
	var util = _dereq_("./util.js");
	var isPrimitive = util.isPrimitive;
	var thrower = util.thrower;
	
	function returnThis() {
	    return this;
	}
	function throwThis() {
	    throw this;
	}
	function return$(r) {
	    return function() {
	        return r;
	    };
	}
	function throw$(r) {
	    return function() {
	        throw r;
	    };
	}
	function promisedFinally(ret, reasonOrValue, isFulfilled) {
	    var then;
	    if (isPrimitive(reasonOrValue)) {
	        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
	    } else {
	        then = isFulfilled ? returnThis : throwThis;
	    }
	    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
	}
	
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    var ret = promise._isBound()
	                    ? handler.call(promise._boundValue())
	                    : handler();
	
	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, reasonOrValue,
	                                    promise.isFulfilled());
	        }
	    }
	
	    if (promise.isRejected()) {
	        NEXT_FILTER.e = reasonOrValue;
	        return NEXT_FILTER;
	    } else {
	        return reasonOrValue;
	    }
	}
	
	function tapHandler(value) {
	    var promise = this.promise;
	    var handler = this.handler;
	
	    var ret = promise._isBound()
	                    ? handler.call(promise._boundValue(), value)
	                    : handler(value);
	
	    if (ret !== undefined) {
	        var maybePromise = tryConvertToPromise(ret, promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            return promisedFinally(maybePromise, value, true);
	        }
	    }
	    return value;
	}
	
	Promise.prototype._passThroughHandler = function (handler, isFinally) {
	    if (typeof handler !== "function") return this.then();
	
	    var promiseAndHandler = {
	        promise: this,
	        handler: handler
	    };
	
	    return this._then(
	            isFinally ? finallyHandler : tapHandler,
	            isFinally ? finallyHandler : undefined, undefined,
	            promiseAndHandler, undefined);
	};
	
	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThroughHandler(handler, true);
	};
	
	Promise.prototype.tap = function (handler) {
	    return this._passThroughHandler(handler, false);
	};
	};
	
	},{"./util.js":38}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise) {
	var errors = _dereq_("./errors.js");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];
	
	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}
	
	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    var promise = this._promise = new Promise(INTERNAL);
	    promise._captureStackTrace();
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	}
	
	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._next(undefined);
	};
	
	PromiseSpawn.prototype._continue = function (result) {
	    if (result === errorObj) {
	        return this._promise._rejectCallback(result.e, false, true);
	    }
	
	    var value = result.value;
	    if (result.done === true) {
	        this._promise._resolveCallback(value);
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._throw(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise._then(
	            this._next,
	            this._throw,
	            undefined,
	            this,
	            null
	       );
	    }
	};
	
	PromiseSpawn.prototype._throw = function (reason) {
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	PromiseSpawn.prototype._next = function (value) {
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};
	
	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        spawn._generator = generator;
	        spawn._next(undefined);
	        return spawn.promise();
	    };
	};
	
	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    yieldHandlers.push(fn);
	};
	
	Promise.spawn = function (generatorFunction) {
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};
	
	},{"./errors.js":13,"./util.js":38}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
	var util = _dereq_("./util.js");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;
	
	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };
	
	    var caller = function(count) {
	        var values = [];
	        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
	        return new Function("holder", "                                      \n\
	            'use strict';                                                    \n\
	            var callback = holder.fn;                                        \n\
	            return callback(values);                                         \n\
	            ".replace(/values/g, values.join(", ")));
	    };
	    var thenCallbacks = [];
	    var callers = [undefined];
	    for (var i = 1; i <= 5; ++i) {
	        thenCallbacks.push(thenCallback(i));
	        callers.push(caller(i));
	    }
	
	    var Holder = function(total, fn) {
	        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
	        this.fn = fn;
	        this.total = total;
	        this.now = 0;
	    };
	
	    Holder.prototype.callers = callers;
	    Holder.prototype.checkFulfillment = function(promise) {
	        var now = this.now;
	        now++;
	        var total = this.total;
	        if (now >= total) {
	            var handler = this.callers[total];
	            promise._pushContext();
	            var ret = tryCatch(handler)(this);
	            promise._popContext();
	            if (ret === errorObj) {
	                promise._rejectCallback(ret.e, false, true);
	            } else {
	                promise._resolveCallback(ret);
	            }
	        } else {
	            this.now = now;
	        }
	    };
	
	    var reject = function (reason) {
	        this._reject(reason);
	    };
	}
	}
	
	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last < 6 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var holder = new Holder(last, fn);
	                var callbacks = thenCallbacks;
	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        if (maybePromise._isPending()) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                        } else if (maybePromise._isFulfilled()) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else {
	                            ret._reject(maybePromise._reason());
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }
	                return ret;
	            }
	        }
	    }
	    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};
	
	};
	
	},{"./util.js":38}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var getDomain = Promise._getDomain;
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var PENDING = {};
	var EMPTY_ARRAY = [];
	
	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : domain.bind(fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
	    async.invoke(init, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);
	function init() {this._init$(undefined, -2);}
	
	MappingPromiseArray.prototype._init = function () {};
	
	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;
	    if (values[index] === PENDING) {
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;
	
	        var callback = this._callback;
	        var receiver = this._promise._boundValue();
	        this._promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        this._promise._popContext();
	        if (ret === errorObj) return this._reject(ret.e);
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = PENDING;
	                return maybePromise._proxyPromiseArray(this, index);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	
	    }
	};
	
	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};
	
	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};
	
	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};
	
	function map(promises, fn, options, _filter) {
	    var limit = typeof options === "object" && options !== null
	        ? options.concurrency
	        : 0;
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter);
	}
	
	Promise.prototype.map = function (fn, options) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	
	    return map(this, fn, options, null).promise();
	};
	
	Promise.map = function (promises, fn, options, _filter) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    return map(promises, fn, options, _filter).promise();
	};
	
	
	};
	
	},{"./async.js":2,"./util.js":38}],20:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	
	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        ret._popContext();
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};
	
	Promise.attempt = Promise["try"] = function (fn, args, ctx) {
	    if (typeof fn !== "function") {
	        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value = util.isArray(args)
	        ? tryCatch(fn).apply(ctx, args)
	        : tryCatch(fn).call(ctx, args);
	    ret._popContext();
	    ret._resolveFromSyncValue(value);
	    return ret;
	};
	
	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false, true);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};
	
	},{"./util.js":38}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var target = promise._target();
	        var newReason = target._getCarriedStackTrace();
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	
	Promise.prototype.asCallback =
	Promise.prototype.nodeify = function (nodeback, options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};
	
	},{"./async.js":2,"./util.js":38}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray) {
	var util = _dereq_("./util.js");
	var async = _dereq_("./async.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	
	Promise.prototype.progressed = function (handler) {
	    return this._then(undefined, undefined, handler, undefined, undefined);
	};
	
	Promise.prototype._progress = function (progressValue) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._target()._progressUnchecked(progressValue);
	
	};
	
	Promise.prototype._progressHandlerAt = function (index) {
	    return index === 0
	        ? this._progressHandler0
	        : this[(index << 2) + index - 5 + 2];
	};
	
	Promise.prototype._doProgressWith = function (progression) {
	    var progressValue = progression.value;
	    var handler = progression.handler;
	    var promise = progression.promise;
	    var receiver = progression.receiver;
	
	    var ret = tryCatch(handler).call(receiver, progressValue);
	    if (ret === errorObj) {
	        if (ret.e != null &&
	            ret.e.name !== "StopProgressPropagation") {
	            var trace = util.canAttachTrace(ret.e)
	                ? ret.e : new Error(util.toString(ret.e));
	            promise._attachExtraTrace(trace);
	            promise._progress(ret.e);
	        }
	    } else if (ret instanceof Promise) {
	        ret._then(promise._progress, null, null, promise, undefined);
	    } else {
	        promise._progress(ret);
	    }
	};
	
	
	Promise.prototype._progressUnchecked = function (progressValue) {
	    var len = this._length();
	    var progress = this._progress;
	    for (var i = 0; i < len; i++) {
	        var handler = this._progressHandlerAt(i);
	        var promise = this._promiseAt(i);
	        if (!(promise instanceof Promise)) {
	            var receiver = this._receiverAt(i);
	            if (typeof handler === "function") {
	                handler.call(receiver, progressValue, promise);
	            } else if (receiver instanceof PromiseArray &&
	                       !receiver._isResolved()) {
	                receiver._promiseProgressed(progressValue, promise);
	            }
	            continue;
	        }
	
	        if (typeof handler === "function") {
	            async.invoke(this._doProgressWith, this, {
	                handler: handler,
	                promise: promise,
	                receiver: this._receiverAt(i),
	                value: progressValue
	            });
	        } else {
	            async.invoke(progress, promise, progressValue);
	        }
	    }
	};
	};
	
	},{"./async.js":2,"./util.js":38}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
	};
	var reflect = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	
	var util = _dereq_("./util.js");
	
	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);
	
	var async = _dereq_("./async.js");
	var errors = _dereq_("./errors.js");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {e: null};
	var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array.js")(Promise, INTERNAL,
	                                    tryConvertToPromise, apiRejection);
	var CapturedTrace = _dereq_("./captured_trace.js")();
	var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
	 /*jshint unused:false*/
	var createContext =
	    _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
	var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
	var PromiseResolver = _dereq_("./promise_resolver.js");
	var nodebackForPromise = PromiseResolver._nodebackForPromise;
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function Promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
	    }
	    if (this.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
	    }
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._progressHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settledValue = undefined;
	    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
	}
	
	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};
	
	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (typeof item === "function") {
	                catchInstances[j++] = item;
	            } else {
	                return Promise.reject(
	                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        var catchFilter = new CatchFilter(catchInstances, fn, this);
	        return this._then(undefined, catchFilter.doFilter, undefined,
	            catchFilter, undefined);
	    }
	    return this._then(undefined, fn, undefined, undefined, undefined);
	};
	
	Promise.prototype.reflect = function () {
	    return this._then(reflect, reflect, undefined, this, undefined);
	};
	
	Promise.prototype.then = function (didFulfill, didReject, didProgress) {
	    if (isDebugging() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	};
	
	Promise.prototype.done = function (didFulfill, didReject, didProgress) {
	    var promise = this._then(didFulfill, didReject, didProgress,
	        undefined, undefined);
	    promise._setIsFinal();
	};
	
	Promise.prototype.spread = function (didFulfill, didReject) {
	    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
	};
	
	Promise.prototype.isCancellable = function () {
	    return !this.isResolved() &&
	        this._cancellable();
	};
	
	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};
	
	Promise.prototype.all = function () {
	    return new PromiseArray(this).promise();
	};
	
	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};
	
	Promise.is = function (val) {
	    return val instanceof Promise;
	};
	
	Promise.fromNode = function(fn) {
	    var ret = new Promise(INTERNAL);
	    var result = tryCatch(fn)(nodebackForPromise(ret));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true, true);
	    }
	    return ret;
	};
	
	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};
	
	Promise.defer = Promise.pending = function () {
	    var promise = new Promise(INTERNAL);
	    return new PromiseResolver(promise);
	};
	
	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        var val = ret;
	        ret = new Promise(INTERNAL);
	        ret._fulfillUnchecked(val);
	    }
	    return ret;
	};
	
	Promise.resolve = Promise.fulfilled = Promise.cast;
	
	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};
	
	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var prev = async._schedule;
	    async._schedule = fn;
	    return prev;
	};
	
	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    didProgress,
	    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var ret = haveInternalData ? internalData : new Promise(INTERNAL);
	
	    if (!haveInternalData) {
	        ret._propagateFrom(this, 4 | 1);
	        ret._captureStackTrace();
	    }
	
	    var target = this._target();
	    if (target !== this) {
	        if (receiver === undefined) receiver = this._boundTo;
	        if (!haveInternalData) ret._setIsMigrated();
	    }
	
	    var callbackIndex = target._addCallbacks(didFulfill,
	                                             didReject,
	                                             didProgress,
	                                             ret,
	                                             receiver,
	                                             getDomain());
	
	    if (target._isResolved() && !target._isSettlePromisesQueued()) {
	        async.invoke(
	            target._settlePromiseAtPostResolution, target, callbackIndex);
	    }
	
	    return ret;
	};
	
	Promise.prototype._settlePromiseAtPostResolution = function (index) {
	    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
	    this._settlePromiseAt(index);
	};
	
	Promise.prototype._length = function () {
	    return this._bitField & 131071;
	};
	
	Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
	    return (this._bitField & 939524096) > 0;
	};
	
	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 536870912) === 536870912;
	};
	
	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -131072) |
	        (len & 131071);
	};
	
	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 268435456;
	};
	
	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 134217728;
	};
	
	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 536870912;
	};
	
	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 33554432;
	};
	
	Promise.prototype._isFinal = function () {
	    return (this._bitField & 33554432) > 0;
	};
	
	Promise.prototype._cancellable = function () {
	    return (this._bitField & 67108864) > 0;
	};
	
	Promise.prototype._setCancellable = function () {
	    this._bitField = this._bitField | 67108864;
	};
	
	Promise.prototype._unsetCancellable = function () {
	    this._bitField = this._bitField & (~67108864);
	};
	
	Promise.prototype._setIsMigrated = function () {
	    this._bitField = this._bitField | 4194304;
	};
	
	Promise.prototype._unsetIsMigrated = function () {
	    this._bitField = this._bitField & (~4194304);
	};
	
	Promise.prototype._isMigrated = function () {
	    return (this._bitField & 4194304) > 0;
	};
	
	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0
	        ? this._receiver0
	        : this[
	            index * 5 - 5 + 4];
	    if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};
	
	Promise.prototype._promiseAt = function (index) {
	    return index === 0
	        ? this._promise0
	        : this[index * 5 - 5 + 3];
	};
	
	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return index === 0
	        ? this._fulfillmentHandler0
	        : this[index * 5 - 5 + 0];
	};
	
	Promise.prototype._rejectionHandlerAt = function (index) {
	    return index === 0
	        ? this._rejectionHandler0
	        : this[index * 5 - 5 + 1];
	};
	
	Promise.prototype._boundValue = function() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	};
	
	Promise.prototype._migrateCallbacks = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var progress = follower._progressHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (promise instanceof Promise) promise._setIsMigrated();
	    this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
	};
	
	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    progress,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();
	
	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	
	    if (index === 0) {
	        this._promise0 = promise;
	        if (receiver !== undefined) this._receiver0 = receiver;
	        if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : domain.bind(fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : domain.bind(reject);
	        }
	        if (typeof progress === "function") {
	            this._progressHandler0 =
	                domain === null ? progress : domain.bind(progress);
	        }
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promise;
	        this[base + 4] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : domain.bind(fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : domain.bind(reject);
	        }
	        if (typeof progress === "function") {
	            this[base + 2] =
	                domain === null ? progress : domain.bind(progress);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};
	
	Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
	    var index = this._length();
	
	    if (index >= 131071 - 5) {
	        index = 0;
	        this._setLength(0);
	    }
	    if (index === 0) {
	        this._promise0 = promiseSlotValue;
	        this._receiver0 = receiver;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] = promiseSlotValue;
	        this[base + 4] = receiver;
	    }
	    this._setLength(index + 1);
	};
	
	Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
	    this._setProxyHandlers(promiseArray, index);
	};
	
	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false, true);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);
	
	    var propagationFlags = 1 | (shouldBind ? 4 : 0);
	    this._propagateFrom(maybePromise, propagationFlags);
	    var promise = maybePromise._target();
	    if (promise._isPending()) {
	        var len = this._length();
	        for (var i = 0; i < len; ++i) {
	            promise._migrateCallbacks(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (promise._isFulfilled()) {
	        this._fulfillUnchecked(promise._value());
	    } else {
	        this._rejectUnchecked(promise._reason(),
	            promise._getCarriedStackTrace());
	    }
	};
	
	Promise.prototype._rejectCallback =
	function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
	    if (!shouldNotMarkOriginatingFromRejection) {
	        util.markAsOriginatingFromRejection(reason);
	    }
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason, hasStack ? undefined : trace);
	};
	
	Promise.prototype._resolveFromResolver = function (resolver) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = tryCatch(resolver)(function(value) {
	        if (promise === null) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }, function (reason) {
	        if (promise === null) return;
	        promise._rejectCallback(reason, synchronous);
	        promise = null;
	    });
	    synchronous = false;
	    this._popContext();
	
	    if (r !== undefined && r === errorObj && promise !== null) {
	        promise._rejectCallback(r.e, true, true);
	        promise = null;
	    }
	};
	
	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    if (promise._isRejected()) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY && !this._isRejected()) {
	        x = tryCatch(handler).apply(this._boundValue(), value);
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    promise._popContext();
	
	    if (x === errorObj || x === promise || x === NEXT_FILTER) {
	        var err = x === promise ? makeSelfResolutionError() : x.e;
	        promise._rejectCallback(err, false, true);
	    } else {
	        promise._resolveCallback(x);
	    }
	};
	
	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};
	
	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};
	
	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};
	
	Promise.prototype._cleanValues = function () {
	    if (this._cancellable()) {
	        this._cancellationParent = undefined;
	    }
	};
	
	Promise.prototype._propagateFrom = function (parent, flags) {
	    if ((flags & 1) > 0 && parent._cancellable()) {
	        this._setCancellable();
	        this._cancellationParent = parent;
	    }
	    if ((flags & 4) > 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	};
	
	Promise.prototype._fulfill = function (value) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._fulfillUnchecked(value);
	};
	
	Promise.prototype._reject = function (reason, carriedStackTrace) {
	    if (this._isFollowingOrFulfilledOrRejected()) return;
	    this._rejectUnchecked(reason, carriedStackTrace);
	};
	
	Promise.prototype._settlePromiseAt = function (index) {
	    var promise = this._promiseAt(index);
	    var isPromise = promise instanceof Promise;
	
	    if (isPromise && promise._isMigrated()) {
	        promise._unsetIsMigrated();
	        return async.invoke(this._settlePromiseAt, this, index);
	    }
	    var handler = this._isFulfilled()
	        ? this._fulfillmentHandlerAt(index)
	        : this._rejectionHandlerAt(index);
	
	    var carriedStackTrace =
	        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
	    var value = this._settledValue;
	    var receiver = this._receiverAt(index);
	    this._clearCallbackDataAtIndex(index);
	
	    if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof PromiseArray) {
	        if (!receiver._isResolved()) {
	            if (this._isFulfilled()) {
	                receiver._promiseFulfilled(value, promise);
	            }
	            else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (this._isFulfilled()) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value, carriedStackTrace);
	        }
	    }
	
	    if (index >= 4 && (index & 31) === 4)
	        async.invokeLater(this._setLength, this, 0);
	};
	
	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    if (index === 0) {
	        if (!this._isCarryingStackTrace()) {
	            this._fulfillmentHandler0 = undefined;
	        }
	        this._rejectionHandler0 =
	        this._progressHandler0 =
	        this._receiver0 =
	        this._promise0 = undefined;
	    } else {
	        var base = index * 5 - 5;
	        this[base + 3] =
	        this[base + 4] =
	        this[base + 0] =
	        this[base + 1] =
	        this[base + 2] = undefined;
	    }
	};
	
	Promise.prototype._isSettlePromisesQueued = function () {
	    return (this._bitField &
	            -1073741824) === -1073741824;
	};
	
	Promise.prototype._setSettlePromisesQueued = function () {
	    this._bitField = this._bitField | -1073741824;
	};
	
	Promise.prototype._unsetSettlePromisesQueued = function () {
	    this._bitField = this._bitField & (~-1073741824);
	};
	
	Promise.prototype._queueSettlePromises = function() {
	    async.settlePromises(this);
	    this._setSettlePromisesQueued();
	};
	
	Promise.prototype._fulfillUnchecked = function (value) {
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err, undefined);
	    }
	    this._setFulfilled();
	    this._settledValue = value;
	    this._cleanValues();
	
	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    }
	};
	
	Promise.prototype._rejectUncheckedCheckError = function (reason) {
	    var trace = util.ensureErrorObject(reason);
	    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
	};
	
	Promise.prototype._rejectUnchecked = function (reason, trace) {
	    if (reason === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._rejectUnchecked(err);
	    }
	    this._setRejected();
	    this._settledValue = reason;
	    this._cleanValues();
	
	    if (this._isFinal()) {
	        async.throwLater(function(e) {
	            if ("stack" in e) {
	                async.invokeFirst(
	                    CapturedTrace.unhandledRejection, undefined, e);
	            }
	            throw e;
	        }, trace === undefined ? reason : trace);
	        return;
	    }
	
	    if (trace !== undefined && trace !== reason) {
	        this._setCarriedStackTrace(trace);
	    }
	
	    if (this._length() > 0) {
	        this._queueSettlePromises();
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};
	
	Promise.prototype._settlePromises = function () {
	    this._unsetSettlePromisesQueued();
	    var len = this._length();
	    for (var i = 0; i < len; i++) {
	        this._settlePromiseAt(i);
	    }
	};
	
	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);
	
	_dereq_("./progress.js")(Promise, PromiseArray);
	_dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
	_dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
	_dereq_("./direct_resolve.js")(Promise);
	_dereq_("./synchronous_inspection.js")(Promise);
	_dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
	Promise.Promise = Promise;
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./cancel.js')(Promise);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
	_dereq_('./settle.js')(Promise, PromiseArray);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./any.js')(Promise);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./timers.js')(Promise, INTERNAL);
	_dereq_('./filter.js')(Promise, INTERNAL);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._progressHandler0 = value;                                         
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	        p._settledValue = value;                                             
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
	    return Promise;                                                          
	
	};
	
	},{"./any.js":1,"./async.js":2,"./bind.js":3,"./call_get.js":5,"./cancel.js":6,"./captured_trace.js":7,"./catch_filter.js":8,"./context.js":9,"./debuggability.js":10,"./direct_resolve.js":11,"./each.js":12,"./errors.js":13,"./filter.js":15,"./finally.js":16,"./generators.js":17,"./join.js":18,"./map.js":19,"./method.js":20,"./nodeify.js":21,"./progress.js":22,"./promise_array.js":24,"./promise_resolver.js":25,"./promisify.js":26,"./props.js":27,"./race.js":29,"./reduce.js":30,"./settle.js":32,"./some.js":33,"./synchronous_inspection.js":34,"./thenables.js":35,"./timers.js":36,"./using.js":37,"./util.js":38}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection) {
	var util = _dereq_("./util.js");
	var isArray = util.isArray;
	
	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}
	
	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    var parent;
	    if (values instanceof Promise) {
	        parent = values;
	        promise._propagateFrom(parent, 1 | 4);
	    }
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	PromiseArray.prototype.length = function () {
	    return this._length;
	};
	
	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};
	
	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        this._values = values;
	        if (values._isFulfilled()) {
	            values = values._value();
	            if (!isArray(values)) {
	                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	                this.__hardReject__(err);
	                return;
	            }
	        } else if (values._isPending()) {
	            values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	            return;
	        } else {
	            this._reject(values._reason());
	            return;
	        }
	    } else if (!isArray(values)) {
	        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
	        return;
	    }
	
	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var promise = this._promise;
	    for (var i = 0; i < len; ++i) {
	        var isResolved = this._isResolved();
	        var maybePromise = tryConvertToPromise(values[i], promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (isResolved) {
	                maybePromise._ignoreRejections();
	            } else if (maybePromise._isPending()) {
	                maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                this._promiseFulfilled(maybePromise._value(), i);
	            } else {
	                this._promiseRejected(maybePromise._reason(), i);
	            }
	        } else if (!isResolved) {
	            this._promiseFulfilled(maybePromise, i);
	        }
	    }
	};
	
	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};
	
	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};
	
	PromiseArray.prototype.__hardReject__ =
	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false, true);
	};
	
	PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
	    this._promise._progress({
	        index: index,
	        value: progressValue
	    });
	};
	
	
	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};
	
	PromiseArray.prototype._promiseRejected = function (reason, index) {
	    this._totalResolved++;
	    this._reject(reason);
	};
	
	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};
	
	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};
	
	return PromiseArray;
	};
	
	},{"./util.js":38}],25:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util.js");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors.js");
	var TimeoutError = errors.TimeoutError;
	var OperationalError = errors.OperationalError;
	var haveGetters = util.haveGetters;
	var es5 = _dereq_("./es5.js");
	
	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}
	
	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}
	
	function nodebackForPromise(promise) {
	    return function(err, value) {
	        if (promise === null) return;
	
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (arguments.length > 2) {
	            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
	            promise._fulfill(args);
	        } else {
	            promise._fulfill(value);
	        }
	
	        promise = null;
	    };
	}
	
	
	var PromiseResolver;
	if (!haveGetters) {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	        this.asCallback = nodebackForPromise(promise);
	        this.callback = this.asCallback;
	    };
	}
	else {
	    PromiseResolver = function (promise) {
	        this.promise = promise;
	    };
	}
	if (haveGetters) {
	    var prop = {
	        get: function() {
	            return nodebackForPromise(this.promise);
	        }
	    };
	    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
	    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
	}
	
	PromiseResolver._nodebackForPromise = nodebackForPromise;
	
	PromiseResolver.prototype.toString = function () {
	    return "[object PromiseResolver]";
	};
	
	PromiseResolver.prototype.resolve =
	PromiseResolver.prototype.fulfill = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._resolveCallback(value);
	};
	
	PromiseResolver.prototype.reject = function (reason) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._rejectCallback(reason);
	};
	
	PromiseResolver.prototype.progress = function (value) {
	    if (!(this instanceof PromiseResolver)) {
	        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
	    }
	    this.promise._progress(value);
	};
	
	PromiseResolver.prototype.cancel = function (err) {
	    this.promise.cancel(err);
	};
	
	PromiseResolver.prototype.timeout = function () {
	    this.reject(new TimeoutError("timeout"));
	};
	
	PromiseResolver.prototype.isResolved = function () {
	    return this.promise.isResolved();
	};
	
	PromiseResolver.prototype.toJSON = function () {
	    return this.promise.toJSON();
	};
	
	module.exports = PromiseResolver;
	
	},{"./errors.js":13,"./es5.js":14,"./util.js":38}],26:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util.js");
	var nodebackForPromise = _dereq_("./promise_resolver.js")
	    ._nodebackForPromise;
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
	
	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};
	
	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}
	
	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}
	
	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}
	
	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}
	
	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};
	
	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};
	
	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};
	
	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};
	
	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};
	
	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;
	
	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }
	
	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }
	
	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }
	
	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL","'use strict';                            \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise);                      \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	        "
	        .replace("Parameters", parameterDeclaration(newParameterCount))
	        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode))(
	            Promise,
	            fn,
	            receiver,
	            withAppended,
	            maybeWrapAsError,
	            nodebackForPromise,
	            util.tryCatch,
	            util.errorObj,
	            util.notEnumerableProp,
	            INTERNAL
	        );
	};
	}
	
	function makeNodePromisifiedClosure(callback, receiver, _, fn) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}
	
	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;
	
	function promisifyAll(obj, suffix, filter, promisifier) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);
	
	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        obj[promisifiedKey] = promisifier === makeNodePromisified
	                ? makeNodePromisified(key, THIS, key, fn, suffix)
	                : promisifier(fn, function() {
	                    return makeNodePromisified(key, THIS, key, fn, suffix);
	                });
	    }
	    util.toFastProperties(obj);
	    return obj;
	}
	
	function promisify(callback, receiver) {
	    return makeNodePromisified(callback, receiver, undefined, callback);
	}
	
	Promise.promisify = function (fn, receiver) {
	    if (typeof fn !== "function") {
	        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};
	
	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
	    }
	    options = Object(options);
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;
	
	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
	    }
	
	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier);
	            promisifyAll(value, suffix, filter, promisifier);
	        }
	    }
	
	    return promisifyAll(target, suffix, filter, promisifier);
	};
	};
	
	
	},{"./errors":13,"./promise_resolver.js":25,"./util.js":38}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util.js");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5.js");
	
	function PropertiesPromiseArray(obj) {
	    var keys = es5.keys(obj);
	    var len = keys.length;
	    var values = new Array(len * 2);
	    for (var i = 0; i < len; ++i) {
	        var key = keys[i];
	        values[i] = obj[key];
	        values[i + len] = key;
	    }
	    this.constructor$(values);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);
	
	PropertiesPromiseArray.prototype._init = function () {
	    this._init$(undefined, -3) ;
	};
	
	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val = {};
	        var keyOffset = this.length();
	        for (var i = 0, len = this.length(); i < len; ++i) {
	            val[this._values[i + keyOffset]] = this._values[i];
	        }
	        this._resolve(val);
	    }
	};
	
	PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
	    this._promise._progress({
	        key: this._values[index + this.length()],
	        value: value
	    });
	};
	
	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};
	
	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};
	
	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);
	
	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }
	
	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 4);
	    }
	    return ret;
	}
	
	Promise.prototype.props = function () {
	    return props(this);
	};
	
	Promise.props = function (promises) {
	    return props(promises);
	};
	};
	
	},{"./es5.js":14,"./util.js":38}],28:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}
	
	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}
	
	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};
	
	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};
	
	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};
	
	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};
	
	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};
	
	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];
	
	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};
	
	Queue.prototype.length = function () {
	    return this._length;
	};
	
	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};
	
	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};
	
	module.exports = Queue;
	
	},{}],29:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var isArray = _dereq_("./util.js").isArray;
	
	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};
	
	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);
	
	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else if (!isArray(promises)) {
	        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
	    }
	
	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 4 | 1);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];
	
	        if (val === undefined && !(i in promises)) {
	            continue;
	        }
	
	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}
	
	Promise.race = function (promises) {
	    return race(promises, undefined);
	};
	
	Promise.prototype.race = function () {
	    return race(this, undefined);
	};
	
	};
	
	},{"./util.js":38}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL) {
	var getDomain = Promise._getDomain;
	var async = _dereq_("./async.js");
	var util = _dereq_("./util.js");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	function ReductionPromiseArray(promises, fn, accum, _each) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    this._preservedValues = _each === INTERNAL ? [] : null;
	    this._zerothIsAccum = (accum === undefined);
	    this._gotAccum = false;
	    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
	    this._valuesPhase = undefined;
	    var maybePromise = tryConvertToPromise(accum, this._promise);
	    var rejected = false;
	    var isPromise = maybePromise instanceof Promise;
	    if (isPromise) {
	        maybePromise = maybePromise._target();
	        if (maybePromise._isPending()) {
	            maybePromise._proxyPromiseArray(this, -1);
	        } else if (maybePromise._isFulfilled()) {
	            accum = maybePromise._value();
	            this._gotAccum = true;
	        } else {
	            this._reject(maybePromise._reason());
	            rejected = true;
	        }
	    }
	    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
	    var domain = getDomain();
	    this._callback = domain === null ? fn : domain.bind(fn);
	    this._accum = accum;
	    if (!rejected) async.invoke(init, this, undefined);
	}
	function init() {
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);
	
	ReductionPromiseArray.prototype._init = function () {};
	
	ReductionPromiseArray.prototype._resolveEmptyArray = function () {
	    if (this._gotAccum || this._zerothIsAccum) {
	        this._resolve(this._preservedValues !== null
	                        ? [] : this._accum);
	    }
	};
	
	ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    values[index] = value;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var isEach = preservedValues !== null;
	    var gotAccum = this._gotAccum;
	    var valuesPhase = this._valuesPhase;
	    var valuesPhaseIndex;
	    if (!valuesPhase) {
	        valuesPhase = this._valuesPhase = new Array(length);
	        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
	            valuesPhase[valuesPhaseIndex] = 0;
	        }
	    }
	    valuesPhaseIndex = valuesPhase[index];
	
	    if (index === 0 && this._zerothIsAccum) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	        valuesPhase[index] = ((valuesPhaseIndex === 0)
	            ? 1 : 2);
	    } else if (index === -1) {
	        this._accum = value;
	        this._gotAccum = gotAccum = true;
	    } else {
	        if (valuesPhaseIndex === 0) {
	            valuesPhase[index] = 1;
	        } else {
	            valuesPhase[index] = 2;
	            this._accum = value;
	        }
	    }
	    if (!gotAccum) return;
	
	    var callback = this._callback;
	    var receiver = this._promise._boundValue();
	    var ret;
	
	    for (var i = this._reducingIndex; i < length; ++i) {
	        valuesPhaseIndex = valuesPhase[i];
	        if (valuesPhaseIndex === 2) {
	            this._reducingIndex = i + 1;
	            continue;
	        }
	        if (valuesPhaseIndex !== 1) return;
	        value = values[i];
	        this._promise._pushContext();
	        if (isEach) {
	            preservedValues.push(value);
	            ret = tryCatch(callback).call(receiver, value, i, length);
	        }
	        else {
	            ret = tryCatch(callback)
	                .call(receiver, this._accum, value, i, length);
	        }
	        this._promise._popContext();
	
	        if (ret === errorObj) return this._reject(ret.e);
	
	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            if (maybePromise._isPending()) {
	                valuesPhase[i] = 4;
	                return maybePromise._proxyPromiseArray(this, i);
	            } else if (maybePromise._isFulfilled()) {
	                ret = maybePromise._value();
	            } else {
	                return this._reject(maybePromise._reason());
	            }
	        }
	
	        this._reducingIndex = i + 1;
	        this._accum = ret;
	    }
	
	    this._resolve(isEach ? preservedValues : this._accum);
	};
	
	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}
	
	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};
	
	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};
	};
	
	},{"./async.js":2,"./util.js":38}],31:[function(_dereq_,module,exports){
	"use strict";
	var schedule;
	var util = _dereq_("./util");
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
	};
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            window.navigator.standalone)) {
	    schedule = function(fn) {
	        var div = document.createElement("div");
	        var observer = new MutationObserver(fn);
	        observer.observe(div, {attributes: true});
	        return function() { div.classList.toggle("foo"); };
	    };
	    schedule.isStatic = true;
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;
	
	},{"./util":38}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util.js");
	
	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);
	
	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	    }
	};
	
	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 268435456;
	    ret._settledValue = value;
	    this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 134217728;
	    ret._settledValue = reason;
	    this._promiseResolved(index, ret);
	};
	
	Promise.settle = function (promises) {
	    return new SettledPromiseArray(promises).promise();
	};
	
	Promise.prototype.settle = function () {
	    return new SettledPromiseArray(this).promise();
	};
	};
	
	},{"./util.js":38}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util.js");
	var RangeError = _dereq_("./errors.js").RangeError;
	var AggregateError = _dereq_("./errors.js").AggregateError;
	var isArray = util.isArray;
	
	
	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);
	
	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};
	
	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};
	
	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};
	
	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};
	
	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};
	
	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	    }
	
	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            e.push(this._values[i]);
	        }
	        this._reject(e);
	    }
	};
	
	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};
	
	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};
	
	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};
	
	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};
	
	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};
	
	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};
	
	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};
	
	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}
	
	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};
	
	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};
	
	Promise._SomePromiseArray = SomePromiseArray;
	};
	
	},{"./errors.js":13,"./util.js":38}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValue = promise._settledValue;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValue = undefined;
	    }
	}
	
	PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return this._settledValue;
	};
	
	PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    return this._settledValue;
	};
	
	PromiseInspection.prototype.isFulfilled =
	Promise.prototype._isFulfilled = function () {
	    return (this._bitField & 268435456) > 0;
	};
	
	PromiseInspection.prototype.isRejected =
	Promise.prototype._isRejected = function () {
	    return (this._bitField & 134217728) > 0;
	};
	
	PromiseInspection.prototype.isPending =
	Promise.prototype._isPending = function () {
	    return (this._bitField & 402653184) === 0;
	};
	
	PromiseInspection.prototype.isResolved =
	Promise.prototype._isResolved = function () {
	    return (this._bitField & 402653184) > 0;
	};
	
	Promise.prototype.isPending = function() {
	    return this._target()._isPending();
	};
	
	Promise.prototype.isRejected = function() {
	    return this._target()._isRejected();
	};
	
	Promise.prototype.isFulfilled = function() {
	    return this._target()._isFulfilled();
	};
	
	Promise.prototype.isResolved = function() {
	    return this._target()._isResolved();
	};
	
	Promise.prototype._value = function() {
	    return this._settledValue;
	};
	
	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue;
	};
	
	Promise.prototype.value = function() {
	    var target = this._target();
	    if (!target.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
	    }
	    return target._settledValue;
	};
	
	Promise.prototype.reason = function() {
	    var target = this._target();
	    if (!target.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
	    }
	    target._unsetRejectionIsUnhandled();
	    return target._settledValue;
	};
	
	
	Promise.PromiseInspection = PromiseInspection;
	};
	
	},{}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var errorObj = util.errorObj;
	var isObject = util.isObject;
	
	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) {
	            return obj;
	        }
	        else if (isAnyBluebirdPromise(obj)) {
	            var ret = new Promise(INTERNAL);
	            obj._then(
	                ret._fulfillUnchecked,
	                ret._rejectUncheckedCheckError,
	                ret._progressUnchecked,
	                ret,
	                null
	            );
	            return ret;
	        }
	        var then = util.tryCatch(getThen)(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}
	
	function getThen(obj) {
	    return obj.then;
	}
	
	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    return hasProp.call(obj, "_promise0");
	}
	
	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x,
	                                        resolveFromThenable,
	                                        rejectFromThenable,
	                                        progressFromThenable);
	    synchronous = false;
	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }
	
	    function resolveFromThenable(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }
	
	    function rejectFromThenable(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	
	    function progressFromThenable(value) {
	        if (!promise) return;
	        if (typeof promise._progress === "function") {
	            promise._progress(value);
	        }
	    }
	    return ret;
	}
	
	return tryConvertToPromise;
	};
	
	},{"./util.js":38}],36:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util.js");
	var TimeoutError = Promise.TimeoutError;
	
	var afterTimeout = function (promise, message) {
	    if (!promise.isPending()) return;
	    if (typeof message !== "string") {
	        message = "operation timed out";
	    }
	    var err = new TimeoutError(message);
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._cancel(err);
	};
	
	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (value, ms) {
	    if (ms === undefined) {
	        ms = value;
	        value = undefined;
	        var ret = new Promise(INTERNAL);
	        setTimeout(function() { ret._fulfill(); }, ms);
	        return ret;
	    }
	    ms = +ms;
	    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
	};
	
	Promise.prototype.delay = function (ms) {
	    return delay(this, ms);
	};
	
	function successClear(value) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    return value;
	}
	
	function failureClear(reason) {
	    var handle = this;
	    if (handle instanceof Number) handle = +handle;
	    clearTimeout(handle);
	    throw reason;
	}
	
	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret = this.then().cancellable();
	    ret._cancellationParent = this;
	    var handle = setTimeout(function timeoutTimeout() {
	        afterTimeout(ret, message);
	    }, ms);
	    return ret._then(successClear, failureClear, undefined, handle, undefined);
	};
	
	};
	
	},{"./util.js":38}],37:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext) {
	    var TypeError = _dereq_("./errors.js").TypeError;
	    var inherits = _dereq_("./util.js").inherits;
	    var PromiseInspection = Promise.PromiseInspection;
	
	    function inspectionMapper(inspections) {
	        var len = inspections.length;
	        for (var i = 0; i < len; ++i) {
	            var inspection = inspections[i];
	            if (inspection.isRejected()) {
	                return Promise.reject(inspection.error());
	            }
	            inspections[i] = inspection._settledValue;
	        }
	        return inspections;
	    }
	
	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }
	
	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = Promise.defer();
	        function iterator() {
	            if (i >= len) return ret.resolve();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret.promise;
	    }
	
	    function disposerSuccess(value) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = value;
	        inspection._bitField = 268435456;
	        return dispose(this, inspection).thenReturn(value);
	    }
	
	    function disposerFail(reason) {
	        var inspection = new PromiseInspection();
	        inspection._settledValue = reason;
	        inspection._bitField = 134217728;
	        return dispose(this, inspection).thenThrow(reason);
	    }
	
	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }
	
	    Disposer.prototype.data = function () {
	        return this._data;
	    };
	
	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };
	
	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return null;
	    };
	
	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== null
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };
	
	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };
	
	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);
	
	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };
	
	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }
	
	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
	        len--;
	        var resources = new Array(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = arguments[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }
	
	        var promise = Promise.settle(resources)
	            .then(inspectionMapper)
	            .then(function(vals) {
	                promise._pushContext();
	                var ret;
	                try {
	                    ret = fn.apply(undefined, vals);
	                } finally {
	                    promise._popContext();
	                }
	                return ret;
	            })
	            ._then(
	                disposerSuccess, disposerFail, undefined, resources, undefined);
	        resources.promise = promise;
	        return promise;
	    };
	
	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 262144;
	        this._disposer = disposer;
	    };
	
	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 262144) > 0;
	    };
	
	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };
	
	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~262144);
	        this._disposer = undefined;
	    };
	
	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };
	
	};
	
	},{"./errors.js":13,"./util.js":38}],38:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5.js");
	var canEvaluate = typeof navigator == "undefined";
	var haveGetters = (function(){
	    try {
	        var o = {};
	        es5.defineProperty(o, "f", {
	            get: function () {
	                return 3;
	            }
	        });
	        return o.f === 3;
	    }
	    catch (e) {
	        return false;
	    }
	
	})();
	
	var errorObj = {e: {}};
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	
	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;
	
	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};
	
	
	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";
	
	}
	
	function isObject(value) {
	    return !isPrimitive(value);
	}
	
	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;
	
	    return new Error(safeToString(maybeError));
	}
	
	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}
	
	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);
	
	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}
	
	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}
	
	function thrower(r) {
	    throw r;
	}
	
	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];
	
	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };
	
	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];
	
	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }
	
	})();
	
	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);
	
	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
	
	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}
	
	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function f() {}
	    f.prototype = obj;
	    var l = 8;
	    while (l--) new f();
	    return obj;
	    eval(obj);
	}
	
	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}
	
	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}
	
	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}
	
	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}
	
	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}
	
	function canAttachTrace(obj) {
	    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
	}
	
	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();
	
	function classString(obj) {
	    return {}.toString.call(obj);
	}
	
	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}
	
	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    haveGetters: haveGetters,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]"
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();
	
	if (ret.isNode) ret.toFastProperties(process);
	
	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;
	
	},{"./es5.js":14}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 22), (function() { return this; }()), __webpack_require__(/*! (webpack)/~/node-libs-browser/~/timers-browserify/main.js */ 23).setImmediate))

/***/ },
/* 22 */
/*!**********************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/process/browser.js ***!
  \**********************************************************/
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 23 */
/*!*****************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/timers-browserify/main.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(/*! process/browser.js */ 22).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/timers-browserify/main.js */ 23).setImmediate, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/timers-browserify/main.js */ 23).clearImmediate))

/***/ },
/* 24 */
/*!**********************************************************!*\
  !*** ../signalk-js-client/~/superagent-promise/index.js ***!
  \**********************************************************/
/***/ function(module, exports) {

	/**
	 * Promise wrapper for superagent
	 */
	
	function wrap(superagent, Promise) {
	  /**
	   * Request object similar to superagent.Request, but with end() returning
	   * a promise.
	   */
	  function PromiseRequest() {
	    superagent.Request.apply(this, arguments);
	  }
	
	  // Inherit form superagent.Request
	  PromiseRequest.prototype = Object.create(superagent.Request.prototype);
	
	  /** Send request and get a promise that `end` was emitted */
	  PromiseRequest.prototype.end = function(cb) {
	    var _end = superagent.Request.prototype.end;
	    var self = this;
	
	    return new Promise(function(accept, reject) {
	      _end.call(self, function(err, response) {
	        if (cb) {
	          cb(err, response);
	        }
	
	        if (err) {
	          reject(err);
	        } else {
	          accept(response);
	        }
	      });
	    });
	  };
	
	  /** Provide a more promise-y interface */
	  PromiseRequest.prototype.then = function(resolve, reject) {
	    var _end = superagent.Request.prototype.end;
	    var self = this;
	
	    return new Promise(function(accept, reject) {
	      _end.call(self, function(err, response) {
	        if (err) {
	          reject(err);
	        } else {
	          accept(response);
	        }
	      });
	    }).then(resolve, reject);
	  };
	
	  /**
	   * Request builder with same interface as superagent.
	   * It is convenient to import this as `request` in place of superagent.
	   */
	  var request = function(method, url) {
	    return new PromiseRequest(method, url);
	  };
	
	  /** Helper for making an options request */
	  request.options = function(url) {
	    return request('OPTIONS', url);
	  }
	
	  /** Helper for making a head request */
	  request.head = function(url, data) {
	    var req = request('HEAD', url);
	    if (data) {
	      req.send(data);
	    }
	    return req;
	  };
	
	  /** Helper for making a get request */
	  request.get = function(url, data) {
	    var req = request('GET', url);
	    if (data) {
	      req.query(data);
	    }
	    return req;
	  };
	
	  /** Helper for making a post request */
	  request.post = function(url, data) {
	    var req = request('POST', url);
	    if (data) {
	      req.send(data);
	    }
	    return req;
	  };
	
	  /** Helper for making a put request */
	  request.put = function(url, data) {
	    var req = request('PUT', url);
	    if (data) {
	      req.send(data);
	    }
	    return req;
	  };
	
	  /** Helper for making a patch request */
	  request.patch = function(url, data) {
	    var req = request('PATCH', url);
	    if (data) {
	      req.send(data);
	    }
	    return req;
	  };
	
	  /** Helper for making a delete request */
	  request.del = function(url) {
	    return request('DELETE', url);
	  };
	
	  // Export the request builder
	  return request;
	}
	
	module.exports = wrap;


/***/ },
/* 25 */
/*!*******************************************************!*\
  !*** ../signalk-js-client/~/superagent/lib/client.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Module dependencies.
	 */
	
	var Emitter = __webpack_require__(/*! emitter */ 26);
	var reduce = __webpack_require__(/*! reduce */ 27);
	
	/**
	 * Root reference for iframes.
	 */
	
	var root = 'undefined' == typeof window
	  ? (this || self)
	  : window;
	
	/**
	 * Noop.
	 */
	
	function noop(){};
	
	/**
	 * Check if `obj` is a host object,
	 * we don't want to serialize these :)
	 *
	 * TODO: future proof, move to compoent land
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api private
	 */
	
	function isHost(obj) {
	  var str = {}.toString.call(obj);
	
	  switch (str) {
	    case '[object File]':
	    case '[object Blob]':
	    case '[object FormData]':
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Determine XHR.
	 */
	
	request.getXHR = function () {
	  if (root.XMLHttpRequest
	      && (!root.location || 'file:' != root.location.protocol
	          || !root.ActiveXObject)) {
	    return new XMLHttpRequest;
	  } else {
	    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
	    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
	    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
	    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
	  }
	  return false;
	};
	
	/**
	 * Removes leading and trailing whitespace, added to support IE.
	 *
	 * @param {String} s
	 * @return {String}
	 * @api private
	 */
	
	var trim = ''.trim
	  ? function(s) { return s.trim(); }
	  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };
	
	/**
	 * Check if `obj` is an object.
	 *
	 * @param {Object} obj
	 * @return {Boolean}
	 * @api private
	 */
	
	function isObject(obj) {
	  return obj === Object(obj);
	}
	
	/**
	 * Serialize the given `obj`.
	 *
	 * @param {Object} obj
	 * @return {String}
	 * @api private
	 */
	
	function serialize(obj) {
	  if (!isObject(obj)) return obj;
	  var pairs = [];
	  for (var key in obj) {
	    if (null != obj[key]) {
	      pairs.push(encodeURIComponent(key)
	        + '=' + encodeURIComponent(obj[key]));
	    }
	  }
	  return pairs.join('&');
	}
	
	/**
	 * Expose serialization method.
	 */
	
	 request.serializeObject = serialize;
	
	 /**
	  * Parse the given x-www-form-urlencoded `str`.
	  *
	  * @param {String} str
	  * @return {Object}
	  * @api private
	  */
	
	function parseString(str) {
	  var obj = {};
	  var pairs = str.split('&');
	  var parts;
	  var pair;
	
	  for (var i = 0, len = pairs.length; i < len; ++i) {
	    pair = pairs[i];
	    parts = pair.split('=');
	    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
	  }
	
	  return obj;
	}
	
	/**
	 * Expose parser.
	 */
	
	request.parseString = parseString;
	
	/**
	 * Default MIME type map.
	 *
	 *     superagent.types.xml = 'application/xml';
	 *
	 */
	
	request.types = {
	  html: 'text/html',
	  json: 'application/json',
	  xml: 'application/xml',
	  urlencoded: 'application/x-www-form-urlencoded',
	  'form': 'application/x-www-form-urlencoded',
	  'form-data': 'application/x-www-form-urlencoded'
	};
	
	/**
	 * Default serialization map.
	 *
	 *     superagent.serialize['application/xml'] = function(obj){
	 *       return 'generated xml here';
	 *     };
	 *
	 */
	
	 request.serialize = {
	   'application/x-www-form-urlencoded': serialize,
	   'application/json': JSON.stringify
	 };
	
	 /**
	  * Default parsers.
	  *
	  *     superagent.parse['application/xml'] = function(str){
	  *       return { object parsed from str };
	  *     };
	  *
	  */
	
	request.parse = {
	  'application/x-www-form-urlencoded': parseString,
	  'application/json': JSON.parse
	};
	
	/**
	 * Parse the given header `str` into
	 * an object containing the mapped fields.
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api private
	 */
	
	function parseHeader(str) {
	  var lines = str.split(/\r?\n/);
	  var fields = {};
	  var index;
	  var line;
	  var field;
	  var val;
	
	  lines.pop(); // trailing CRLF
	
	  for (var i = 0, len = lines.length; i < len; ++i) {
	    line = lines[i];
	    index = line.indexOf(':');
	    field = line.slice(0, index).toLowerCase();
	    val = trim(line.slice(index + 1));
	    fields[field] = val;
	  }
	
	  return fields;
	}
	
	/**
	 * Return the mime type for the given `str`.
	 *
	 * @param {String} str
	 * @return {String}
	 * @api private
	 */
	
	function type(str){
	  return str.split(/ *; */).shift();
	};
	
	/**
	 * Return header field parameters.
	 *
	 * @param {String} str
	 * @return {Object}
	 * @api private
	 */
	
	function params(str){
	  return reduce(str.split(/ *; */), function(obj, str){
	    var parts = str.split(/ *= */)
	      , key = parts.shift()
	      , val = parts.shift();
	
	    if (key && val) obj[key] = val;
	    return obj;
	  }, {});
	};
	
	/**
	 * Initialize a new `Response` with the given `xhr`.
	 *
	 *  - set flags (.ok, .error, etc)
	 *  - parse header
	 *
	 * Examples:
	 *
	 *  Aliasing `superagent` as `request` is nice:
	 *
	 *      request = superagent;
	 *
	 *  We can use the promise-like API, or pass callbacks:
	 *
	 *      request.get('/').end(function(res){});
	 *      request.get('/', function(res){});
	 *
	 *  Sending data can be chained:
	 *
	 *      request
	 *        .post('/user')
	 *        .send({ name: 'tj' })
	 *        .end(function(res){});
	 *
	 *  Or passed to `.send()`:
	 *
	 *      request
	 *        .post('/user')
	 *        .send({ name: 'tj' }, function(res){});
	 *
	 *  Or passed to `.post()`:
	 *
	 *      request
	 *        .post('/user', { name: 'tj' })
	 *        .end(function(res){});
	 *
	 * Or further reduced to a single call for simple cases:
	 *
	 *      request
	 *        .post('/user', { name: 'tj' }, function(res){});
	 *
	 * @param {XMLHTTPRequest} xhr
	 * @param {Object} options
	 * @api private
	 */
	
	function Response(req, options) {
	  options = options || {};
	  this.req = req;
	  this.xhr = this.req.xhr;
	  // responseText is accessible only if responseType is '' or 'text' and on older browsers
	  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
	     ? this.xhr.responseText
	     : null;
	  this.statusText = this.req.xhr.statusText;
	  this.setStatusProperties(this.xhr.status);
	  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
	  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
	  // getResponseHeader still works. so we get content-type even if getting
	  // other headers fails.
	  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
	  this.setHeaderProperties(this.header);
	  this.body = this.req.method != 'HEAD'
	    ? this.parseBody(this.text ? this.text : this.xhr.response)
	    : null;
	}
	
	/**
	 * Get case-insensitive `field` value.
	 *
	 * @param {String} field
	 * @return {String}
	 * @api public
	 */
	
	Response.prototype.get = function(field){
	  return this.header[field.toLowerCase()];
	};
	
	/**
	 * Set header related properties:
	 *
	 *   - `.type` the content type without params
	 *
	 * A response of "Content-Type: text/plain; charset=utf-8"
	 * will provide you with a `.type` of "text/plain".
	 *
	 * @param {Object} header
	 * @api private
	 */
	
	Response.prototype.setHeaderProperties = function(header){
	  // content-type
	  var ct = this.header['content-type'] || '';
	  this.type = type(ct);
	
	  // params
	  var obj = params(ct);
	  for (var key in obj) this[key] = obj[key];
	};
	
	/**
	 * Parse the given body `str`.
	 *
	 * Used for auto-parsing of bodies. Parsers
	 * are defined on the `superagent.parse` object.
	 *
	 * @param {String} str
	 * @return {Mixed}
	 * @api private
	 */
	
	Response.prototype.parseBody = function(str){
	  var parse = request.parse[this.type];
	  return parse && str && (str.length || str instanceof Object)
	    ? parse(str)
	    : null;
	};
	
	/**
	 * Set flags such as `.ok` based on `status`.
	 *
	 * For example a 2xx response will give you a `.ok` of __true__
	 * whereas 5xx will be __false__ and `.error` will be __true__. The
	 * `.clientError` and `.serverError` are also available to be more
	 * specific, and `.statusType` is the class of error ranging from 1..5
	 * sometimes useful for mapping respond colors etc.
	 *
	 * "sugar" properties are also defined for common cases. Currently providing:
	 *
	 *   - .noContent
	 *   - .badRequest
	 *   - .unauthorized
	 *   - .notAcceptable
	 *   - .notFound
	 *
	 * @param {Number} status
	 * @api private
	 */
	
	Response.prototype.setStatusProperties = function(status){
	  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
	  if (status === 1223) {
	    status = 204;
	  }
	
	  var type = status / 100 | 0;
	
	  // status / class
	  this.status = status;
	  this.statusType = type;
	
	  // basics
	  this.info = 1 == type;
	  this.ok = 2 == type;
	  this.clientError = 4 == type;
	  this.serverError = 5 == type;
	  this.error = (4 == type || 5 == type)
	    ? this.toError()
	    : false;
	
	  // sugar
	  this.accepted = 202 == status;
	  this.noContent = 204 == status;
	  this.badRequest = 400 == status;
	  this.unauthorized = 401 == status;
	  this.notAcceptable = 406 == status;
	  this.notFound = 404 == status;
	  this.forbidden = 403 == status;
	};
	
	/**
	 * Return an `Error` representative of this response.
	 *
	 * @return {Error}
	 * @api public
	 */
	
	Response.prototype.toError = function(){
	  var req = this.req;
	  var method = req.method;
	  var url = req.url;
	
	  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
	  var err = new Error(msg);
	  err.status = this.status;
	  err.method = method;
	  err.url = url;
	
	  return err;
	};
	
	/**
	 * Expose `Response`.
	 */
	
	request.Response = Response;
	
	/**
	 * Initialize a new `Request` with the given `method` and `url`.
	 *
	 * @param {String} method
	 * @param {String} url
	 * @api public
	 */
	
	function Request(method, url) {
	  var self = this;
	  Emitter.call(this);
	  this._query = this._query || [];
	  this.method = method;
	  this.url = url;
	  this.header = {};
	  this._header = {};
	  this.on('end', function(){
	    var err = null;
	    var res = null;
	
	    try {
	      res = new Response(self);
	    } catch(e) {
	      err = new Error('Parser is unable to parse the response');
	      err.parse = true;
	      err.original = e;
	      return self.callback(err);
	    }
	
	    self.emit('response', res);
	
	    if (err) {
	      return self.callback(err, res);
	    }
	
	    if (res.status >= 200 && res.status < 300) {
	      return self.callback(err, res);
	    }
	
	    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
	    new_err.original = err;
	    new_err.response = res;
	    new_err.status = res.status;
	
	    self.callback(new_err, res);
	  });
	}
	
	/**
	 * Mixin `Emitter`.
	 */
	
	Emitter(Request.prototype);
	
	/**
	 * Allow for extension
	 */
	
	Request.prototype.use = function(fn) {
	  fn(this);
	  return this;
	}
	
	/**
	 * Set timeout to `ms`.
	 *
	 * @param {Number} ms
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.timeout = function(ms){
	  this._timeout = ms;
	  return this;
	};
	
	/**
	 * Clear previous timeout.
	 *
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.clearTimeout = function(){
	  this._timeout = 0;
	  clearTimeout(this._timer);
	  return this;
	};
	
	/**
	 * Abort the request, and clear potential timeout.
	 *
	 * @return {Request}
	 * @api public
	 */
	
	Request.prototype.abort = function(){
	  if (this.aborted) return;
	  this.aborted = true;
	  this.xhr.abort();
	  this.clearTimeout();
	  this.emit('abort');
	  return this;
	};
	
	/**
	 * Set header `field` to `val`, or multiple fields with one object.
	 *
	 * Examples:
	 *
	 *      req.get('/')
	 *        .set('Accept', 'application/json')
	 *        .set('X-API-Key', 'foobar')
	 *        .end(callback);
	 *
	 *      req.get('/')
	 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
	 *        .end(callback);
	 *
	 * @param {String|Object} field
	 * @param {String} val
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.set = function(field, val){
	  if (isObject(field)) {
	    for (var key in field) {
	      this.set(key, field[key]);
	    }
	    return this;
	  }
	  this._header[field.toLowerCase()] = val;
	  this.header[field] = val;
	  return this;
	};
	
	/**
	 * Remove header `field`.
	 *
	 * Example:
	 *
	 *      req.get('/')
	 *        .unset('User-Agent')
	 *        .end(callback);
	 *
	 * @param {String} field
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.unset = function(field){
	  delete this._header[field.toLowerCase()];
	  delete this.header[field];
	  return this;
	};
	
	/**
	 * Get case-insensitive header `field` value.
	 *
	 * @param {String} field
	 * @return {String}
	 * @api private
	 */
	
	Request.prototype.getHeader = function(field){
	  return this._header[field.toLowerCase()];
	};
	
	/**
	 * Set Content-Type to `type`, mapping values from `request.types`.
	 *
	 * Examples:
	 *
	 *      superagent.types.xml = 'application/xml';
	 *
	 *      request.post('/')
	 *        .type('xml')
	 *        .send(xmlstring)
	 *        .end(callback);
	 *
	 *      request.post('/')
	 *        .type('application/xml')
	 *        .send(xmlstring)
	 *        .end(callback);
	 *
	 * @param {String} type
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.type = function(type){
	  this.set('Content-Type', request.types[type] || type);
	  return this;
	};
	
	/**
	 * Set Accept to `type`, mapping values from `request.types`.
	 *
	 * Examples:
	 *
	 *      superagent.types.json = 'application/json';
	 *
	 *      request.get('/agent')
	 *        .accept('json')
	 *        .end(callback);
	 *
	 *      request.get('/agent')
	 *        .accept('application/json')
	 *        .end(callback);
	 *
	 * @param {String} accept
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.accept = function(type){
	  this.set('Accept', request.types[type] || type);
	  return this;
	};
	
	/**
	 * Set Authorization field value with `user` and `pass`.
	 *
	 * @param {String} user
	 * @param {String} pass
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.auth = function(user, pass){
	  var str = btoa(user + ':' + pass);
	  this.set('Authorization', 'Basic ' + str);
	  return this;
	};
	
	/**
	* Add query-string `val`.
	*
	* Examples:
	*
	*   request.get('/shoes')
	*     .query('size=10')
	*     .query({ color: 'blue' })
	*
	* @param {Object|String} val
	* @return {Request} for chaining
	* @api public
	*/
	
	Request.prototype.query = function(val){
	  if ('string' != typeof val) val = serialize(val);
	  if (val) this._query.push(val);
	  return this;
	};
	
	/**
	 * Write the field `name` and `val` for "multipart/form-data"
	 * request bodies.
	 *
	 * ``` js
	 * request.post('/upload')
	 *   .field('foo', 'bar')
	 *   .end(callback);
	 * ```
	 *
	 * @param {String} name
	 * @param {String|Blob|File} val
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.field = function(name, val){
	  if (!this._formData) this._formData = new root.FormData();
	  this._formData.append(name, val);
	  return this;
	};
	
	/**
	 * Queue the given `file` as an attachment to the specified `field`,
	 * with optional `filename`.
	 *
	 * ``` js
	 * request.post('/upload')
	 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
	 *   .end(callback);
	 * ```
	 *
	 * @param {String} field
	 * @param {Blob|File} file
	 * @param {String} filename
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.attach = function(field, file, filename){
	  if (!this._formData) this._formData = new root.FormData();
	  this._formData.append(field, file, filename);
	  return this;
	};
	
	/**
	 * Send `data`, defaulting the `.type()` to "json" when
	 * an object is given.
	 *
	 * Examples:
	 *
	 *       // querystring
	 *       request.get('/search')
	 *         .end(callback)
	 *
	 *       // multiple data "writes"
	 *       request.get('/search')
	 *         .send({ search: 'query' })
	 *         .send({ range: '1..5' })
	 *         .send({ order: 'desc' })
	 *         .end(callback)
	 *
	 *       // manual json
	 *       request.post('/user')
	 *         .type('json')
	 *         .send('{"name":"tj"})
	 *         .end(callback)
	 *
	 *       // auto json
	 *       request.post('/user')
	 *         .send({ name: 'tj' })
	 *         .end(callback)
	 *
	 *       // manual x-www-form-urlencoded
	 *       request.post('/user')
	 *         .type('form')
	 *         .send('name=tj')
	 *         .end(callback)
	 *
	 *       // auto x-www-form-urlencoded
	 *       request.post('/user')
	 *         .type('form')
	 *         .send({ name: 'tj' })
	 *         .end(callback)
	 *
	 *       // defaults to x-www-form-urlencoded
	  *      request.post('/user')
	  *        .send('name=tobi')
	  *        .send('species=ferret')
	  *        .end(callback)
	 *
	 * @param {String|Object} data
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.send = function(data){
	  var obj = isObject(data);
	  var type = this.getHeader('Content-Type');
	
	  // merge
	  if (obj && isObject(this._data)) {
	    for (var key in data) {
	      this._data[key] = data[key];
	    }
	  } else if ('string' == typeof data) {
	    if (!type) this.type('form');
	    type = this.getHeader('Content-Type');
	    if ('application/x-www-form-urlencoded' == type) {
	      this._data = this._data
	        ? this._data + '&' + data
	        : data;
	    } else {
	      this._data = (this._data || '') + data;
	    }
	  } else {
	    this._data = data;
	  }
	
	  if (!obj || isHost(data)) return this;
	  if (!type) this.type('json');
	  return this;
	};
	
	/**
	 * Invoke the callback with `err` and `res`
	 * and handle arity check.
	 *
	 * @param {Error} err
	 * @param {Response} res
	 * @api private
	 */
	
	Request.prototype.callback = function(err, res){
	  var fn = this._callback;
	  this.clearTimeout();
	  fn(err, res);
	};
	
	/**
	 * Invoke callback with x-domain error.
	 *
	 * @api private
	 */
	
	Request.prototype.crossDomainError = function(){
	  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');
	  err.crossDomain = true;
	  this.callback(err);
	};
	
	/**
	 * Invoke callback with timeout error.
	 *
	 * @api private
	 */
	
	Request.prototype.timeoutError = function(){
	  var timeout = this._timeout;
	  var err = new Error('timeout of ' + timeout + 'ms exceeded');
	  err.timeout = timeout;
	  this.callback(err);
	};
	
	/**
	 * Enable transmission of cookies with x-domain requests.
	 *
	 * Note that for this to work the origin must not be
	 * using "Access-Control-Allow-Origin" with a wildcard,
	 * and also must set "Access-Control-Allow-Credentials"
	 * to "true".
	 *
	 * @api public
	 */
	
	Request.prototype.withCredentials = function(){
	  this._withCredentials = true;
	  return this;
	};
	
	/**
	 * Initiate request, invoking callback `fn(res)`
	 * with an instanceof `Response`.
	 *
	 * @param {Function} fn
	 * @return {Request} for chaining
	 * @api public
	 */
	
	Request.prototype.end = function(fn){
	  var self = this;
	  var xhr = this.xhr = request.getXHR();
	  var query = this._query.join('&');
	  var timeout = this._timeout;
	  var data = this._formData || this._data;
	
	  // store callback
	  this._callback = fn || noop;
	
	  // state change
	  xhr.onreadystatechange = function(){
	    if (4 != xhr.readyState) return;
	
	    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
	    // result in the error "Could not complete the operation due to error c00c023f"
	    var status;
	    try { status = xhr.status } catch(e) { status = 0; }
	
	    if (0 == status) {
	      if (self.timedout) return self.timeoutError();
	      if (self.aborted) return;
	      return self.crossDomainError();
	    }
	    self.emit('end');
	  };
	
	  // progress
	  var handleProgress = function(e){
	    if (e.total > 0) {
	      e.percent = e.loaded / e.total * 100;
	    }
	    self.emit('progress', e);
	  };
	  if (this.hasListeners('progress')) {
	    xhr.onprogress = handleProgress;
	  }
	  try {
	    if (xhr.upload && this.hasListeners('progress')) {
	      xhr.upload.onprogress = handleProgress;
	    }
	  } catch(e) {
	    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
	    // Reported here:
	    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
	  }
	
	  // timeout
	  if (timeout && !this._timer) {
	    this._timer = setTimeout(function(){
	      self.timedout = true;
	      self.abort();
	    }, timeout);
	  }
	
	  // querystring
	  if (query) {
	    query = request.serializeObject(query);
	    this.url += ~this.url.indexOf('?')
	      ? '&' + query
	      : '?' + query;
	  }
	
	  // initiate request
	  xhr.open(this.method, this.url, true);
	
	  // CORS
	  if (this._withCredentials) xhr.withCredentials = true;
	
	  // body
	  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
	    // serialize stuff
	    var contentType = this.getHeader('Content-Type');
	    var serialize = request.serialize[contentType ? contentType.split(';')[0] : ''];
	    if (serialize) data = serialize(data);
	  }
	
	  // set header fields
	  for (var field in this.header) {
	    if (null == this.header[field]) continue;
	    xhr.setRequestHeader(field, this.header[field]);
	  }
	
	  // send stuff
	  this.emit('request', this);
	  xhr.send(data);
	  return this;
	};
	
	/**
	 * Faux promise support
	 *
	 * @param {Function} fulfill
	 * @param {Function} reject
	 * @return {Request}
	 */
	
	Request.prototype.then = function (fulfill, reject) {
	  return this.end(function(err, res) {
	    err ? reject(err) : fulfill(res);
	  });
	}
	
	/**
	 * Expose `Request`.
	 */
	
	request.Request = Request;
	
	/**
	 * Issue a request:
	 *
	 * Examples:
	 *
	 *    request('GET', '/users').end(callback)
	 *    request('/users').end(callback)
	 *    request('/users', callback)
	 *
	 * @param {String} method
	 * @param {String|Function} url or callback
	 * @return {Request}
	 * @api public
	 */
	
	function request(method, url) {
	  // callback
	  if ('function' == typeof url) {
	    return new Request('GET', method).end(url);
	  }
	
	  // url first
	  if (1 == arguments.length) {
	    return new Request('GET', method);
	  }
	
	  return new Request(method, url);
	}
	
	/**
	 * GET `url` with optional callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed|Function} data or fn
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */
	
	request.get = function(url, data, fn){
	  var req = request('GET', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.query(data);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * HEAD `url` with optional callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed|Function} data or fn
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */
	
	request.head = function(url, data, fn){
	  var req = request('HEAD', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * DELETE `url` with optional callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */
	
	request.del = function(url, fn){
	  var req = request('DELETE', url);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * PATCH `url` with optional `data` and callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed} data
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */
	
	request.patch = function(url, data, fn){
	  var req = request('PATCH', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * POST `url` with optional `data` and callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed} data
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */
	
	request.post = function(url, data, fn){
	  var req = request('POST', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * PUT `url` with optional `data` and callback `fn(res)`.
	 *
	 * @param {String} url
	 * @param {Mixed|Function} data or fn
	 * @param {Function} fn
	 * @return {Request}
	 * @api public
	 */
	
	request.put = function(url, data, fn){
	  var req = request('PUT', url);
	  if ('function' == typeof data) fn = data, data = null;
	  if (data) req.send(data);
	  if (fn) req.end(fn);
	  return req;
	};
	
	/**
	 * Expose `request`.
	 */
	
	module.exports = request;


/***/ },
/* 26 */
/*!**********************************************************************!*\
  !*** ../signalk-js-client/~/superagent/~/component-emitter/index.js ***!
  \**********************************************************************/
/***/ function(module, exports) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	module.exports = Emitter;
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks[event] = this._callbacks[event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  var self = this;
	  this._callbacks = this._callbacks || {};
	
	  function on() {
	    self.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks[event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks[event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	  var args = [].slice.call(arguments, 1)
	    , callbacks = this._callbacks[event];
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks[event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 27 */
/*!*********************************************************************!*\
  !*** ../signalk-js-client/~/superagent/~/reduce-component/index.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	
	/**
	 * Reduce `arr` with `fn`.
	 *
	 * @param {Array} arr
	 * @param {Function} fn
	 * @param {Mixed} initial
	 *
	 * TODO: combatible error handling?
	 */
	
	module.exports = function(arr, fn, initial){  
	  var idx = 0;
	  var len = arr.length;
	  var curr = arguments.length == 3
	    ? initial
	    : arr[idx++];
	
	  while (idx < len) {
	    curr = fn.call(null, curr, arr[idx], ++idx, arr);
	  }
	  
	  return curr;
	};

/***/ },
/* 28 */
/*!**************************************************************!*\
  !*** ../signalk-js-client/~/js-quantities/src/quantities.js ***!
  \**************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/*!
	Copyright © 2006-2007 Kevin C. Olbrich
	Copyright © 2010-2013 LIM SAS (http://lim.eu) - Julien Sanchez
	
	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	*/
	/*jshint eqeqeq:true, immed:true, undef:true */
	/*global module:false, define:false */
	(function (root, factory) {
	    "use strict";
	
	    if (true) {
	        // Node. Does not work with strict CommonJS, but
	        // only CommonJS-like enviroments that support module.exports,
	        // like Node.
	        module.exports = factory();
	    } else if (typeof define === "function" && define.amd) {
	        // AMD. Register as an anonymous module.
	        define(factory);
	    } else {
	        // Browser globals
	        root.Qty = factory();
	    }
	}(this, function() {
	  "use strict";
	
	  var UNITS = {
	    /* prefixes */
	    "<googol>" : [["googol"], 1e100, "prefix"],
	    "<kibi>"  :  [["Ki","Kibi","kibi"], Math.pow(2,10), "prefix"],
	    "<mebi>"  :  [["Mi","Mebi","mebi"], Math.pow(2,20), "prefix"],
	    "<gibi>"  :  [["Gi","Gibi","gibi"], Math.pow(2,30), "prefix"],
	    "<tebi>"  :  [["Ti","Tebi","tebi"], Math.pow(2,40), "prefix"],
	    "<pebi>"  :  [["Pi","Pebi","pebi"], Math.pow(2,50), "prefix"],
	    "<exi>"   :  [["Ei","Exi","exi"], Math.pow(2,60), "prefix"],
	    "<zebi>"  :  [["Zi","Zebi","zebi"], Math.pow(2,70), "prefix"],
	    "<yebi>"  :  [["Yi","Yebi","yebi"], Math.pow(2,80), "prefix"],
	    "<yotta>" :  [["Y","Yotta","yotta"], 1e24, "prefix"],
	    "<zetta>" :  [["Z","Zetta","zetta"], 1e21, "prefix"],
	    "<exa>"   :  [["E","Exa","exa"], 1e18, "prefix"],
	    "<peta>"  :  [["P","Peta","peta"], 1e15, "prefix"],
	    "<tera>"  :  [["T","Tera","tera"], 1e12, "prefix"],
	    "<giga>"  :  [["G","Giga","giga"], 1e9, "prefix"],
	    "<mega>"  :  [["M","Mega","mega"], 1e6, "prefix"],
	    "<kilo>"  :  [["k","kilo"], 1e3, "prefix"],
	    "<hecto>" :  [["h","Hecto","hecto"], 1e2, "prefix"],
	    "<deca>"  :  [["da","Deca","deca","deka"], 1e1, "prefix"],
	    "<deci>"  :  [["d","Deci","deci"], 1e-1, "prefix"],
	    "<centi>"  : [["c","Centi","centi"], 1e-2, "prefix"],
	    "<milli>" :  [["m","Milli","milli"], 1e-3, "prefix"],
	    "<micro>"  : [
	      ["u","\u03BC"/*µ as greek letter*/,"\u00B5"/*µ as micro sign*/,"Micro","mc","micro"],
	      1e-6,
	      "prefix"
	    ],
	    "<nano>"  :  [["n","Nano","nano"], 1e-9, "prefix"],
	    "<pico>"  :  [["p","Pico","pico"], 1e-12, "prefix"],
	    "<femto>" :  [["f","Femto","femto"], 1e-15, "prefix"],
	    "<atto>"  :  [["a","Atto","atto"], 1e-18, "prefix"],
	    "<zepto>" :  [["z","Zepto","zepto"], 1e-21, "prefix"],
	    "<yocto>" :  [["y","Yocto","yocto"], 1e-24, "prefix"],
	
	    "<1>"     :  [["1", "<1>"], 1, ""],
	    /* length units */
	    "<meter>" :  [["m","meter","meters","metre","metres"], 1.0, "length", ["<meter>"] ],
	    "<inch>"  :  [["in","inch","inches","\""], 0.0254, "length", ["<meter>"]],
	    "<foot>"  :  [["ft","foot","feet","'"], 0.3048, "length", ["<meter>"]],
	    "<yard>"  :  [["yd","yard","yards"], 0.9144, "length", ["<meter>"]],
	    "<mile>"  :  [["mi","mile","miles"], 1609.344, "length", ["<meter>"]],
	    "<naut-mile>" : [["nmi"], 1852, "length", ["<meter>"]],
	    "<league>":  [["league","leagues"], 4828, "length", ["<meter>"]],
	    "<furlong>": [["furlong","furlongs"], 201.2, "length", ["<meter>"]],
	    "<rod>"   :  [["rd","rod","rods"], 5.029, "length", ["<meter>"]],
	    "<mil>"   :  [["mil","mils"], 0.0000254, "length", ["<meter>"]],
	    "<angstrom>"  :[["ang","angstrom","angstroms"], 1e-10, "length", ["<meter>"]],
	    "<fathom>" : [["fathom","fathoms"], 1.829, "length", ["<meter>"]],
	    "<pica>"  : [["pica","picas"], 0.00423333333, "length", ["<meter>"]],
	    "<point>" : [["pt","point","points"], 0.000352777778, "length", ["<meter>"]],
	    "<redshift>" : [["z","red-shift"], 1.302773e26, "length", ["<meter>"]],
	    "<AU>"    : [["AU","astronomical-unit"], 149597900000, "length", ["<meter>"]],
	    "<light-second>":[["ls","light-second"], 299792500, "length", ["<meter>"]],
	    "<light-minute>":[["lmin","light-minute"], 17987550000, "length", ["<meter>"]],
	    "<light-year>" : [["ly","light-year"], 9460528000000000, "length", ["<meter>"]],
	    "<parsec>"  : [["pc","parsec","parsecs"], 30856780000000000, "length", ["<meter>"]],
	
	    /* mass */
	    "<kilogram>" : [["kg","kilogram","kilograms"], 1.0, "mass", ["<kilogram>"]],
	    "<AMU>" : [["u","AMU","amu"], 6.0221415e26, "mass", ["<kilogram>"]],
	    "<dalton>" : [["Da","Dalton","Daltons","dalton","daltons"], 6.0221415e26, "mass", ["<kilogram>"]],
	    "<slug>" : [["slug","slugs"], 14.5939029, "mass", ["<kilogram>"]],
	    "<short-ton>" : [["tn","ton"], 907.18474, "mass", ["<kilogram>"]],
	    "<metric-ton>":[["tonne"], 1000, "mass", ["<kilogram>"]],
	    "<carat>" : [["ct","carat","carats"], 0.0002, "mass", ["<kilogram>"]],
	    "<pound>" : [["lbs","lb","pound","pounds","#"], 0.45359237, "mass", ["<kilogram>"]],
	    "<ounce>" : [["oz","ounce","ounces"], 0.0283495231, "mass", ["<kilogram>"]],
	    "<gram>"    :  [["g","gram","grams","gramme","grammes"], 1e-3, "mass", ["<kilogram>"]],
	    "<grain>" : [["grain","grains","gr"], 6.479891e-5, "mass", ["<kilogram>"]],
	    "<dram>"  : [["dram","drams","dr"], 0.0017718452, "mass",["<kilogram>"]],
	    "<stone>" : [["stone","stones","st"],6.35029318, "mass",["<kilogram>"]],
	
	    /* area */
	    "<hectare>":[["hectare"], 10000, "area", ["<meter>","<meter>"]],
	    "<acre>":[["acre","acres"], 4046.85642, "area", ["<meter>","<meter>"]],
	    "<sqft>":[["sqft"], 1, "area", ["<feet>","<feet>"]],
	
	    /* volume */
	    "<liter>" : [["l","L","liter","liters","litre","litres"], 0.001, "volume", ["<meter>","<meter>","<meter>"]],
	    "<gallon>":  [["gal","gallon","gallons"], 0.0037854118, "volume", ["<meter>","<meter>","<meter>"]],
	    "<quart>":  [["qt","quart","quarts"], 0.00094635295, "volume", ["<meter>","<meter>","<meter>"]],
	    "<pint>":  [["pt","pint","pints"], 0.000473176475, "volume", ["<meter>","<meter>","<meter>"]],
	    "<cup>":  [["cu","cup","cups"], 0.000236588238, "volume", ["<meter>","<meter>","<meter>"]],
	    "<fluid-ounce>":  [["floz","fluid-ounce","fluid-ounces"], 2.95735297e-5, "volume", ["<meter>","<meter>","<meter>"]],
	    "<tablespoon>":  [["tbs","tablespoon","tablespoons"], 1.47867648e-5, "volume", ["<meter>","<meter>","<meter>"]],
	    "<teaspoon>":  [["tsp","teaspoon","teaspoons"], 4.92892161e-6, "volume", ["<meter>","<meter>","<meter>"]],
	    "<bushel>":  [["bu","bsh","bushel","bushels"], 0.035239072, "volume", ["<meter>","<meter>","<meter>"]],
	
	    /* speed */
	    "<kph>" : [["kph"], 0.277777778, "speed", ["<meter>"], ["<second>"]],
	    "<mph>" : [["mph"], 0.44704, "speed", ["<meter>"], ["<second>"]],
	    "<knot>" : [["kt","kn","kts","knot","knots"], 0.514444444, "speed", ["<meter>"], ["<second>"]],
	    "<fps>"  : [["fps"], 0.3048, "speed", ["<meter>"], ["<second>"]],
	
	    /* acceleration */
	    "<gee>" : [["gee"], 9.80665, "acceleration", ["<meter>"], ["<second>","<second>"]],
	
	    /* temperature_difference */
	    "<kelvin>" : [["degK","kelvin"], 1.0, "temperature", ["<kelvin>"]],
	    "<celsius>" : [["degC","celsius","celsius","centigrade"], 1.0, "temperature", ["<kelvin>"]],
	    "<fahrenheit>" : [["degF","fahrenheit"], 5/9, "temperature", ["<kelvin>"]],
	    "<rankine>" : [["degR","rankine"], 5/9, "temperature", ["<kelvin>"]],
	    "<temp-K>"  : [["tempK"], 1.0, "temperature", ["<temp-K>"]],
	    "<temp-C>"  : [["tempC"], 1.0, "temperature", ["<temp-K>"]],
	    "<temp-F>"  : [["tempF"], 5/9, "temperature", ["<temp-K>"]],
	    "<temp-R>"  : [["tempR"], 5/9, "temperature", ["<temp-K>"]],
	
	    /* time */
	    "<second>":  [["s","sec","secs","second","seconds"], 1.0, "time", ["<second>"]],
	    "<minute>":  [["min","mins","minute","minutes"], 60.0, "time", ["<second>"]],
	    "<hour>":  [["h","hr","hrs","hour","hours"], 3600.0, "time", ["<second>"]],
	    "<day>":  [["d","day","days"], 3600*24, "time", ["<second>"]],
	    "<week>":  [["wk","week","weeks"], 7*3600*24, "time", ["<second>"]],
	    "<fortnight>": [["fortnight","fortnights"], 1209600, "time", ["<second>"]],
	    "<year>":  [["y","yr","year","years","annum"], 31556926, "time", ["<second>"]],
	    "<decade>":[["decade","decades"], 315569260, "time", ["<second>"]],
	    "<century>":[["century","centuries"], 3155692600, "time", ["<second>"]],
	
	    /* pressure */
	    "<pascal>" : [["Pa","pascal","Pascal"], 1.0, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
	    "<bar>" : [["bar","bars"], 100000, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
	    "<mmHg>" : [["mmHg"], 133.322368, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
	    "<inHg>" : [["inHg"], 3386.3881472, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
	    "<torr>" : [["torr"], 133.322368, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
	    "<atm>" : [["atm","ATM","atmosphere","atmospheres"], 101325, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
	    "<psi>" : [["psi"], 6894.76, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
	    "<cmh2o>" : [["cmH2O"], 98.0638, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
	    "<inh2o>" : [["inH2O"], 249.082052, "pressure", ["<kilogram>"],["<meter>","<second>","<second>"]],
	
	    /* viscosity */
	    "<poise>"  : [["P","poise"], 0.1, "viscosity", ["<kilogram>"],["<meter>","<second>"] ],
	    "<stokes>" : [["St","stokes"], 1e-4, "viscosity", ["<meter>","<meter>"], ["<second>"]],
	
	    /* substance */
	    "<mole>"  :  [["mol","mole"], 1.0, "substance", ["<mole>"]],
	
	    /* concentration */
	    "<molar>" : [["M","molar"], 1000, "concentration", ["<mole>"], ["<meter>","<meter>","<meter>"]],
	    "<wtpercent>"  : [["wt%","wtpercent"], 10, "concentration", ["<kilogram>"], ["<meter>","<meter>","<meter>"]],
	
	    /* activity */
	    "<katal>" :  [["kat","katal","Katal"], 1.0, "activity", ["<mole>"], ["<second>"]],
	    "<unit>"  :  [["U","enzUnit"], 16.667e-16, "activity", ["<mole>"], ["<second>"]],
	
	    /* capacitance */
	    "<farad>" :  [["F","farad","Farad"], 1.0, "capacitance", ["<farad>"]],
	
	    /* charge */
	    "<coulomb>" :  [["C","coulomb","Coulomb"], 1.0, "charge", ["<ampere>","<second>"]],
	
	    /* current */
	    "<ampere>"  :  [["A","Ampere","ampere","amp","amps"], 1.0, "current", ["<ampere>"]],
	
	    /* conductance */
	    "<siemens>" : [["S","Siemens","siemens"], 1.0, "conductance", ["<second>","<second>","<second>","<ampere>","<ampere>"], ["<kilogram>","<meter>","<meter>"]],
	
	    /* inductance */
	    "<henry>" :  [["H","Henry","henry"], 1.0, "inductance", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>","<ampere>","<ampere>"]],
	
	    /* potential */
	    "<volt>"  :  [["V","Volt","volt","volts"], 1.0, "potential", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>","<second>","<ampere>"]],
	
	    /* resistance */
	    "<ohm>" :  [
	      ["Ohm","ohm","\u03A9"/*Ω as greek letter*/,"\u2126"/*Ω as ohm sign*/],
	      1.0,
	      "resistance",
	      ["<meter>","<meter>","<kilogram>"],["<second>","<second>","<second>","<ampere>","<ampere>"]
	    ],
	    /* magnetism */
	    "<weber>" : [["Wb","weber","webers"], 1.0, "magnetism", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>","<ampere>"]],
	    "<tesla>"  : [["T","tesla","teslas"], 1.0, "magnetism", ["<kilogram>"], ["<second>","<second>","<ampere>"]],
	    "<gauss>" : [["G","gauss"], 1e-4, "magnetism",  ["<kilogram>"], ["<second>","<second>","<ampere>"]],
	    "<maxwell>" : [["Mx","maxwell","maxwells"], 1e-8, "magnetism", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>","<ampere>"]],
	    "<oersted>"  : [["Oe","oersted","oersteds"], 250.0/Math.PI, "magnetism", ["<ampere>"], ["<meter>"]],
	
	    /* energy */
	    "<joule>" :  [["J","joule","Joule","joules"], 1.0, "energy", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
	    "<erg>"   :  [["erg","ergs"], 1e-7, "energy", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
	    "<btu>"   :  [["BTU","btu","BTUs"], 1055.056, "energy", ["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
	    "<calorie>" :  [["cal","calorie","calories"], 4.18400, "energy",["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
	    "<Calorie>" :  [["Cal","Calorie","Calories"], 4184.00, "energy",["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
	    "<therm-US>" : [["th","therm","therms","Therm"], 105480400, "energy",["<meter>","<meter>","<kilogram>"], ["<second>","<second>"]],
	
	    /* force */
	    "<newton>"  : [["N","Newton","newton"], 1.0, "force", ["<kilogram>","<meter>"], ["<second>","<second>"]],
	    "<dyne>"  : [["dyn","dyne"], 1e-5, "force", ["<kilogram>","<meter>"], ["<second>","<second>"]],
	    "<pound-force>"  : [["lbf","pound-force"], 4.448222, "force", ["<kilogram>","<meter>"], ["<second>","<second>"]],
	
	    /* frequency */
	    "<hertz>" : [["Hz","hertz","Hertz"], 1.0, "frequency", ["<1>"], ["<second>"]],
	
	    /* angle */
	    "<radian>" :[["rad","radian","radians"], 1.0, "angle", ["<radian>"]],
	    "<degree>" :[["deg","degree","degrees"], Math.PI / 180.0, "angle", ["<radian>"]],
	    "<gradian>"   :[["gon","grad","gradian","grads"], Math.PI / 200.0, "angle", ["<radian>"]],
	    "<steradian>"  : [["sr","steradian","steradians"], 1.0, "solid_angle", ["<steradian>"]],
	
	    /* rotation */
	    "<rotation>" : [["rotation"], 2.0*Math.PI, "angle", ["<radian>"]],
	    "<rpm>"   :[["rpm"], 2.0*Math.PI / 60.0, "angular_velocity", ["<radian>"], ["<second>"]],
	
	    /* memory */
	    "<byte>"  :[["B","byte"], 1.0, "memory", ["<byte>"]],
	    "<bit>"  :[["b","bit"], 0.125, "memory", ["<byte>"]],
	
	    /* currency */
	    "<dollar>":[["USD","dollar"], 1.0, "currency", ["<dollar>"]],
	    "<cents>" :[["cents"], 0.01, "currency", ["<dollar>"]],
	
	    /* luminosity */
	    "<candela>" : [["cd","candela"], 1.0, "luminosity", ["<candela>"]],
	    "<lumen>" : [["lm","lumen"], 1.0, "luminous_power", ["<candela>","<steradian>"]],
	    "<lux>" :[["lux"], 1.0, "illuminance", ["<candela>","<steradian>"], ["<meter>","<meter>"]],
	
	    /* power */
	    "<watt>"  : [["W","watt","watts"], 1.0, "power", ["<kilogram>","<meter>","<meter>"], ["<second>","<second>","<second>"]],
	    "<horsepower>"  :  [["hp","horsepower"], 745.699872, "power", ["<kilogram>","<meter>","<meter>"], ["<second>","<second>","<second>"]],
	
	    /* radiation */
	    "<gray>" : [["Gy","gray","grays"], 1.0, "radiation", ["<meter>","<meter>"], ["<second>","<second>"]],
	    "<roentgen>" : [["R","roentgen"], 0.009330, "radiation", ["<meter>","<meter>"], ["<second>","<second>"]],
	    "<sievert>" : [["Sv","sievert","sieverts"], 1.0, "radiation", ["<meter>","<meter>"], ["<second>","<second>"]],
	    "<becquerel>" : [["Bq","bequerel","bequerels"], 1.0, "radiation", ["<1>"],["<second>"]],
	    "<curie>" : [["Ci","curie","curies"], 3.7e10, "radiation", ["<1>"],["<second>"]],
	
	    /* rate */
	    "<cpm>" : [["cpm"], 1.0/60.0, "rate", ["<count>"],["<second>"]],
	    "<dpm>" : [["dpm"], 1.0/60.0, "rate", ["<count>"],["<second>"]],
	    "<bpm>" : [["bpm"], 1.0/60.0, "rate", ["<count>"],["<second>"]],
	
	    /* resolution / typography */
	    "<dot>" : [["dot","dots"], 1, "resolution", ["<each>"]],
	    "<pixel>" : [["pixel","px"], 1, "resolution", ["<each>"]],
	    "<ppi>" : [["ppi"], 1, "resolution", ["<pixel>"], ["<inch>"]],
	    "<dpi>" : [["dpi"], 1, "typography", ["<dot>"], ["<inch>"]],
	
	    /* other */
	    "<cell>" : [["cells","cell"], 1, "counting", ["<each>"]],
	    "<each>" : [["each"], 1.0, "counting", ["<each>"]],
	    "<count>" : [["count"], 1.0, "counting", ["<each>"]],
	    "<base-pair>"  : [["bp"], 1.0, "counting", ["<each>"]],
	    "<nucleotide>" : [["nt"], 1.0, "counting", ["<each>"]],
	    "<molecule>" : [["molecule","molecules"], 1.0, "counting", ["<1>"]],
	    "<dozen>" :  [["doz","dz","dozen"],12.0,"prefix_only", ["<each>"]],
	    "<percent>": [["%","percent"], 0.01, "prefix_only", ["<1>"]],
	    "<ppm>" :  [["ppm"],1e-6, "prefix_only", ["<1>"]],
	    "<ppt>" :  [["ppt"],1e-9, "prefix_only", ["<1>"]],
	    "<gross>" :  [["gr","gross"],144.0, "prefix_only", ["<dozen>","<dozen>"]],
	    "<decibel>"  : [["dB","decibel","decibels"], 1.0, "logarithmic", ["<decibel>"]]
	  };
	
	
	  var BASE_UNITS = ["<meter>","<kilogram>","<second>","<mole>", "<farad>", "<ampere>","<radian>","<kelvin>","<temp-K>","<byte>","<dollar>","<candela>","<each>","<steradian>","<decibel>"];
	  var UNITY = "<1>";
	  var UNITY_ARRAY= [UNITY];
	  var SIGN = "[+-]";
	  var INTEGER = "\\d+";
	  var SIGNED_INTEGER = SIGN + "?" + INTEGER;
	  var FRACTION = "\\." + INTEGER;
	  var FLOAT = "(?:" + INTEGER + "(?:" + FRACTION + ")?" + ")" +
	              "|" +
	              "(?:" + FRACTION + ")";
	  var EXPONENT = "[Ee]" + SIGNED_INTEGER;
	  var SCI_NUMBER = "(?:" + FLOAT + ")(?:" + EXPONENT + ")?";
	  var SIGNED_NUMBER = SIGN + "?\\s*" + SCI_NUMBER;
	  var QTY_STRING = "(" + SIGNED_NUMBER + ")?" + "\\s*([^/]*)(?:\/(.+))?";
	  var QTY_STRING_REGEX = new RegExp("^" + QTY_STRING + "$");
	  var POWER_OP = "\\^|\\*{2}";
	  var TOP_REGEX = new RegExp ("([^ \\*]+?)(?:" + POWER_OP + ")?(-?\\d+)");
	  var BOTTOM_REGEX = new RegExp("([^ \\*]+?)(?:" + POWER_OP + ")?(\\d+)");
	
	  var SIGNATURE_VECTOR = ["length", "time", "temperature", "mass", "current", "substance", "luminosity", "currency", "memory", "angle", "capacitance"];
	  var KINDS = {
	    "-312058": "resistance",
	    "-312038": "inductance",
	    "-152040": "magnetism",
	    "-152038": "magnetism",
	    "-152058": "potential",
	    "-39": "acceleration",
	    "-38": "radiation",
	    "-20": "frequency",
	    "-19": "speed",
	    "-18": "viscosity",
	    "0": "unitless",
	    "1": "length",
	    "2": "area",
	    "3": "volume",
	    "20": "time",
	    "400": "temperature",
	    "7942": "power",
	    "7959": "pressure",
	    "7962": "energy",
	    "7979": "viscosity",
	    "7961": "force",
	    "7997": "mass_concentration",
	    "8000": "mass",
	    "159999": "magnetism",
	    "160000": "current",
	    "160020": "charge",
	    "312058": "conductance",
	    "3199980": "activity",
	    "3199997": "molar_concentration",
	    "3200000": "substance",
	    "63999998": "illuminance",
	    "64000000": "luminous_power",
	    "1280000000": "currency",
	    "25600000000": "memory",
	    "511999999980": "angular_velocity",
	    "512000000000": "angle",
	    "10240000000000": "capacitance"
	  };
	
	  var baseUnitCache = {};
	
	  function Qty(initValue) {
	    assertValidInitializationValueType(initValue);
	
	    if(!(isQty(this))) {
	      return new Qty(initValue);
	    }
	
	    this.scalar = null;
	    this.baseScalar = null;
	    this.signature = null;
	    this._conversionCache = {};
	    this.numerator = UNITY_ARRAY;
	    this.denominator = UNITY_ARRAY;
	
	    if (isDefinitionObject(initValue)) {
	      this.scalar = initValue.scalar;
	      this.numerator = (initValue.numerator && initValue.numerator.length !== 0)? initValue.numerator : UNITY_ARRAY;
	      this.denominator = (initValue.denominator && initValue.denominator.length !== 0)? initValue.denominator : UNITY_ARRAY;
	    }
	    else {
	      parse.call(this, initValue);
	    }
	
	    // math with temperatures is very limited
	    if(this.denominator.join("*").indexOf("temp") >= 0) {
	      throw new QtyError("Cannot divide with temperatures");
	    }
	    if(this.numerator.join("*").indexOf("temp") >= 0) {
	      if(this.numerator.length > 1) {
	        throw new QtyError("Cannot multiply by temperatures");
	      }
	      if(!compareArray(this.denominator, UNITY_ARRAY)) {
	        throw new QtyError("Cannot divide with temperatures");
	      }
	    }
	
	    this.initValue = initValue;
	    updateBaseScalar.call(this);
	
	    if(this.isTemperature() && this.baseScalar < 0) {
	      throw new QtyError("Temperatures must not be less than absolute zero");
	    }
	  }
	
	  /**
	   * Parses a string as a quantity
	   * @param {string} value - quantity as text
	   * @throws if value is not a string
	   * @returns {Qty|null} Parsed quantity or null if unrecognized
	   */
	  Qty.parse = function parse(value) {
	    if(!isString(value)) {
	      throw new QtyError("Argument should be a string");
	    }
	
	    try {
	      return Qty(value);
	    }
	    catch(e) {
	      return null;
	    }
	  };
	
	  /**
	   * Configures and returns a fast function to convert
	   * Number values from units to others.
	   * Useful to efficiently convert large array of values
	   * with same units into others with iterative methods.
	   * Does not take care of rounding issues.
	   *
	   * @param {string} srcUnits Units of values to convert
	   * @param {string} dstUnits Units to convert to
	   *
	   * @returns {Function} Converting function accepting Number value
	   *   and returning converted value
	   *
	   * @throws "Incompatible units" if units are incompatible
	   *
	   * @example
	   * // Converting large array of numbers with the same units
	   * // into other units
	   * var converter = Qty.swiftConverter("m/h", "ft/s");
	   * var convertedSerie = largeSerie.map(converter);
	   *
	   */
	  Qty.swiftConverter = function swiftConverter(srcUnits, dstUnits) {
	    var srcQty = Qty(srcUnits);
	    var dstQty = Qty(dstUnits);
	
	    if(srcQty.eq(dstQty)) {
	      return identity;
	    }
	
	    var convert;
	    if(!srcQty.isTemperature()) {
	      convert = function(value) {
	        return value * srcQty.baseScalar / dstQty.baseScalar;
	      };
	    }
	    else {
	      convert = function(value) {
	        // TODO Not optimized
	        return srcQty.mul(value).to(dstQty).scalar;
	      };
	    }
	
	    return function converter(value) {
	      var i,
	          length,
	          result;
	      if(!Array.isArray(value)) {
	        return convert(value);
	      }
	      else {
	        length = value.length;
	        result = [];
	        for(i = 0; i < length; i++) {
	          result.push(convert(value[i]));
	        }
	        return result;
	      }
	    };
	  };
	
	  /**
	   * Returns the list of available well-known kinds of units, e.g.
	   * "radiation" or "length".
	   *
	   * @returns {string[]} names of kinds of units
	   */
	  Qty.getKinds = function() {
	    var knownKinds = Object.keys(KINDS).map(function(knownSignature) {
	      return KINDS[knownSignature];
	    }).sort();
	    return knownKinds;
	  };
	
	  /**
	   * Default formatter
	   *
	   * @param {number} scalar
	   * @param {string} units
	   *
	   * @returns {string} formatted result
	   */
	  function defaultFormatter(scalar, units) {
	    return (scalar + " " + units).trim();
	  }
	
	  /**
	   *
	   * Configurable Qty default formatter
	   *
	   * @type {function}
	   *
	   * @param {number} scalar
	   * @param {string} units
	   *
	   * @returns {string} formatted result
	   */
	  Qty.formatter = defaultFormatter;
	
	  var updateBaseScalar = function () {
	    if(this.baseScalar) {
	      return this.baseScalar;
	    }
	    if(this.isBase()) {
	      this.baseScalar = this.scalar;
	      this.signature = unitSignature.call(this);
	    }
	    else {
	      var base = this.toBase();
	      this.baseScalar = base.scalar;
	      this.signature = base.signature;
	    }
	  };
	
	  /*
	  calculates the unit signature id for use in comparing compatible units and simplification
	  the signature is based on a simple classification of units and is based on the following publication
	
	  Novak, G.S., Jr. "Conversion of units of measurement", IEEE Transactions on Software Engineering,
	  21(8), Aug 1995, pp.651-661
	  doi://10.1109/32.403789
	  http://ieeexplore.ieee.org/Xplore/login.jsp?url=/iel1/32/9079/00403789.pdf?isnumber=9079&prod=JNL&arnumber=403789&arSt=651&ared=661&arAuthor=Novak%2C+G.S.%2C+Jr.
	  */
	  var unitSignature = function () {
	    if(this.signature) {
	      return this.signature;
	    }
	    var vector = unitSignatureVector.call(this);
	    for(var i = 0; i < vector.length; i++) {
	      vector[i] *= Math.pow(20, i);
	    }
	
	    return vector.reduce(function(previous, current) {return previous + current;}, 0);
	  };
	
	  // calculates the unit signature vector used by unit_signature
	  var unitSignatureVector = function () {
	    if(!this.isBase()) {
	      return unitSignatureVector.call(this.toBase());
	    }
	
	    var vector = new Array(SIGNATURE_VECTOR.length);
	    for(var i = 0; i < vector.length; i++) {
	      vector[i] = 0;
	    }
	    var r, n;
	    for(var j = 0; j < this.numerator.length; j++) {
	      if((r = UNITS[this.numerator[j]])) {
	        n = SIGNATURE_VECTOR.indexOf(r[2]);
	        if(n >= 0) {
	          vector[n] = vector[n] + 1;
	        }
	      }
	    }
	
	    for(var k = 0; k < this.denominator.length; k++) {
	      if((r = UNITS[this.denominator[k]])) {
	        n = SIGNATURE_VECTOR.indexOf(r[2]);
	        if(n >= 0) {
	          vector[n] = vector[n] - 1;
	        }
	      }
	    }
	    return vector;
	  };
	
	  /* parse a string into a unit object.
	   * Typical formats like :
	   * "5.6 kg*m/s^2"
	   * "5.6 kg*m*s^-2"
	   * "5.6 kilogram*meter*second^-2"
	   * "2.2 kPa"
	   * "37 degC"
	   * "1"  -- creates a unitless constant with value 1
	   * "GPa"  -- creates a unit with scalar 1 with units 'GPa'
	   * 6'4"  -- recognized as 6 feet + 4 inches
	   * 8 lbs 8 oz -- recognized as 8 lbs + 8 ounces
	   */
	  var parse = function (val) {
	    if (!isString(val)) {
	      val = val.toString();
	    }
	    val = val.trim();
	    if (val.length === 0) {
	      throw new QtyError("Unit not recognized");
	    }
	
	    var result = QTY_STRING_REGEX.exec(val);
	    if(!result) {
	      throw new QtyError(val + ": Quantity not recognized");
	    }
	
	    var scalarMatch = result[1];
	    if(scalarMatch) {
	      // Allow whitespaces between sign and scalar for loose parsing
	      scalarMatch = scalarMatch.replace(/\s/g, "");
	      this.scalar = parseFloat(scalarMatch);
	    }
	    else {
	      this.scalar = 1;
	    }
	    var top = result[2];
	    var bottom = result[3];
	
	    var n, x, nx;
	    // TODO DRY me
	    while((result = TOP_REGEX.exec(top))) {
	      n = parseFloat(result[2]);
	      if(isNaN(n)) {
	        // Prevents infinite loops
	        throw new QtyError("Unit exponent is not a number");
	      }
	      // Disallow unrecognized unit even if exponent is 0
	      if(n === 0 && !UNIT_TEST_REGEX.test(result[1])) {
	        throw new QtyError("Unit not recognized");
	      }
	      x = result[1] + " ";
	      nx = "";
	      for(var i = 0; i < Math.abs(n) ; i++) {
	        nx += x;
	      }
	      if(n >= 0) {
	        top = top.replace(result[0], nx);
	      }
	      else {
	        bottom = bottom ? bottom + nx : nx;
	        top = top.replace(result[0], "");
	      }
	    }
	
	    while((result = BOTTOM_REGEX.exec(bottom))) {
	      n = parseFloat(result[2]);
	      if(isNaN(n)) {
	        // Prevents infinite loops
	        throw new QtyError("Unit exponent is not a number");
	      }
	      // Disallow unrecognized unit even if exponent is 0
	      if(n === 0 && !UNIT_TEST_REGEX.test(result[1])) {
	        throw new QtyError("Unit not recognized");
	      }
	      x = result[1] + " ";
	      nx = "";
	      for(var j = 0; j < n ; j++) {
	        nx += x;
	      }
	
	      bottom = bottom.replace(result[0], nx, "g");
	    }
	
	    if(top) {
	      this.numerator = parseUnits(top.trim());
	    }
	    if(bottom) {
	      this.denominator = parseUnits(bottom.trim());
	    }
	
	  };
	
	  /*
	   * Throws incompatible units error
	   *
	   * @throws "Incompatible units" error
	   */
	  function throwIncompatibleUnits() {
	    throw new QtyError("Incompatible units");
	  }
	
	  Qty.prototype = {
	
	    // Properly set up constructor
	    constructor: Qty,
	
	    // Converts the unit back to a float if it is unitless.  Otherwise raises an exception
	    toFloat: function() {
	      if(this.isUnitless()) {
	        return this.scalar;
	      }
	      throw new QtyError("Can't convert to Float unless unitless.  Use Unit#scalar");
	    },
	
	    // returns true if no associated units
	    // false, even if the units are "unitless" like 'radians, each, etc'
	    isUnitless: function() {
	      return compareArray(this.numerator, UNITY_ARRAY) && compareArray(this.denominator, UNITY_ARRAY);
	    },
	
	    /*
	    check to see if units are compatible, but not the scalar part
	    this check is done by comparing signatures for performance reasons
	    if passed a string, it will create a unit object with the string and then do the comparison
	    this permits a syntax like:
	    unit =~ "mm"
	    if you want to do a regexp on the unit string do this ...
	    unit.units =~ /regexp/
	    */
	    isCompatible: function(other) {
	      if(isString(other)) {
	        return this.isCompatible(Qty(other));
	      }
	
	      if(!(isQty(other))) {
	        return false;
	      }
	
	      if(other.signature !== undefined) {
	        return this.signature === other.signature;
	      }
	      else {
	        return false;
	      }
	    },
	
	    /*
	    check to see if units are inverse of each other, but not the scalar part
	    this check is done by comparing signatures for performance reasons
	    if passed a string, it will create a unit object with the string and then do the comparison
	    this permits a syntax like:
	    unit =~ "mm"
	    if you want to do a regexp on the unit string do this ...
	    unit.units =~ /regexp/
	    */
	    isInverse: function(other) {
	      return this.inverse().isCompatible(other);
	    },
	
	    kind: function() {
	      return KINDS[this.signature.toString()];
	    },
	
	    // Returns 'true' if the Unit is represented in base units
	    isBase: function() {
	      if(this._isBase !== undefined) {
	        return this._isBase;
	      }
	      if(this.isDegrees() && this.numerator[0].match(/<(kelvin|temp-K)>/)) {
	        this._isBase = true;
	        return this._isBase;
	      }
	
	      this.numerator.concat(this.denominator).forEach(function(item) {
	        if(item !== UNITY && BASE_UNITS.indexOf(item) === -1 ) {
	          this._isBase = false;
	        }
	      }, this);
	      if(this._isBase === false) {
	        return this._isBase;
	      }
	      this._isBase = true;
	      return this._isBase;
	    },
	
	    // convert to base SI units
	    // results of the conversion are cached so subsequent calls to this will be fast
	    toBase: function() {
	      if(this.isBase()) {
	        return this;
	      }
	
	      if(this.isTemperature()) {
	        return toTempK(this);
	      }
	
	      var cached = baseUnitCache[this.units()];
	      if(!cached) {
	        cached = toBaseUnits(this.numerator,this.denominator);
	        baseUnitCache[this.units()] = cached;
	      }
	      return cached.mul(this.scalar);
	    },
	
	    // returns the 'unit' part of the Unit object without the scalar
	    units: function() {
	      if(this._units !== undefined) {
	        return this._units;
	      }
	
	      var numIsUnity = compareArray(this.numerator, UNITY_ARRAY),
	          denIsUnity = compareArray(this.denominator, UNITY_ARRAY);
	      if(numIsUnity && denIsUnity) {
	        this._units = "";
	        return this._units;
	      }
	
	      var numUnits = stringifyUnits(this.numerator),
	          denUnits = stringifyUnits(this.denominator);
	      this._units = numUnits + (denIsUnity ? "":("/" + denUnits));
	      return this._units;
	    },
	
	    eq: function(other) {
	      return this.compareTo(other) === 0;
	    },
	    lt: function(other) {
	      return this.compareTo(other) === -1;
	    },
	    lte: function(other) {
	      return this.eq(other) || this.lt(other);
	    },
	    gt: function(other) {
	      return this.compareTo(other) === 1;
	    },
	    gte: function(other) {
	      return this.eq(other) || this.gt(other);
	    },
	
	    /**
	     * Returns the nearest multiple of quantity passed as
	     * precision
	     *
	     * @param {(Qty|string|number)} prec-quantity - Quantity, string formated
	     *   quantity or number as expected precision
	     *
	     * @returns {Qty} Nearest multiple of precQuantity
	     *
	     * @example
	     * Qty('5.5 ft').toPrec('2 ft'); // returns 6 ft
	     * Qty('0.8 cu').toPrec('0.25 cu'); // returns 0.75 cu
	     * Qty('6.3782 m').toPrec('cm'); // returns 6.38 m
	     * Qty('1.146 MPa').toPrec('0.1 bar'); // returns 1.15 MPa
	     *
	     */
	    toPrec: function(precQuantity) {
	      if(isString(precQuantity)) {
	        precQuantity = Qty(precQuantity);
	      }
	      if(isNumber(precQuantity)) {
	        precQuantity = Qty(precQuantity + " " + this.units());
	      }
	
	      if(!this.isUnitless()) {
	        precQuantity = precQuantity.to(this.units());
	      }
	      else if(!precQuantity.isUnitless()) {
	        throwIncompatibleUnits();
	      }
	
	      if(precQuantity.scalar === 0) {
	        throw new QtyError("Divide by zero");
	      }
	
	      var precRoundedResult = mulSafe(Math.round(this.scalar/precQuantity.scalar),
	                                         precQuantity.scalar);
	
	      return Qty(precRoundedResult + this.units());
	    },
	
	    /**
	     * Stringifies the quantity
	     * Deprecation notice: only units parameter is supported.
	     *
	     * @param {(number|string|Qty)} targetUnitsOrMaxDecimalsOrPrec -
	     *                              target units if string,
	     *                              max number of decimals if number,
	     *                              passed to #toPrec before converting if Qty
	     *
	     * @param {number=} maxDecimals - Maximum number of decimals of
	     *                                formatted output
	     *
	     * @returns {string} reparseable quantity as string
	     */
	    toString: function(targetUnitsOrMaxDecimalsOrPrec, maxDecimals) {
	      var targetUnits;
	      if(isNumber(targetUnitsOrMaxDecimalsOrPrec)) {
	        targetUnits = this.units();
	        maxDecimals = targetUnitsOrMaxDecimalsOrPrec;
	      }
	      else if(isString(targetUnitsOrMaxDecimalsOrPrec)) {
	        targetUnits = targetUnitsOrMaxDecimalsOrPrec;
	      }
	      else if(isQty(targetUnitsOrMaxDecimalsOrPrec)) {
	        return this.toPrec(targetUnitsOrMaxDecimalsOrPrec).toString(maxDecimals);
	      }
	
	      var out = this.to(targetUnits);
	
	      var outScalar = maxDecimals !== undefined ? round(out.scalar, maxDecimals) : out.scalar;
	      out = (outScalar + " " + out.units()).trim();
	      return out;
	    },
	
	    /**
	     * Format the quantity according to optional passed target units
	     * and formatter
	     *
	     * @param {string} [targetUnits=current units] -
	     *                 optional units to convert to before formatting
	     *
	     * @param {function} [formatter=Qty.formatter] -
	     *                   delegates formatting to formatter callback.
	     *                   formatter is called back with two parameters (scalar, units)
	     *                   and should return formatted result.
	     *                   If unspecified, formatting is delegated to default formatter
	     *                   set to Qty.formatter
	     *
	     * @example
	     * var roundingAndLocalizingFormatter = function(scalar, units) {
	     *   // localize or limit scalar to n max decimals for instance
	     *   // return formatted result
	     * };
	     * var qty = Qty('1.1234 m');
	     * qty.format(); // same units, default formatter => "1.234 m"
	     * qty.format("cm"); // converted to "cm", default formatter => "123.45 cm"
	     * qty.format(roundingAndLocalizingFormatter); // same units, custom formatter => "1,2 m"
	     * qty.format("cm", roundingAndLocalizingFormatter); // convert to "cm", custom formatter => "123,4 cm"
	     *
	     * @returns {string} quantity as string
	     */
	    format: function(targetUnits, formatter) {
	      if(arguments.length === 1) {
	        if(typeof targetUnits === "function") {
	          formatter = targetUnits;
	          targetUnits = undefined;
	        }
	      }
	
	      formatter = formatter || Qty.formatter;
	      var targetQty = this.to(targetUnits);
	      return formatter.call(this, targetQty.scalar, targetQty.units());
	    },
	
	    // Compare two Qty objects. Throws an exception if they are not of compatible types.
	    // Comparisons are done based on the value of the quantity in base SI units.
	    //
	    // NOTE: We cannot compare inverses as that breaks the general compareTo contract:
	    //   if a.compareTo(b) < 0 then b.compareTo(a) > 0
	    //   if a.compareTo(b) == 0 then b.compareTo(a) == 0
	    //
	    //   Since "10S" == ".1ohm" (10 > .1) and "10ohm" == ".1S" (10 > .1)
	    //     Qty("10S").inverse().compareTo("10ohm") == -1
	    //     Qty("10ohm").inverse().compareTo("10S") == -1
	    //
	    //   If including inverses in the sort is needed, I suggest writing: Qty.sort(qtyArray,units)
	    compareTo: function(other) {
	      if(isString(other)) {
	        return this.compareTo(Qty(other));
	      }
	      if(!this.isCompatible(other)) {
	        throwIncompatibleUnits();
	      }
	      if(this.baseScalar < other.baseScalar) {
	        return -1;
	      }
	      else if(this.baseScalar === other.baseScalar) {
	        return 0;
	      }
	      else if(this.baseScalar > other.baseScalar) {
	        return 1;
	      }
	    },
	
	    // Return true if quantities and units match
	    // Unit("100 cm").same(Unit("100 cm"))  # => true
	    // Unit("100 cm").same(Unit("1 m"))     # => false
	    same: function(other) {
	      return (this.scalar === other.scalar) && (this.units() === other.units());
	    },
	
	    // Returns a Qty that is the inverse of this Qty,
	    inverse: function() {
	      if(this.isTemperature()) {
	        throw new QtyError("Cannot divide with temperatures");
	      }
	      if(this.scalar === 0) {
	        throw new QtyError("Divide by zero");
	      }
	      return Qty({"scalar": 1/this.scalar, "numerator": this.denominator, "denominator": this.numerator});
	    },
	
	    isDegrees: function() {
	      // signature may not have been calculated yet
	      return (this.signature === null || this.signature === 400) &&
	        this.numerator.length === 1 &&
	        compareArray(this.denominator, UNITY_ARRAY) &&
	        (this.numerator[0].match(/<temp-[CFRK]>/) || this.numerator[0].match(/<(kelvin|celsius|rankine|fahrenheit)>/));
	    },
	
	    isTemperature: function() {
	      return this.isDegrees() && this.numerator[0].match(/<temp-[CFRK]>/);
	    },
	
	    /**
	     * Converts to other compatible units.
	     * Instance's converted quantities are cached for faster subsequent calls.
	     *
	     * @param {(string|Qty)} other - Target units as string or retrieved from
	     *                               other Qty instance (scalar is ignored)
	     *
	     * @returns {Qty} New converted Qty instance with target units
	     *
	     * @throws {QtyError} if target units are incompatible
	     *
	     * @example
	     * var weight = Qty("25 kg");
	     * weight.to("lb"); // => Qty("55.11556554621939 lbs");
	     * weight.to(Qty("3 g")); // => Qty("25000 g"); // scalar of passed Qty is ignored
	     */
	    to: function(other) {
	      var cached, target;
	
	      if(!other) {
	        return this;
	      }
	
	      if(!isString(other)) {
	        return this.to(other.units());
	      }
	
	      cached = this._conversionCache[other];
	      if(cached) {
	        return cached;
	      }
	
	      // Instantiating target to normalize units
	      target = Qty(other);
	      if(target.units() === this.units()) {
	        return this;
	      }
	
	      if(!this.isCompatible(target)) {
	        if(this.isInverse(target)) {
	          target = this.inverse().to(other);
	        }
	        else {
	          throwIncompatibleUnits();
	        }
	      }
	      else {
	        if(target.isTemperature()) {
	          target = toTemp(this,target);
	        }
	        else if(target.isDegrees()) {
	          target = toDegrees(this,target);
	        }
	        else {
	          var q = divSafe(this.baseScalar, target.baseScalar);
	          target = Qty({"scalar": q, "numerator": target.numerator, "denominator": target.denominator});
	        }
	      }
	
	      this._conversionCache[other] = target;
	      return target;
	    },
	
	    // Quantity operators
	    // Returns new instance with this units
	    add: function(other) {
	      if(isString(other)) {
	        other = Qty(other);
	      }
	
	      if(!this.isCompatible(other)) {
	        throwIncompatibleUnits();
	      }
	
	      if(this.isTemperature() && other.isTemperature()) {
	        throw new QtyError("Cannot add two temperatures");
	      }
	      else if(this.isTemperature()) {
	        return addTempDegrees(this,other);
	      }
	      else if(other.isTemperature()) {
	        return addTempDegrees(other,this);
	      }
	
	      return Qty({"scalar": this.scalar + other.to(this).scalar, "numerator": this.numerator, "denominator": this.denominator});
	    },
	
	    sub: function(other) {
	      if(isString(other)) {
	        other = Qty(other);
	      }
	
	      if(!this.isCompatible(other)) {
	        throwIncompatibleUnits();
	      }
	
	      if(this.isTemperature() && other.isTemperature()) {
	        return subtractTemperatures(this,other);
	      }
	      else if(this.isTemperature()) {
	        return subtractTempDegrees(this,other);
	      }
	      else if(other.isTemperature()) {
	        throw new QtyError("Cannot subtract a temperature from a differential degree unit");
	      }
	
	      return Qty({"scalar": this.scalar - other.to(this).scalar, "numerator": this.numerator, "denominator": this.denominator});
	    },
	
	    mul: function(other) {
	      if(isNumber(other)) {
	        return Qty({"scalar": mulSafe(this.scalar, other), "numerator": this.numerator, "denominator": this.denominator});
	      }
	      else if(isString(other)) {
	        other = Qty(other);
	      }
	
	      if((this.isTemperature()||other.isTemperature()) && !(this.isUnitless()||other.isUnitless())) {
	        throw new QtyError("Cannot multiply by temperatures");
	      }
	
	      // Quantities should be multiplied with same units if compatible, with base units else
	      var op1 = this;
	      var op2 = other;
	
	      // so as not to confuse results, multiplication and division between temperature degrees will maintain original unit info in num/den
	      // multiplication and division between deg[CFRK] can never factor each other out, only themselves: "degK*degC/degC^2" == "degK/degC"
	      if(op1.isCompatible(op2) && op1.signature !== 400) {
	        op2 = op2.to(op1);
	      }
	      var numden = cleanTerms(op1.numerator.concat(op2.numerator), op1.denominator.concat(op2.denominator));
	
	      return Qty({"scalar": mulSafe(op1.scalar, op2.scalar) , "numerator": numden[0], "denominator": numden[1]});
	    },
	
	    div: function(other) {
	      if(isNumber(other)) {
	        if(other === 0) {
	          throw new QtyError("Divide by zero");
	        }
	        return Qty({"scalar": this.scalar / other, "numerator": this.numerator, "denominator": this.denominator});
	      }
	      else if(isString(other)) {
	        other = Qty(other);
	      }
	
	      if(other.scalar === 0) {
	        throw new QtyError("Divide by zero");
	      }
	
	      if(other.isTemperature()) {
	        throw new QtyError("Cannot divide with temperatures");
	      }
	      else if(this.isTemperature() && !other.isUnitless()) {
	        throw new QtyError("Cannot divide with temperatures");
	      }
	
	      // Quantities should be multiplied with same units if compatible, with base units else
	      var op1 = this;
	      var op2 = other;
	
	      // so as not to confuse results, multiplication and division between temperature degrees will maintain original unit info in num/den
	      // multiplication and division between deg[CFRK] can never factor each other out, only themselves: "degK*degC/degC^2" == "degK/degC"
	      if(op1.isCompatible(op2) && op1.signature !== 400) {
	        op2 = op2.to(op1);
	      }
	      var numden = cleanTerms(op1.numerator.concat(op2.denominator), op1.denominator.concat(op2.numerator));
	
	      return Qty({"scalar": op1.scalar / op2.scalar, "numerator": numden[0], "denominator": numden[1]});
	    }
	
	  };
	
	  function toBaseUnits (numerator,denominator) {
	    var num = [];
	    var den = [];
	    var q = 1;
	    var unit;
	    for(var i = 0; i < numerator.length; i++) {
	      unit = numerator[i];
	      if(PREFIX_VALUES[unit]) {
	        // workaround to fix
	        // 0.1 * 0.1 => 0.010000000000000002
	        q = mulSafe(q, PREFIX_VALUES[unit]);
	      }
	      else {
	        if(UNIT_VALUES[unit]) {
	          q *= UNIT_VALUES[unit].scalar;
	
	          if(UNIT_VALUES[unit].numerator) {
	            num.push(UNIT_VALUES[unit].numerator);
	          }
	          if(UNIT_VALUES[unit].denominator) {
	            den.push(UNIT_VALUES[unit].denominator);
	          }
	        }
	      }
	    }
	    for(var j = 0; j < denominator.length; j++) {
	      unit = denominator[j];
	      if(PREFIX_VALUES[unit]) {
	        q /= PREFIX_VALUES[unit];
	      }
	      else {
	        if(UNIT_VALUES[unit]) {
	          q /= UNIT_VALUES[unit].scalar;
	
	          if(UNIT_VALUES[unit].numerator) {
	            den.push(UNIT_VALUES[unit].numerator);
	          }
	          if(UNIT_VALUES[unit].denominator) {
	            num.push(UNIT_VALUES[unit].denominator);
	          }
	        }
	      }
	    }
	
	    // Flatten
	    num = num.reduce(function(a,b) {
	      return a.concat(b);
	    }, []);
	    den = den.reduce(function(a,b) {
	      return a.concat(b);
	    }, []);
	
	    return Qty({"scalar": q, "numerator": num, "denominator": den});
	  }
	
	  var parsedUnitsCache = {};
	  /**
	   * Parses and converts units string to normalized unit array.
	   * Result is cached to speed up next calls.
	   *
	   * @param {string} units Units string
	   * @returns {string[]} Array of normalized units
	   *
	   * @example
	   * // Returns ["<second>", "<meter>", "<second>"]
	   * parseUnits("s m s");
	   *
	   */
	  function parseUnits(units) {
	    var cached = parsedUnitsCache[units];
	    if(cached) {
	      return cached;
	    }
	
	    var unitMatch, normalizedUnits = [];
	    // Scan
	    if(!UNIT_TEST_REGEX.test(units)) {
	      throw new QtyError("Unit not recognized");
	    }
	
	    while((unitMatch = UNIT_MATCH_REGEX.exec(units))) {
	      normalizedUnits.push(unitMatch.slice(1));
	    }
	
	    normalizedUnits = normalizedUnits.map(function(item) {
	      return PREFIX_MAP[item[0]] ? [PREFIX_MAP[item[0]], UNIT_MAP[item[1]]] : [UNIT_MAP[item[1]]];
	    });
	
	    // Flatten and remove null elements
	    normalizedUnits = normalizedUnits.reduce(function(a,b) {
	      return a.concat(b);
	    }, []);
	    normalizedUnits = normalizedUnits.filter(function(item) {
	      return item;
	    });
	
	    parsedUnitsCache[units] = normalizedUnits;
	
	    return normalizedUnits;
	  }
	
	  function NestedMap() {}
	
	  NestedMap.prototype.get = function(keys) {
	
	    // Allows to pass key1, key2, ... instead of [key1, key2, ...]
	    if(arguments.length > 1) {
	      // Slower with Firefox but faster with Chrome than
	      // Array.prototype.slice.call(arguments)
	      // See http://jsperf.com/array-apply-versus-array-prototype-slice-call
	      keys = Array.apply(null, arguments);
	    }
	
	    return keys.reduce(function(map, key, index) {
	      if (map) {
	
	        var childMap = map[key];
	
	        if (index === keys.length - 1) {
	          return childMap ? childMap.data : undefined;
	        }
	        else {
	          return childMap;
	        }
	      }
	    },
	    this);
	  };
	
	  NestedMap.prototype.set = function(keys, value) {
	
	      if(arguments.length > 2) {
	        keys = Array.prototype.slice.call(arguments, 0, -1);
	        value = arguments[arguments.length - 1];
	      }
	
	      return keys.reduce(function(map, key, index) {
	
	        var childMap = map[key];
	        if (childMap === undefined) {
	          childMap = map[key] = {};
	        }
	
	        if (index === keys.length - 1) {
	          childMap.data = value;
	          return value;
	        }
	        else {
	          return childMap;
	        }
	      },
	      this);
	  };
	
	  var stringifiedUnitsCache = new NestedMap();
	  /**
	   * Returns a string representing a normalized unit array
	   *
	   * @param {string[]} units Normalized unit array
	   * @returns {string} String representing passed normalized unit array and
	   *   suitable for output
	   *
	   */
	  function stringifyUnits(units) {
	
	    var stringified = stringifiedUnitsCache.get(units);
	    if(stringified) {
	      return stringified;
	    }
	
	    var isUnity = compareArray(units, UNITY_ARRAY);
	    if(isUnity) {
	      stringified = "1";
	    }
	    else {
	      stringified = simplify(getOutputNames(units)).join("*");
	    }
	
	    // Cache result
	    stringifiedUnitsCache.set(units, stringified);
	
	    return stringified;
	  }
	
	  function getOutputNames(units) {
	    var unitNames = [], token, tokenNext;
	    for(var i = 0; i < units.length; i++) {
	      token = units[i];
	      tokenNext = units[i+1];
	      if(PREFIX_VALUES[token]) {
	        unitNames.push(OUTPUT_MAP[token] + OUTPUT_MAP[tokenNext]);
	        i++;
	      }
	      else {
	        unitNames.push(OUTPUT_MAP[token]);
	      }
	    }
	    return unitNames;
	  }
	
	  function simplify (units) {
	    // this turns ['s','m','s'] into ['s2','m']
	
	    var unitCounts = units.reduce(function(acc, unit) {
	      var unitCounter = acc[unit];
	      if(!unitCounter) {
	        acc.push(unitCounter = acc[unit] = [unit, 0]);
	      }
	
	      unitCounter[1]++;
	
	      return acc;
	    }, []);
	
	    return unitCounts.map(function(unitCount) {
	      return unitCount[0] + (unitCount[1] > 1 ? unitCount[1] : "");
	    });
	  }
	
	  function compareArray(array1, array2) {
	    if (array2.length !== array1.length) {
	      return false;
	    }
	    for (var i = 0; i < array1.length; i++) {
	      if (array2[i].compareArray) {
	        if (!array2[i].compareArray(array1[i])) {
	          return false;
	        }
	      }
	      if (array2[i] !== array1[i]) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  function round(val, decimals) {
	    return Math.round(val*Math.pow(10, decimals))/Math.pow(10, decimals);
	  }
	
	  function subtractTemperatures(lhs,rhs) {
	    var lhsUnits = lhs.units();
	    var rhsConverted = rhs.to(lhsUnits);
	    var dstDegrees = Qty(getDegreeUnits(lhsUnits));
	    return Qty({"scalar": lhs.scalar - rhsConverted.scalar, "numerator": dstDegrees.numerator, "denominator": dstDegrees.denominator});
	  }
	
	  function subtractTempDegrees(temp,deg) {
	    var tempDegrees = deg.to(getDegreeUnits(temp.units()));
	    return Qty({"scalar": temp.scalar - tempDegrees.scalar, "numerator": temp.numerator, "denominator": temp.denominator});
	  }
	
	  function addTempDegrees(temp,deg) {
	    var tempDegrees = deg.to(getDegreeUnits(temp.units()));
	    return Qty({"scalar": temp.scalar + tempDegrees.scalar, "numerator": temp.numerator, "denominator": temp.denominator});
	  }
	
	  function getDegreeUnits(units) {
	    if(units === "tempK") {
	      return "degK";
	    }
	    else if(units === "tempC") {
	      return "degC";
	    }
	    else if(units === "tempF") {
	      return "degF";
	    }
	    else if(units === "tempR") {
	      return "degR";
	    }
	    else {
	      throw new QtyError("Unknown type for temp conversion from: " + units);
	    }
	  }
	
	  function toDegrees(src,dst) {
	    var srcDegK = toDegK(src);
	    var dstUnits = dst.units();
	    var dstScalar;
	
	    if(dstUnits === "degK") {
	      dstScalar = srcDegK.scalar;
	    }
	    else if(dstUnits === "degC") {
	      dstScalar = srcDegK.scalar ;
	    }
	    else if(dstUnits === "degF") {
	      dstScalar = srcDegK.scalar * 9/5;
	    }
	    else if(dstUnits === "degR") {
	      dstScalar = srcDegK.scalar * 9/5;
	    }
	    else {
	      throw new QtyError("Unknown type for degree conversion to: " + dstUnits);
	    }
	
	    return Qty({"scalar": dstScalar, "numerator": dst.numerator, "denominator": dst.denominator});
	  }
	
	  function toDegK(qty) {
	    var units = qty.units();
	    var q;
	    if(units.match(/(deg)[CFRK]/)) {
	      q = qty.baseScalar;
	    }
	    else if(units === "tempK") {
	      q = qty.scalar;
	    }
	    else if(units === "tempC") {
	      q = qty.scalar;
	    }
	    else if(units === "tempF") {
	      q = qty.scalar * 5/9;
	    }
	    else if(units === "tempR") {
	      q = qty.scalar * 5/9;
	    }
	    else {
	      throw new QtyError("Unknown type for temp conversion from: " + units);
	    }
	
	    return Qty({"scalar": q, "numerator": ["<kelvin>"], "denominator": UNITY_ARRAY});
	  }
	
	  function toTemp(src,dst) {
	    var dstUnits = dst.units();
	    var dstScalar;
	
	    if(dstUnits === "tempK") {
	      dstScalar = src.baseScalar;
	    }
	    else if(dstUnits === "tempC") {
	      dstScalar = src.baseScalar - 273.15;
	    }
	    else if(dstUnits === "tempF") {
	      dstScalar = (src.baseScalar * 9/5) - 459.67;
	    }
	    else if(dstUnits === "tempR") {
	      dstScalar = src.baseScalar * 9/5;
	    }
	    else {
	      throw new QtyError("Unknown type for temp conversion to: " + dstUnits);
	    }
	
	    return Qty({"scalar": dstScalar, "numerator": dst.numerator, "denominator": dst.denominator});
	  }
	
	  function toTempK(qty) {
	    var units = qty.units();
	    var q;
	    if(units.match(/(deg)[CFRK]/)) {
	      q = qty.baseScalar;
	    }
	    else if(units === "tempK") {
	      q = qty.scalar;
	    }
	    else if(units === "tempC") {
	      q = qty.scalar + 273.15;
	    }
	    else if(units === "tempF") {
	      q = (qty.scalar + 459.67) * 5/9;
	    }
	    else if(units === "tempR") {
	      q = qty.scalar * 5/9;
	    }
	    else {
	      throw new QtyError("Unknown type for temp conversion from: " + units);
	    }
	
	    return Qty({"scalar": q, "numerator": ["<temp-K>"], "denominator": UNITY_ARRAY});
	  }
	
	  /**
	   * Safely multiplies numbers while avoiding floating errors
	   * like 0.1 * 0.1 => 0.010000000000000002
	   *
	   * @returns {number} result
	   * @param {...number} number
	   */
	  function mulSafe() {
	    var result = 1, decimals = 0;
	    for(var i = 0; i < arguments.length; i++) {
	      var arg = arguments[i];
	      decimals = decimals + getFractional(arg);
	      result *= arg;
	    }
	
	    return decimals !== 0 ? round(result, decimals) : result;
	  }
	
	  /**
	   * Safely divides two numbers while avoiding floating errors
	   * like 0.3 / 0.05 => 5.999999999999999
	   *
	   * @returns {number} result
	   * @param {number} num Numerator
	   * @param {number} den Denominator
	   */
	  function divSafe(num, den) {
	    if(den === 0) {
	      throw new QtyError("Divide by zero");
	    }
	
	    var factor = Math.pow(10, getFractional(den));
	    var invDen = factor/(factor*den);
	
	    return mulSafe(num, invDen);
	  }
	
	  function getFractional(num) {
	    // Check for NaNs or Infinities
	    if(!isFinite(num)) {
	      return 0;
	    }
	
	    // Faster than parsing strings
	    // http://jsperf.com/count-decimals/2
	    var count = 0;
	    while(num % 1 !== 0) {
	      num *= 10;
	      count++;
	    }
	    return count;
	  }
	
	  Qty.mulSafe = mulSafe;
	  Qty.divSafe = divSafe;
	
	  function cleanTerms(num, den) {
	    num = num.filter(function(val) {return val !== UNITY;});
	    den = den.filter(function(val) {return val !== UNITY;});
	
	    var combined = {};
	
	    var k;
	    for(var i = 0; i < num.length; i++) {
	      if(PREFIX_VALUES[num[i]]) {
	        k = [num[i], num[i+1]];
	        i++;
	      }
	      else {
	        k = num[i];
	      }
	      if(k && k !== UNITY) {
	        if(combined[k]) {
	          combined[k][0]++;
	        }
	        else {
	          combined[k] = [1, k];
	        }
	      }
	    }
	
	    for(var j = 0; j < den.length; j++) {
	      if(PREFIX_VALUES[den[j]]) {
	        k = [den[j], den[j+1]];
	        j++;
	      }
	      else {
	        k = den[j];
	      }
	      if(k && k !== UNITY) {
	        if(combined[k]) {
	          combined[k][0]--;
	        }
	        else {
	          combined[k] = [-1, k];
	        }
	      }
	    }
	
	    num = [];
	    den = [];
	
	    for(var prop in combined) {
	      if(combined.hasOwnProperty(prop)) {
	        var item = combined[prop];
	        var n;
	        if(item[0] > 0) {
	          for(n = 0; n < item[0]; n++) {
	            num.push(item[1]);
	          }
	        }
	        else if(item[0] < 0) {
	          for(n = 0; n < -item[0]; n++) {
	            den.push(item[1]);
	          }
	        }
	      }
	    }
	
	    if(num.length === 0) {
	      num = UNITY_ARRAY;
	    }
	    if(den.length === 0) {
	      den = UNITY_ARRAY;
	    }
	
	    // Flatten
	    num = num.reduce(function(a,b) {
	      return a.concat(b);
	    }, []);
	    den = den.reduce(function(a,b) {
	      return a.concat(b);
	    }, []);
	
	    return [num, den];
	  }
	
	  /*
	   * Identity function
	   */
	  function identity(value) {
	    return value;
	  }
	
	  /**
	   * Tests if a value is a string
	   *
	   * @param {} value - Value to test
	   *
	   * @returns {boolean} true if value is a string, false otherwise
	   */
	  function isString(value) {
	    return typeof value === "string" || value instanceof String;
	  }
	
	  /*
	   * Prefer stricter Number.isFinite if currently supported.
	   * To be dropped when ES6 is finalized. Obsolete browsers will
	   * have to use ES6 polyfills.
	   */
	  var isFinite = Number.isFinite || window.isFinite;
	  /**
	   * Tests if a value is a number
	   *
	   * @param {} value - Value to test
	   *
	   * @returns {boolean} true if value is a number, false otherwise
	   */
	  function isNumber(value) {
	    // Number.isFinite allows not to consider NaN or '1' as numbers
	    return isFinite(value);
	  }
	
	  /**
	   * Tests if a value is a Qty instance
	   *
	   * @param {} value - Value to test
	   *
	   * @returns {boolean} true if value is a Qty instance, false otherwise
	   */
	  function isQty(value) {
	    return value instanceof Qty;
	  }
	
	  /**
	   * Tests if a value is a Qty definition object
	   *
	   * @param {} value - Value to test
	   *
	   * @returns {boolean} true if value is a definition object, false otherwise
	   */
	  function isDefinitionObject(value) {
	    return value && typeof value === "object" && value.hasOwnProperty("scalar");
	  }
	
	  /**
	   * Asserts initialization value type is valid
	   *
	   * @param {} value - Value to test
	   *
	   * @throws {QtyError} if initialization value type is not valid
	   */
	  function assertValidInitializationValueType(value) {
	    if (!(isString(value) || isNumber(value) || isQty(value) || isDefinitionObject(value))) {
	      throw new QtyError("Only strings, numbers or quantities " +
	                         "accepted as initialization values");
	    }
	  }
	
	  // Setup
	  var PREFIX_VALUES = {};
	  var PREFIX_MAP = {};
	  var UNIT_VALUES = {};
	  var UNIT_MAP = {};
	  var OUTPUT_MAP = {};
	  for(var unitDef in UNITS) {
	    if(UNITS.hasOwnProperty(unitDef)) {
	      var definition = UNITS[unitDef];
	      if(definition[2] === "prefix") {
	        PREFIX_VALUES[unitDef] = definition[1];
	        for(var i = 0; i < definition[0].length; i++) {
	          PREFIX_MAP[definition[0][i]] = unitDef;
	        }
	      }
	      else {
	        UNIT_VALUES[unitDef] = {
	          scalar: definition[1],
	          numerator: definition[3],
	          denominator: definition[4]
	        };
	        for(var j = 0; j < definition[0].length; j++) {
	          UNIT_MAP[definition[0][j]] = unitDef;
	        }
	      }
	      OUTPUT_MAP[unitDef] = definition[0][0];
	    }
	  }
	  var PREFIX_REGEX = Object.keys(PREFIX_MAP).sort(function(a, b) {
	    return b.length - a.length;
	  }).join("|");
	  var UNIT_REGEX = Object.keys(UNIT_MAP).sort(function(a, b) {
	    return b.length - a.length;
	  }).join("|");
	  /*
	   * Minimal boundary regex to support units with Unicode characters
	   * \b only works for ASCII
	   */
	  var BOUNDARY_REGEX = "\\b|$";
	  var UNIT_MATCH = "(" + PREFIX_REGEX + ")??(" +
	                   UNIT_REGEX +
	                   ")(?:" + BOUNDARY_REGEX + ")";
	  var UNIT_MATCH_REGEX = new RegExp(UNIT_MATCH, "g"); // g flag for multiple occurences
	  var UNIT_TEST_REGEX = new RegExp("^\\s*(" + UNIT_MATCH + "\\s*\\*?\\s*)+$");
	
	  /**
	   * Custom error type definition
	   * @constructor
	   */
	  function QtyError() {
	    var err;
	    if(!this) { // Allows to instantiate QtyError without new()
	      err = Object.create(QtyError.prototype);
	      QtyError.apply(err, arguments);
	      return err;
	    }
	    err = Error.apply(this, arguments);
	    this.name = "QtyError";
	    this.message = err.message;
	    this.stack = err.stack;
	  }
	  QtyError.prototype = Object.create(Error.prototype, {constructor: { value: QtyError }});
	  Qty.Error = QtyError;
	
	  return Qty;
	}));


/***/ },
/* 29 */
/*!*********************************!*\
  !*** ../specification/index.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	  var subSchemas = {
	    'alarms': __webpack_require__(/*! ./schemas/groups/alarms.json */ 30),
	    'communication': __webpack_require__(/*! ./schemas/groups/communication.json */ 31),
	    'design': __webpack_require__(/*! ./schemas/groups/design.json */ 32),
	    'navigation': __webpack_require__(/*! ./schemas/groups/navigation.json */ 33),
	    'electrical_ac': __webpack_require__(/*! ./schemas/groups/electrical_ac.json */ 34),
	    'environment': __webpack_require__(/*! ./schemas/groups/environment.json */ 35),
	    'performance': __webpack_require__(/*! ./schemas/groups/performance.json */ 36),
	    'propulsion': __webpack_require__(/*! ./schemas/groups/propulsion.json */ 37),
	    'resources': __webpack_require__(/*! ./schemas/groups/resources.json */ 38),
	    'sensors': __webpack_require__(/*! ./schemas/groups/sensors.json */ 39),
	    'steering': __webpack_require__(/*! ./schemas/groups/steering.json */ 40),
	    'tanks': __webpack_require__(/*! ./schemas/groups/tanks.json */ 41)
	  };
	
	
	function getTv4() {
	  var tv4 = __webpack_require__(/*! tv4 */ 42);
	  var vesselSchema = __webpack_require__(/*! ./schemas/vessel.json */ 43);
	  tv4.addSchema('https://signalk.github.io/specification/schemas/vessel.json', vesselSchema);
	  var definitions = __webpack_require__(/*! ./schemas/definitions.json */ 44);
	  tv4.addSchema('https://signalk.github.io/specification/schemas/definitions.json', definitions);
	
	  for (var schema in subSchemas) {
	    tv4.addSchema('https://signalk.github.io/specification/schemas/groups/' + schema + '.json', subSchemas[schema]);
	  }
	  return tv4;
	}
	
	function validateFull(tree) {
	  var signalkSchema = __webpack_require__(/*! ./schemas/signalk.json */ 45);
	
	  var tv4 = getTv4();
	  var valid = getTv4().validateMultiple(tree, signalkSchema, true, true);
	  var result = tv4.validateResult(tree, signalkSchema, true, true);
	  //Hack: validateMultiple marks anyOf last match incorrectly as not valid with banUnknownProperties
	  //https://github.com/geraintluff/tv4/issues/128
	  valid.valid = result.valid;
	  return valid;
	}
	
	function validateDelta(delta, ignoreContext) {
	  var tv4 = __webpack_require__(/*! tv4 */ 42);
	  var deltaSchema = __webpack_require__(/*! ./schemas/delta.json */ 46);
	  var definitions = __webpack_require__(/*! ./schemas/definitions.json */ 44);
	  tv4.addSchema('https://signalk.github.io/specification/schemas/definitions.json', definitions);
	
	  if (ignoreContext) {
	    delta.context = 'ignored the context, so place a placeholder there';
	  }
	  var valid = tv4.validateMultiple(delta, deltaSchema, true, true);
	  return valid;
	}
	
	function validateWithSchema(msg, schemaName) { 
	  var tv4 = __webpack_require__(/*! tv4 */ 42);
	  var schema = __webpack_require__(/*! ./schemas */ 47)("./" + schemaName);
	  var valid = tv4.validateResult(msg,schema, true, true);
	  return valid;
	}
	
	function chaiAsPromised(chai, utils) {
	  "use strict";
	
	  var Assertion = chai.Assertion
	
	  function checkValidFullSignalK () { 
	    var result = validateFull(this._obj);
	    var message = result.errors.length === 0 ? '' : result.errors[result.errors.length-1].message + ':' + result.errors[result.errors.length-1].dataPath +
	      ' (' + (result.errors.length-1) + ' other errors not reported here)';
	    this.assert(
	      result.valid
	      , message
	      , 'expected #{this} to not be valid SignalK'
	      );
	  }
	  Assertion.addProperty('validSignalK', checkValidFullSignalK);
	  Assertion.addProperty('validFullSignalK', checkValidFullSignalK);
	  Assertion.addProperty('validSignalKVessel', function() {
	    this._obj = {
	      'vessels': {
	        'urn:mrn:imo:mmsi:230099999': this._obj
	      }
	    }
	    checkValidFullSignalK.call(this);
	  });
	  Assertion.addProperty('validSignalKVesselIgnoringIdentity', function() {
	    this._obj.mmsi = '230099999';
	    this._obj = {
	      'vessels': {
	        'urn:mrn:imo:mmsi:230099999': this._obj
	      }
	    }
	    checkValidFullSignalK.call(this);
	  });
	  Assertion.addProperty('validSignalKDelta', function () {
	    var result = validateDelta(this._obj);
	    var message = result.errors.length === 0 ? '' : result.errors[0].message + ':' + result.errors[0].dataPath + 
	      ' (' + (result.errors.length-1) + ' other errors not reported here)';
	    this.assert(
	      result.valid
	      , message
	      , 'expected #{this} to not be valid SignalK delta'
	      );
	  });
	  Assertion.addProperty('validSubscribeMessage', function () {
	    var result = validateWithSchema(msg, 'messages/subscribe');
	    var message = result.error ? result.error.message + ':' + result.error.dataPath : '';
	    this.assert(
	      result.valid
	      , message
	      , 'expected #{this} to not be valid SignalK subscribe message'
	      );
	  });
	  Assertion.addProperty('validUnsubscribeMessage', function () {
	    var result = validateWithSchema(msg, 'messages/unsubscribe');
	    var message = result.error ? result.error.message + ':' + result.error.dataPath : '';
	    this.assert(
	      result.valid
	      , message
	      , 'expected #{this} to not be valid SignalK unsubscribe message'
	      );
	  });
	}
	
	
	
	
	module.exports.validateFull = validateFull;
	module.exports.validateVessel = function(vesselData) {
	  return validateFull({
	      'vessels': {
	        'urn:mrn:imo:mmsi:230099999': vesselData
	      }
	    });
	}
	module.exports.validateDelta = validateDelta;
	module.exports.chaiModule = chaiAsPromised;
	module.exports.i18n = __webpack_require__(/*! ./i18n/ */ 54);
	module.exports.getTv4 = getTv4;
	module.exports.subSchemas = subSchemas;
	module.exports.units = __webpack_require__(/*! ./schemas/definitions */ 44).definitions.units;
	module.exports.metadata = __webpack_require__(/*! ./keyswithmetadata */ 56);


/***/ },
/* 30 */
/*!***************************************************!*\
  !*** ../specification/schemas/groups/alarms.json ***!
  \***************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"id": "https://signalk.github.io/specification/schemas/groups/alarms.json#",
		"title": "alarms",
		"description": "Alarms, their state, and actions. The alarm limits are set in any Signal K key.meta.zones array.",
		"required": false,
		"properties": {
			"alarmMethod": {
				"description": "Method to use to raise alarms",
				"$ref": "../definitions.json#/definitions/alarmMethod"
			},
			"alarmState": {
				"description": "Current alarm state",
				"$ref": "../definitions.json#/definitions/alarmValue"
			},
			"message": {
				"description": "Message to display or speak",
				"type": "string"
			},
			"timestamp": {
				"description": "timestamp of the last update to this data",
				"$ref": "../definitions.json#/definitions/timestamp"
			},
			"source": {
				"description": "Source of this data",
				"$ref": "../definitions.json#/definitions/source"
			}
		}
	};

/***/ },
/* 31 */
/*!**********************************************************!*\
  !*** ../specification/schemas/groups/communication.json ***!
  \**********************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/communication.json#",
		"description": "Schema describing the communication child-object of a Vessel.",
		"title": "communication",
		"properties": {
			"callsignDsc": {
				"type": "string",
				"description": "Callsign for DSC communication",
				"example": "ZL1234"
			},
			"callsignHf": {
				"type": "string",
				"description": "Callsign for HF communication",
				"example": "ZL3RTH"
			},
			"callsignVhf": {
				"type": "string",
				"description": "Callsign for VHF communication",
				"example": "ZM2038"
			},
			"phoneNumber": {
				"type": "string",
				"description": "Phone number of skipper",
				"example": "+64xxxxxx"
			},
			"emailHf": {
				"type": "string",
				"description": "Email address to be used for HF email (Winmail, Airmail, Sailmail)",
				"example": "motu@xxx.co.nz"
			},
			"email": {
				"type": "string",
				"description": "Regular email for the skipper",
				"example": "robert@xxx.co.nz"
			},
			"satPhoneNumber": {
				"type": "string",
				"description": "Satellite phone number for vessel.",
				"example": "+64xxxxxx"
			},
			"skipperName": {
				"type": "string",
				"description": "Full name of the skipper of the vessel.",
				"example": "Fabian Tollenaar"
			},
			"crewNames": {
				"type": "array",
				"description": "Array with the names of the crew",
				"additionalProperties": [
					{
						"type": "string",
						"description": "Name of a crew member of the vessel.",
						"example": "Catherine"
					}
				]
			}
		}
	};

/***/ },
/* 32 */
/*!***************************************************!*\
  !*** ../specification/schemas/groups/design.json ***!
  \***************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/design.json#",
		"description": "An object describing the vessels primary dimensions and statistics.",
		"title": "design",
		"properties": {
			"displacement": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "The displacement of the vessel",
				"units": "kg"
			},
			"draft": {
				"type": "object",
				"title": "draft",
				"description": "The draft of the vessel",
				"properties": {
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					},
					"minimum": {
						"description": "The minimum draft of the vessel",
						"type": "number",
						"units": "m"
					},
					"maximum": {
						"description": "The maximum draft of the vessel",
						"type": "number",
						"units": "m"
					},
					"canoe": {
						"description": "The draft of the vessel without protrusions such as keel, centerboard, rudder",
						"type": "number",
						"units": "m"
					}
				}
			},
			"length": {
				"type": "object",
				"title": "length",
				"description": "The various lengths of the vessel",
				"properties": {
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					},
					"overall": {
						"type": "number",
						"description": "Length overall",
						"units": "m"
					},
					"hull": {
						"type": "number",
						"description": "Length of hull",
						"units": "m"
					},
					"waterline": {
						"type": "number",
						"description": "Length at waterline",
						"units": "m"
					}
				}
			},
			"keel": {
				"type": "object",
				"title": "keel",
				"description": "Information about the vessel's keel",
				"properties": {
					"type": {
						"type": "string",
						"description": "The type of keel.",
						"enum": [
							"long",
							"fin",
							"flare",
							"bulb",
							"wing",
							"centerboard",
							"kanting",
							"lifting",
							"daggerboard"
						]
					},
					"angle": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "A number indicating at which angle the keel currently is (in case of a canting keel), negative to port.",
						"units": "rad"
					},
					"lift": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "In the case of a lifting keel, centreboard or daggerboard, the part of the keel which is extended. 0 is 'all the way up' and 1 is 'all the way down'. 0.8 would be 80% down.",
						"units": "ratio",
						"example": 0.8
					},
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					}
				}
			},
			"beam": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "Beam length",
				"units": "m"
			},
			"airHeight": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "Total height of the vessel",
				"units": "m"
			},
			"rigging": {
				"type": "object",
				"title": "rigging",
				"description": "Information about the vessel's rigging",
				"properties": {
					"configuration": {
						"type": "string",
						"description": "The configuration of the rigging",
						"example": "sloop"
					},
					"masts": {
						"type": "number",
						"description": "The number of masts on the vessel."
					},
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					}
				}
			}
		}
	};

/***/ },
/* 33 */
/*!*******************************************************!*\
  !*** ../specification/schemas/groups/navigation.json ***!
  \*******************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/navigation.json#",
		"description": "Schema describing the navigation child-object of a Vessel.",
		"title": "navigation",
		"properties": {
			"courseOverGroundMagnetic": {
				"description": "Course over ground (magnetic)",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "rad"
			},
			"courseOverGroundTrue": {
				"description": "Course over ground (true)",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "rad"
			},
			"activeRoute": {
				"type": "object",
				"title": "Active Route",
				"description": "The currently active route",
				"properties": {
					"timestamp": {
						"$ref": "../definitions.json#/definitions/timestamp",
						"description": "Time of last update to active route"
					},
					"source": {
						"$ref": "../definitions.json#/definitions/source",
						"description": "Source of last update to active route"
					},
					"bearingActual": {
						"type": "number",
						"description": "The current bearing of the next waypoint relative to true North",
						"units": "rad"
					},
					"distanceActual": {
						"type": "number",
						"description": "The current distance to the next waypoint",
						"units": "m"
					},
					"bearingDirect": {
						"type": "number",
						"description": "The bearing relative to true North from last waypoint to the next waypoint",
						"units": "rad"
					},
					"courseRequired": {
						"type": "number",
						"description": "The course relative to true North towards the next waypoint",
						"units": "rad"
					},
					"eta": {
						"$ref": "../definitions.json#/definitions/timestamp",
						"description": "The estimated time of arrival at the end of the current route"
					},
					"route": {
						"type": "string",
						"description": "A pointer to the current route, found in the routes list"
					},
					"startTime": {
						"$ref": "../definitions.json#/definitions/timestamp",
						"description": "The time this route was activated"
					},
					"waypoint": {
						"type": "object",
						"title": "waypoint",
						"description": "The last and next waypoints data",
						"properties": {
							"lastTime": {
								"$ref": "../definitions.json#/definitions/timestamp",
								"description": "The time the last waypoint was reached"
							},
							"last": {
								"type": "string",
								"description": "The last waypoint, a pointer to the list of waypoints"
							},
							"nextEta": {
								"$ref": "../definitions.json#/definitions/timestamp",
								"description": "Estimated time of arrival at the next waypoint",
								"example": "2014-03-24T00:15:41Z"
							},
							"next": {
								"type": "string",
								"description": "A pointer to the next waypoint, found in the waypoints list"
							},
							"xte": {
								"type": "number",
								"description": "Cross track error",
								"units": "m"
							}
						}
					}
				}
			},
			"magneticVariation": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "The magnetic variation (declination) at the current position",
				"units": "rad"
			},
			"destination": {
				"title": "destination",
				"description": "The intended destination of this trip",
				"type": "object",
				"properties": {
					"eta": {
						"$ref": "../definitions.json#/definitions/timestamp"
					},
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					},
					"longitude": {
						"type": "number",
						"description": "Longitude of the destination",
						"units": "deg",
						"example": 4.98765245
					},
					"latitude": {
						"type": "number",
						"description": "Latitude of the destination",
						"units": "deg",
						"example": 52.0987654
					},
					"altitude": {
						"type": "number",
						"description": "Altitude of the destination",
						"units": "m"
					}
				}
			},
			"gnss": {
				"type": "object",
				"title": "gnss",
				"description": "Global satellite navigation meta information",
				"properties": {
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					},
					"quality": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "Quality of the satellite fix"
					},
					"satellites": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "Number of satellites"
					},
					"antennaAltitude": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "Altitude of antenna",
						"units": "m"
					},
					"horizontalDilution": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "Horizontal position error"
					},
					"geoidalSeparation": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "Difference between WGS84 earth ellipsoid and mean sea level"
					},
					"differentialAge": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "Age of DGPS data",
						"units": "s"
					},
					"differentialReference": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "ID of DGPS base station"
					}
				}
			},
			"headingMagnetic": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "Current magnetic heading of the vessels",
				"units": "rad"
			},
			"headingTrue": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "The current true heading of the vessel",
				"units": "rad"
			},
			"position": {
				"type": "object",
				"title": "position",
				"description": "The position of the vessel in 3 dimensions",
				"properties": {
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					},
					"longitude": {
						"type": "number",
						"description": "Longitude of boat",
						"units": "deg",
						"example": 4.98765245
					},
					"latitude": {
						"type": "number",
						"description": "Latitude of boat",
						"units": "deg",
						"example": 52.0987654
					},
					"altitude": {
						"type": "number",
						"units": "m",
						"description": "Altitude of boat"
					}
				}
			},
			"attitude": {
				"type": "object",
				"title": "Attitude",
				"description": "Vessel attitude: roll, pitch and yaw",
				"properties": {
					"roll": {
						"type": "number",
						"description": "Vessel roll, +ve is list to starboard",
						"units": "rad"
					},
					"pitch": {
						"type": "number",
						"description": "Pitch, +ve is bow up",
						"units": "rad"
					},
					"yaw": {
						"type": "number",
						"description": "Yaw, +ve is heading change to starboard",
						"units": "rad"
					},
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					}
				}
			},
			"rateOfTurn": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "Rate of turn",
				"units": "rad/s"
			},
			"speedOverGround": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "Vessel speed over ground",
				"units": "m/s"
			},
			"speedThroughWater": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "Vessel speed through the water",
				"units": "m/s"
			},
			"log": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "Log value",
				"units": "m"
			},
			"logTrip": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "Trip log value",
				"units": "m"
			},
			"state": {
				"type": "object",
				"title": "state",
				"description": "Current navigational state of the vessel",
				"properties": {
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					},
					"value": {
						"type": "string",
						"enum": [
							"under way using engine",
							"at anchor",
							"not under command",
							"restricted maneuverability",
							"constrained by her draught",
							"moored",
							"aground",
							"engaged in fishing",
							"under way sailing",
							"not defined (example)"
						]
					}
				}
			},
			"anchor": {
				"type": "object",
				"title": "anchor",
				"description": "The anchor data, for anchor watch etc",
				"properties": {
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					},
					"maxRadius": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "Radius of anchor alarm boundary. The distance from anchor to the center of the boat",
						"units": "m"
					},
					"currentRadius": {
						"$ref": "../definitions.json#/definitions/numberValue",
						"description": "Current distance to anchor",
						"units": "m"
					},
					"position": {
						"type": "object",
						"title": "position",
						"description": "The actual anchor position of the vessel in 3 dimensions, probably an estimate at best",
						"properties": {
							"source": {
								"description": "Source of this data",
								"$ref": "../definitions.json#/definitions/source"
							},
							"timestamp": {
								"description": "timestamp of the last update to this data",
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"longitude": {
								"type": "number",
								"description": "Longitude of the anchor",
								"units": "deg",
								"example": 4.98765245
							},
							"latitude": {
								"type": "number",
								"description": "Latitude of the anchor",
								"units": "deg",
								"example": 52.0987654
							},
							"altitude": {
								"type": "number",
								"description": "Altitude of the anchor",
								"units": "m"
							}
						}
					}
				}
			}
		}
	};

/***/ },
/* 34 */
/*!**********************************************************!*\
  !*** ../specification/schemas/groups/electrical_ac.json ***!
  \**********************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/electrical_ac.json#",
		"description": "Schema describing electric measurements pertaining to shore power, AC generators, etc.",
		"title": "AC Electrical Properties",
		"properties": {
			"bus1": {
				"type": "object",
				"title": "Bus #1",
				"description": "Main AC power bus on the vessel",
				"properties": {
					"phaseA": {
						"type": "object",
						"title": "Bus #1, Phase A",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between bus phase A and phase B.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between bus phase A and neutral.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Bus phase A frequency.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							}
						}
					},
					"phaseB": {
						"type": "object",
						"title": "Bus #1, Phase B",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between bus phase B and phase C.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between bus phase B and neutral.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Bus phase B frequency.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							}
						}
					},
					"phaseC": {
						"type": "object",
						"title": "Bus #1, Phase C",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between bus phase C and phase A.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between bus phase C and neutral.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Bus phase C frequency.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							}
						}
					},
					"average": {
						"type": "object",
						"title": "Bus #1, Average",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average RMS voltage measured between two hot legs of a 3-phase or split-phase bus.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average RMS voltage measured between any hot leg and neutral in a 3-phase, split-phase, or single phase bus.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average frequency of the bus.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							}
						}
					}
				}
			},
			"utility": {
				"type": "object",
				"title": "Utility (Shore Power)",
				"description": "Vessel's shore power connection",
				"properties": {
					"phaseA": {
						"type": "object",
						"title": "Utility, Phase A",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between utility phase A and phase B.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between utility phase A and neutral.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Utility phase A frequency.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							},
							"reactivePower": {
								"type": "object",
								"title": "Reactive power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"reactivePower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase A reactive power",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 5000
									},
									"powerFactor": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase A power factor",
										"minimum": -1,
										"maximum": 1,
										"example": 0.97
									},
									"powerFactorLagging": {
										"enum": [
											"leading",
											"lagging",
											"error",
											"not available"
										],
										"type": "string",
										"description": "Utility phase A lead/lag status.",
										"example": "leading"
									}
								}
							},
							"realPower": {
								"type": "object",
								"title": "Real Power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"realPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase A real power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									},
									"apparentPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase A apparent power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									}
								}
							}
						}
					},
					"phaseB": {
						"type": "object",
						"title": "Utility, Phase B",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between utility phase B and phase C.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between utility phase B and neutral.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Utility phase B frequency.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							},
							"reactivePower": {
								"type": "object",
								"title": "Reactive power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"reactivePower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase B reactive power",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 5000
									},
									"powerFactor": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase B power factor",
										"minimum": -1,
										"maximum": 1,
										"example": 0.97
									},
									"powerFactorLagging": {
										"enum": [
											"leading",
											"lagging",
											"error",
											"not available"
										],
										"description": "Utility phase B lead/lag status.",
										"example": "leading",
										"type": "string"
									}
								}
							},
							"realPower": {
								"type": "object",
								"title": "Real Power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"realPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase B real power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									},
									"apparentPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase B apparent power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									}
								}
							}
						}
					},
					"phaseC": {
						"type": "object",
						"title": "Utility, Phase C",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between utility phase C and phase A.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between utility phase C and neutral.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Utility phase C frequency.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							},
							"reactivePower": {
								"type": "object",
								"title": "Reactive power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"reactivePower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase C reactive power",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 5000
									},
									"powerFactor": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase C power factor",
										"minimum": -1,
										"maximum": 1,
										"example": 0.97
									},
									"powerFactorLagging": {
										"enum": [
											"leading",
											"lagging",
											"error",
											"not available"
										],
										"description": "Utility phase C lead/lag status.",
										"example": "leading",
										"type": "string"
									}
								}
							},
							"realPower": {
								"type": "object",
								"title": "Real Power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"realPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase C real power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									},
									"apparentPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Utility phase C apparent power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									}
								}
							}
						}
					},
					"average": {
						"type": "object",
						"title": "Utility, Average",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average RMS voltage measured between two hot legs of a 3-phase or split-phase utility connection.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average RMS voltage measured between any hot leg and neutral in a 3-phase, split-phase, or single phase utility connection.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average frequency of the utility connection.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							}
						}
					},
					"energy": {
						"type": "object",
						"title": "Utility, Energy Totals",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"totalExport": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Total watt hours exported by the utility",
								"units": "J"
							},
							"totalImport": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Total watt hours imported by the utility",
								"units": "J"
							}
						}
					},
					"reactivePower": {
						"type": "object",
						"title": "Utility, Reactive Power",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"reactivePower": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "In a normally operating system, the reactive power will be less than half the real power. In order to allow for fault conditions, it is desirable to have the same range for reactive power as for real power. Reactive power is a signed quantity, like real power.",
								"units": "W",
								"minimum": -2000000000,
								"maximum": 2211081215,
								"example": 5000
							},
							"powerFactor": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average power factor for utility.",
								"minimum": -1,
								"maximum": 1,
								"example": 0.97
							},
							"powerFactorLagging": {
								"description": "Lead/lag status for utility.",
								"example": "Leading",
								"type": "string",
								"enum": [
									"leading",
									"lagging",
									"error",
									"not available"
								]
							}
						}
					},
					"realPower": {
						"type": "object",
						"title": "Utility, Real Power",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"realPower": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Total real power delivered by the utility",
								"comment": "Real power must be signed since power may flow in both directions.",
								"units": "W",
								"minimum": -2000000000,
								"maximum": 2211081215,
								"example": 10500
							},
							"apparentPower": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Total apparent power delivered by the utility. This is an unsigned quantity, but is delivered signed in order to have an equivalent range to real power.",
								"units": "W",
								"minimum": -2000000000,
								"maximum": 2211081215,
								"example": 10500
							}
						}
					}
				}
			},
			"generator": {
				"type": "object",
				"title": "Generator",
				"description": "Vessel's generator",
				"properties": {
					"phaseA": {
						"type": "object",
						"title": "Generator, Phase A",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between generator phase A and phase B.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between generator phase A and neutral.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Generator phase A frequency.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							},
							"reactivePower": {
								"type": "object",
								"title": "Reactive power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"reactivePower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase A reactive power",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 5000
									},
									"powerFactor": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase A power factor",
										"minimum": -1,
										"maximum": 1,
										"example": 0.97
									},
									"powerFactorLagging": {
										"description": "Generator phase A lead/lag status.",
										"example": "leading",
										"type": "string",
										"enum": [
											"leading",
											"lagging",
											"error",
											"not available"
										]
									}
								}
							},
							"realPower": {
								"type": "object",
								"title": "Real Power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"realPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase A real power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									},
									"apparentPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase A apparent power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									}
								}
							}
						}
					},
					"phaseB": {
						"type": "object",
						"title": "Generator, Phase B",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between generator phase B and phase C.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between generator phase B and neutral.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Generator phase B frequency.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							},
							"reactivePower": {
								"type": "object",
								"title": "Reactive power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"reactivePower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase B reactive power",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 5000
									},
									"powerFactor": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase B power factor",
										"minimum": -1,
										"maximum": 1,
										"example": 0.97
									},
									"powerFactorLagging": {
										"description": "Generator phase B lead/lag status.",
										"example": "leading",
										"type": "string",
										"enum": [
											"leading",
											"lagging",
											"error",
											"not available"
										]
									}
								}
							},
							"realPower": {
								"type": "object",
								"title": "Real Power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"realPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase B real power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									},
									"apparentPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase B apparent power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									}
								}
							}
						}
					},
					"phaseC": {
						"type": "object",
						"title": "Generator, Phase C",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between generator phase C and phase A.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "RMS voltage measured between generator phase C and neutral.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Generator phase C frequency.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							},
							"reactivePower": {
								"type": "object",
								"title": "Reactive power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"reactivePower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase C reactive power",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 5000
									},
									"powerFactor": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase C power factor",
										"minimum": -1,
										"maximum": 1,
										"example": 0.97
									},
									"powerFactorLagging": {
										"enum": [
											"leading",
											"lagging",
											"error",
											"not available"
										],
										"description": "Generator phase C lead/lag status.",
										"example": "leading",
										"type": "string"
									}
								}
							},
							"realPower": {
								"type": "object",
								"title": "Real Power",
								"properties": {
									"timestamp": {
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"source": {
										"$ref": "../definitions.json#/definitions/source"
									},
									"realPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase C real power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									},
									"apparentPower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"description": "Generator phase C apparent power.",
										"units": "W",
										"minimum": -2000000000,
										"maximum": 2211081215,
										"example": 10500
									}
								}
							}
						}
					},
					"average": {
						"type": "object",
						"title": "Generator, Average",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"lineLineVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average RMS voltage measured between two hot legs of a 3-phase or split-phase generator.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 480
							},
							"lineNeutralVoltage": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average RMS voltage measured between any hot leg and neutral in a 3-phase, split-phase, or single phase generator.",
								"units": "V",
								"minimum": 0,
								"maximum": 64255,
								"example": 277
							},
							"frequency": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average frequency of the generator output.",
								"units": "Hz",
								"minimum": 0,
								"maximum": 501.9921875,
								"example": 60
							}
						}
					},
					"energy": {
						"type": "object",
						"title": "Generator, Energy Totals",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"totalExport": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Total energy exported by the generator",
								"units": "J"
							},
							"totalImport": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Total energy imported by the generator",
								"units": "J"
							}
						}
					},
					"reactivePower": {
						"type": "object",
						"title": "Generator, Reactive Power",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"reactivePower": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Reactive power",
								"comment": "In a normally operating system, the reactive power will be less than half the real power. In order to allow for fault conditions, it is desirable to have the same range for reactive power as for real power",
								"units": "W",
								"minimum": -2000000000,
								"maximum": 2211081215,
								"example": 5000
							},
							"powerFactor": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Average power factor for the generator.",
								"minimum": -1,
								"maximum": 1,
								"example": 0.97
							},
							"powerFactorLagging": {
								"enum": [
									"leading",
									"lagging",
									"error",
									"not available"
								],
								"description": "Lead/lag status for the generator.",
								"example": "leading",
								"type": "string"
							}
						}
					},
					"realPower": {
						"type": "object",
						"title": "Generator, Real Power",
						"properties": {
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							},
							"realPower": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Total real power delivered by the generator. Real power must be signed since power may flow in both directions.",
								"units": "W",
								"minimum": -2000000000,
								"maximum": 2211081215,
								"example": 10500
							},
							"apparentPower": {
								"#ref": "../definitions.json#/definitions/numberValue",
								"description": "Total apparent power delivered by the generator. This is an unsigned quantity, but is delivered signed in order to have an equivalent range to real power.",
								"units": "W",
								"minimum": -2000000000,
								"maximum": 2211081215,
								"example": 10500
							}
						}
					}
				}
			}
		}
	};

/***/ },
/* 35 */
/*!********************************************************!*\
  !*** ../specification/schemas/groups/environment.json ***!
  \********************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/environmental.json#",
		"description": "Schema describing the environmental child-object of a Vessel.",
		"title": "environment",
		"properties": {
			"airPressureChangeRateAlarm": {
				"description": "Change per hour which will cause an alarm",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "Pa"
			},
			"airPressure": {
				"description": "Current air pressure",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "Pa"
			},
			"airTemp": {
				"description": "Current air temperature",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "K"
			},
			"depth": {
				"title": "depth",
				"type": "object",
				"description": "Depth related data",
				"properties": {
					"belowKeel": {
						"description": "Depth below keel",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m"
					},
					"belowTransducer": {
						"description": "Depth below Transducer",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m"
					},
					"belowSurface": {
						"description": "Depth from surface",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m"
					},
					"transducerToKeel": {
						"description": "Depth from the transducer to the bottom of the keel",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m"
					},
					"surfaceToTransducer": {
						"description": "Depth transducer is below the water",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m"
					}
				}
			},
			"humidity": {
				"description": "Current relative humidity",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "ratio"
			},
			"salinity": {
				"description": "Water salinity",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "ratio"
			},
			"current": {
				"type": "object",
				"title": "current",
				"description": "Direction and strength of current affecting the vessel",
				"properties": {
					"timestamp": {
						"$ref": "../definitions.json#/definitions/timestamp"
					},
					"source": {
						"$ref": "../definitions.json#/definitions/source"
					},
					"drift": {
						"type": "number",
						"description": "The speed component of the water current vector",
						"example": 3.12,
						"units": "m/s"
					},
					"setTrue": {
						"type": "number",
						"description": "The direction component of the water current vector referenced to true (geographic) north",
						"example": 123.45,
						"units": "rad"
					},
					"setMagnetic": {
						"type": "number",
						"description": "The direction component of the water current vector referenced to magnetic north",
						"example": 131.22,
						"units": "rad"
					}
				}
			},
			"tide": {
				"type": "object",
				"title": "tide",
				"description": "Tide data",
				"properties": {
					"heightHigh": {
						"description": "Next high tide",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m"
					},
					"heightNow": {
						"description": "The current tide height",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m"
					},
					"heightLow": {
						"description": "The next low tide height",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m"
					},
					"timeLow": {
						"description": "Time of the next low tide in UTC",
						"$ref": "../definitions.json#/definitions/timestamp"
					},
					"timeHigh": {
						"description": "Time of next high tide in UTC",
						"$ref": "../definitions.json#/definitions/timestamp"
					}
				}
			},
			"waterTemp": {
				"description": "Current water temperature",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "K"
			},
			"wind": {
				"type": "object",
				"title": "wind",
				"description": "Wind data.",
				"properties": {
					"angleApparent": {
						"description": "Apparent wind angle, negative to port",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"angleTrueGround": {
						"description": "True wind angle based on speed over ground, negative to port",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"angleTrueWater": {
						"description": "True wind angle based on speed through water, negative to port",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"directionChangeAlarm": {
						"description": "The angle the wind needs to shift to raise an alarm",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"directionTrue": {
						"description": "The wind direction relative to true north",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"directionMagnetic": {
						"description": "The wind direction relative to magnetic north",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"speedAlarm": {
						"description": "The speed above which a wind alarm will be raised",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m/s"
					},
					"speedTrue": {
						"description": "Wind speed over water (as calculated from speedApparent and vessel's speed through water)",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m/s"
					},
					"speedOverGround": {
						"description": "Wind speed over ground (as calculated from speedApparent and vessel's speed over ground)",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m/s"
					},
					"speedApparent": {
						"description": "Apparent wind speed",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "m/s"
					}
				}
			}
		}
	};

/***/ },
/* 36 */
/*!********************************************************!*\
  !*** ../specification/schemas/groups/performance.json ***!
  \********************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/performance.json#",
		"description": "Schema describing the performance child-object of a Vessel.",
		"title": "performance",
		"properties": {
			"polarSpeed": {
				"description": "The current polar speed based on current polar, trueWindSpeed and truewindAngle.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "m/s"
			},
			"polarSpeedRatio": {
				"description": "The ratio of current speed through water to the polar speed.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "ratio"
			},
			"velocityMadeGood": {
				"description": "The current velocity made good derived from the speed through water and appearant wind angle. A positive value is heading to upwind, negative to downwind.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "m/s"
			},
			"velocityMadeGoodToWaypoint": {
				"description": "The current velocity made good to the next waypoint derived from the speedOverGround, courseOverGround.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "m/s"
			},
			"beatAngle": {
				"description": "The true wind beat angle for the best velocity made good based on current current polar and trueWindSpeed.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "rad"
			},
			"beatAngleVelocityMadeGood": {
				"description": "The velocity made good for the beat angle.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "m/s"
			},
			"beatAngleTargetSpeed": {
				"description": "The target speed for the beat angle.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "m/s"
			},
			"gybeAngle": {
				"description": "The true wind gybe angle for the best velocity made good downwind based on current polar and trueWindSpeed.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "rad"
			},
			"gybeAngleVelocityMadeGood": {
				"description": "The velocity made good for the gybe angle",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "m/s"
			},
			"gybeAngleTargetSpeed": {
				"description": "The target speed for the gybe angle.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "m/s"
			},
			"leeway": {
				"description": "Current leeway",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "rad"
			},
			"tackMagnetic": {
				"description": "Magnetic heading on opposite tack.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "rad"
			},
			"tackTrue": {
				"description": "True heading on opposite tack.",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "rad"
			}
		}
	};

/***/ },
/* 37 */
/*!*******************************************************!*\
  !*** ../specification/schemas/groups/propulsion.json ***!
  \*******************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/propulsion.json#",
		"title": "propulsion",
		"description": "An engine, named by a unique name within this vessel",
		"properties": {
			"engineType": {
				"type": "object",
				"description": "The type of engine",
				"properties": {
					"value": {
						"type": "string",
						"enum": [
							"diesel inboard",
							"diesel outboard",
							"petrol inboard",
							"petrol outboard",
							"electric inboard",
							"electric outboard"
						]
					},
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					}
				}
			},
			"state": {
				"type": "object",
				"description": "The current state of the engine",
				"properties": {
					"value": {
						"type": "string",
						"enum": [
							"stopped",
							"started",
							"unusable"
						]
					},
					"source": {
						"description": "Source of this data",
						"$ref": "../definitions.json#/definitions/source"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "../definitions.json#/definitions/timestamp"
					}
				}
			},
			"revolutions": {
				"description": "Engine revolutions",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "Hz"
			},
			"temperature": {
				"description": "Engine temperature",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "K"
			},
			"oilTemperature": {
				"description": "Oil temperature",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "K"
			},
			"oilPressure": {
				"description": "Oil pressure",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "Pa"
			},
			"waterTemperature": {
				"description": "Water temperature",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "K"
			},
			"exhaustTemperature": {
				"description": "Exhaust temperature",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "K"
			},
			"fuelRate": {
				"description": "Fuel consumption rate",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "m3/s"
			}
		}
	};

/***/ },
/* 38 */
/*!******************************************************!*\
  !*** ../specification/schemas/groups/resources.json ***!
  \******************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/resources.json#",
		"title": "resources",
		"description": "Resources to aid in navigation and operation of the vessel",
		"properties": {
			"charts": {
				"type": "object",
				"title": "chart",
				"description": "A holder for charts, each named with their chart code",
				"patternProperties": {
					"(^[2-7][0-9]{8,8}$|^[A-F0-9]{8,8}$)": {
						"type": "object",
						"description": "A chart",
						"properties": {
							"name": {
								"type": "string",
								"description": "Chart common name"
							},
							"identifier": {
								"type": "string",
								"description": "Chart number"
							},
							"description": {
								"type": "string",
								"description": "A description of the chart"
							},
							"tilemapUrl": {
								"type": "string",
								"description": "A url to the tilemap of the chart for use in TMS chartplotting apps"
							},
							"chartUrl": {
								"type": "string",
								"description": "A url to the chart file's storage location"
							},
							"chartFormat": {
								"type": "string",
								"description": "The format of the chart",
								"enum": [
									"gif",
									"geotiff",
									"kap",
									"png",
									"jpg",
									"kml",
									"wkt",
									"topojson",
									"geojson",
									"gpx"
								]
							},
							"timestamp": {
								"description": "timestamp of the last update to this data",
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"description": "Source of this data",
								"$ref": "../definitions.json#/definitions/source"
							}
						}
					}
				}
			},
			"routes": {
				"type": "object",
				"title": "route",
				"description": "A holder for routes, each named with a UUID",
				"patternProperties": {
					"(^[2-7][0-9]{8,8}$|^[A-F0-9]{8,8}$)": {
						"type": "object",
						"description": "A route, named with a UUID",
						"properties": {
							"name": {
								"type": "string",
								"description": "Route's common name"
							},
							"description": {
								"type": "string",
								"description": "A description of the route"
							},
							"distance": {
								"description": "Total distance from start to end",
								"$ref": "../definitions.json#/definitions/numberValue",
								"units": "m"
							},
							"waypoints": {
								"type": "array",
								"items": {
									"type": "string",
									"description": "Pointers to waypoint UUIDs"
								}
							},
							"timestamp": {
								"description": "timestamp of the last update to this data",
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"description": "Source of this data",
								"$ref": "../definitions.json#/definitions/source"
							}
						}
					}
				}
			},
			"notes": {
				"type": "object",
				"title": "notes",
				"description": "A holder for notes about regions, each named with a UUID. Notes might include navigation or cruising info, images, or anything",
				"patternProperties": {
					"(^[2-7][0-9]{8,8}$|^[A-F0-9]{8,8}$)": {
						"type": "object",
						"description": "A note about a region, named with a UUID. Notes might include navigation or cruising info, images, or anything",
						"properties": {
							"title": {
								"type": "string",
								"description": "Note's common name"
							},
							"description": {
								"type": "string",
								"description": "A textual description of the note"
							},
							"region": {
								"type": "string",
								"description": "Pointer to region UUID"
							},
							"mimeType": {
								"type": "string",
								"description": "MIME type of the note"
							},
							"url": {
								"type": "string",
								"description": "Location of the note"
							},
							"timestamp": {
								"description": "timestamp of the last update to this data",
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"description": "Source of this data",
								"$ref": "../definitions.json#/definitions/source"
							}
						}
					}
				}
			},
			"regions": {
				"type": "object",
				"title": "region",
				"description": "A holder for regions, each named with a UUID",
				"patternProperties": {
					"(^[2-7][0-9]{8,8}$|^[A-F0-9]{8,8}$)": {
						"type": "object",
						"description": "A region of interest, named with a UUID",
						"properties": {
							"name": {
								"type": "string",
								"description": "Region's common name"
							},
							"description": {
								"type": "string",
								"description": "A description of the region"
							},
							"waypoints": {
								"type": "array",
								"description": "The set of waypoints that define the edges of the region",
								"items": {
									"type": "string",
									"description": "Pointer to waypoint UUID"
								}
							},
							"timestamp": {
								"description": "timestamp of the last update to this data",
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"description": "Source of this data",
								"$ref": "../definitions.json#/definitions/source"
							}
						}
					}
				}
			},
			"waypoints": {
				"type": "object",
				"title": "waypoint",
				"description": "A holder for waypoints, each named with a UUID",
				"patternProperties": {
					"(^[2-7][0-9]{8,8}$|^[A-F0-9]{8,8}$)": {
						"type": "object",
						"description": "A waypoint, named with a UUID",
						"properties": {
							"name": {
								"type": "string",
								"description": "Waypoint's common name"
							},
							"position": {
								"type": "object",
								"description": "The position of the waypoint in 3 dimensions",
								"properties": {
									"source": {
										"description": "Source of this data",
										"$ref": "../definitions.json#/definitions/source"
									},
									"timestamp": {
										"description": "timestamp of the last update to this data",
										"$ref": "../definitions.json#/definitions/timestamp"
									},
									"longitude": {
										"type": "number",
										"description": "Longitude",
										"units": "deg"
									},
									"latitude": {
										"type": "number",
										"description": "Latitude",
										"units": "deg"
									},
									"altitude": {
										"type": "number",
										"description": "Altitude",
										"units": "m"
									}
								}
							},
							"description": {
								"type": "string",
								"description": "A description of the waypoint"
							},
							"type": {
								"type": "string",
								"description": "The type of waypoint",
								"enum": [
									"location",
									"fish",
									"hazard",
									"anchorage",
									"mark"
								]
							}
						}
					}
				}
			}
		}
	};

/***/ },
/* 39 */
/*!****************************************************!*\
  !*** ../specification/schemas/groups/sensors.json ***!
  \****************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/sensors.json#",
		"description": "An object describing an individual sensor. It should be an object in vessel, named using a unique name or UUID",
		"title": "sensor",
		"properties": {
			"name": {
				"type": "string",
				"description": "The common name of the sensor"
			},
			"sensorType": {
				"type": "string",
				"description": "The datamodel definition of the sensor data. FIXME - need to create a definitions lib of sensor datamodel types"
			},
			"sensorData": {
				"type": "string",
				"description": "The data of the sensor data. FIXME - need to ref the definitions of sensor types"
			},
			"fromBow": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "The distance from the bow to the sensor location"
			},
			"fromCenter": {
				"$ref": "../definitions.json#/definitions/numberValue",
				"description": "The distance from the centerline to the sensor location, -ve to starboard, +ve to port"
			}
		}
	};

/***/ },
/* 40 */
/*!*****************************************************!*\
  !*** ../specification/schemas/groups/steering.json ***!
  \*****************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/steering.json#",
		"description": "Schema describing the steering child-object of a vessel.",
		"title": "steering",
		"properties": {
			"rudderAngle": {
				"description": "Current rudder angle, +ve is rudder to Starboard",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "rad"
			},
			"rudderAngleTarget": {
				"description": "The angle the rudder should move to, +ve is rudder to Starboard",
				"$ref": "../definitions.json#/definitions/numberValue",
				"units": "rad"
			},
			"autopilot": {
				"type": "object",
				"title": "autopilot",
				"description": "Autopilot data",
				"properties": {
					"state": {
						"type": "object",
						"description": "Autopilot state",
						"properties": {
							"value": {
								"type": "string",
								"enum": [
									"on",
									"off",
									"alarm"
								]
							},
							"source": {
								"description": "Source of this data",
								"$ref": "../definitions.json#/definitions/source"
							},
							"timestamp": {
								"description": "timestamp of the last update to this data",
								"$ref": "../definitions.json#/definitions/timestamp"
							}
						}
					},
					"mode": {
						"type": "object",
						"description": "Operational mode",
						"properties": {
							"value": {
								"type": "string",
								"enum": [
									"powersave",
									"normal",
									"accurate"
								]
							},
							"source": {
								"description": "Source of this data",
								"$ref": "../definitions.json#/definitions/source"
							},
							"timestamp": {
								"description": "timestamp of the last update to this data",
								"$ref": "../definitions.json#/definitions/timestamp"
							}
						}
					},
					"targetHeadingNorth": {
						"description": "Target heading for autopilot, relative to true North",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"targetHeadingMagnetic": {
						"description": "Target heading for autopilot, relative to magnetic North",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"headingSource": {
						"type": "object",
						"description": "Current source of heading information",
						"properties": {
							"value": {
								"type": "string",
								"enum": [
									"compass",
									"wind",
									"gps"
								]
							},
							"source": {
								"description": "Source of this data",
								"$ref": "../definitions.json#/definitions/source"
							},
							"timestamp": {
								"description": "timestamp of the last update to this data",
								"$ref": "../definitions.json#/definitions/timestamp"
							}
						}
					},
					"deadZone": {
						"description": "Dead zone to ignore for rudder corrections",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"backlash": {
						"description": "Slack in the rudder drive mechanism",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"gain": {
						"description": "Auto-pilot gain, higher number equals more rudder movement for a given turn",
						"$ref": "../definitions.json#/definitions/numberValue"
					},
					"maxDriveCurrent": {
						"description": "Maximum current to use to drive servo",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "A"
					},
					"maxDriveRate": {
						"description": "Maximum rudder rotation speed",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad/s"
					},
					"portLock": {
						"description": "Position of servo on port lock",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					},
					"starboardLock": {
						"description": "Position of servo on starboard lock",
						"$ref": "../definitions.json#/definitions/numberValue",
						"units": "rad"
					}
				}
			}
		}
	};

/***/ },
/* 41 */
/*!**************************************************!*\
  !*** ../specification/schemas/groups/tanks.json ***!
  \**************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/tanks.json#",
		"description": "A tank, named by a unique identifier",
		"title": "tank",
		"properties": {
			"name": {
				"type": "string",
				"description": "The name of the tank. Useful if multiple tanks of a certain type are on board"
			},
			"type": {
				"type": "string",
				"description": "The type of tank",
				"enum": [
					"petrol",
					"fresh water",
					"greywater",
					"holding",
					"lpg",
					"diesel",
					"rum"
				]
			},
			"capacity": {
				"description": "Total capacity",
				"units": "m3",
				"$ref": "../definitions.json#/definitions/numberValue"
			},
			"level": {
				"description": "Amount of fluid in tank",
				"units": "m3",
				"$ref": "../definitions.json#/definitions/numberValue"
			}
		}
	};

/***/ },
/* 42 */
/*!*************************************!*\
  !*** ../specification/~/tv4/tv4.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	Author: Geraint Luff and others
	Year: 2013
	
	This code is released into the "public domain" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.
	
	If you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.
	*/
	(function (global, factory) {
	  if (true) {
	    // AMD. Register as an anonymous module.
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof module !== 'undefined' && module.exports){
	    // CommonJS. Define export.
	    module.exports = factory();
	  } else {
	    // Browser globals
	    global.tv4 = factory();
	  }
	}(this, function () {
	
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys
	if (!Object.keys) {
		Object.keys = (function () {
			var hasOwnProperty = Object.prototype.hasOwnProperty,
				hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
				dontEnums = [
					'toString',
					'toLocaleString',
					'valueOf',
					'hasOwnProperty',
					'isPrototypeOf',
					'propertyIsEnumerable',
					'constructor'
				],
				dontEnumsLength = dontEnums.length;
	
			return function (obj) {
				if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {
					throw new TypeError('Object.keys called on non-object');
				}
	
				var result = [];
	
				for (var prop in obj) {
					if (hasOwnProperty.call(obj, prop)) {
						result.push(prop);
					}
				}
	
				if (hasDontEnumBug) {
					for (var i=0; i < dontEnumsLength; i++) {
						if (hasOwnProperty.call(obj, dontEnums[i])) {
							result.push(dontEnums[i]);
						}
					}
				}
				return result;
			};
		})();
	}
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
	if (!Object.create) {
		Object.create = (function(){
			function F(){}
	
			return function(o){
				if (arguments.length !== 1) {
					throw new Error('Object.create implementation only accepts one parameter.');
				}
				F.prototype = o;
				return new F();
			};
		})();
	}
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray
	if(!Array.isArray) {
		Array.isArray = function (vArg) {
			return Object.prototype.toString.call(vArg) === "[object Array]";
		};
	}
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf
	if (!Array.prototype.indexOf) {
		Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
			if (this === null) {
				throw new TypeError();
			}
			var t = Object(this);
			var len = t.length >>> 0;
	
			if (len === 0) {
				return -1;
			}
			var n = 0;
			if (arguments.length > 1) {
				n = Number(arguments[1]);
				if (n !== n) { // shortcut for verifying if it's NaN
					n = 0;
				} else if (n !== 0 && n !== Infinity && n !== -Infinity) {
					n = (n > 0 || -1) * Math.floor(Math.abs(n));
				}
			}
			if (n >= len) {
				return -1;
			}
			var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
			for (; k < len; k++) {
				if (k in t && t[k] === searchElement) {
					return k;
				}
			}
			return -1;
		};
	}
	
	// Grungey Object.isFrozen hack
	if (!Object.isFrozen) {
		Object.isFrozen = function (obj) {
			var key = "tv4_test_frozen_key";
			while (obj.hasOwnProperty(key)) {
				key += Math.random();
			}
			try {
				obj[key] = true;
				delete obj[key];
				return false;
			} catch (e) {
				return true;
			}
		};
	}
	// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed
	
	var uriTemplateGlobalModifiers = {
		"+": true,
		"#": true,
		".": true,
		"/": true,
		";": true,
		"?": true,
		"&": true
	};
	var uriTemplateSuffices = {
		"*": true
	};
	
	function notReallyPercentEncode(string) {
		return encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {
			return "%" + doubleEncoded.substring(3);
		});
	}
	
	function uriTemplateSubstitution(spec) {
		var modifier = "";
		if (uriTemplateGlobalModifiers[spec.charAt(0)]) {
			modifier = spec.charAt(0);
			spec = spec.substring(1);
		}
		var separator = "";
		var prefix = "";
		var shouldEscape = true;
		var showVariables = false;
		var trimEmptyString = false;
		if (modifier === '+') {
			shouldEscape = false;
		} else if (modifier === ".") {
			prefix = ".";
			separator = ".";
		} else if (modifier === "/") {
			prefix = "/";
			separator = "/";
		} else if (modifier === '#') {
			prefix = "#";
			shouldEscape = false;
		} else if (modifier === ';') {
			prefix = ";";
			separator = ";";
			showVariables = true;
			trimEmptyString = true;
		} else if (modifier === '?') {
			prefix = "?";
			separator = "&";
			showVariables = true;
		} else if (modifier === '&') {
			prefix = "&";
			separator = "&";
			showVariables = true;
		}
	
		var varNames = [];
		var varList = spec.split(",");
		var varSpecs = [];
		var varSpecMap = {};
		for (var i = 0; i < varList.length; i++) {
			var varName = varList[i];
			var truncate = null;
			if (varName.indexOf(":") !== -1) {
				var parts = varName.split(":");
				varName = parts[0];
				truncate = parseInt(parts[1], 10);
			}
			var suffices = {};
			while (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {
				suffices[varName.charAt(varName.length - 1)] = true;
				varName = varName.substring(0, varName.length - 1);
			}
			var varSpec = {
				truncate: truncate,
				name: varName,
				suffices: suffices
			};
			varSpecs.push(varSpec);
			varSpecMap[varName] = varSpec;
			varNames.push(varName);
		}
		var subFunction = function (valueFunction) {
			var result = "";
			var startIndex = 0;
			for (var i = 0; i < varSpecs.length; i++) {
				var varSpec = varSpecs[i];
				var value = valueFunction(varSpec.name);
				if (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {
					startIndex++;
					continue;
				}
				if (i === startIndex) {
					result += prefix;
				} else {
					result += (separator || ",");
				}
				if (Array.isArray(value)) {
					if (showVariables) {
						result += varSpec.name + "=";
					}
					for (var j = 0; j < value.length; j++) {
						if (j > 0) {
							result += varSpec.suffices['*'] ? (separator || ",") : ",";
							if (varSpec.suffices['*'] && showVariables) {
								result += varSpec.name + "=";
							}
						}
						result += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, "%21") : notReallyPercentEncode(value[j]);
					}
				} else if (typeof value === "object") {
					if (showVariables && !varSpec.suffices['*']) {
						result += varSpec.name + "=";
					}
					var first = true;
					for (var key in value) {
						if (!first) {
							result += varSpec.suffices['*'] ? (separator || ",") : ",";
						}
						first = false;
						result += shouldEscape ? encodeURIComponent(key).replace(/!/g, "%21") : notReallyPercentEncode(key);
						result += varSpec.suffices['*'] ? '=' : ",";
						result += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, "%21") : notReallyPercentEncode(value[key]);
					}
				} else {
					if (showVariables) {
						result += varSpec.name;
						if (!trimEmptyString || value !== "") {
							result += "=";
						}
					}
					if (varSpec.truncate != null) {
						value = value.substring(0, varSpec.truncate);
					}
					result += shouldEscape ? encodeURIComponent(value).replace(/!/g, "%21"): notReallyPercentEncode(value);
				}
			}
			return result;
		};
		subFunction.varNames = varNames;
		return {
			prefix: prefix,
			substitution: subFunction
		};
	}
	
	function UriTemplate(template) {
		if (!(this instanceof UriTemplate)) {
			return new UriTemplate(template);
		}
		var parts = template.split("{");
		var textParts = [parts.shift()];
		var prefixes = [];
		var substitutions = [];
		var varNames = [];
		while (parts.length > 0) {
			var part = parts.shift();
			var spec = part.split("}")[0];
			var remainder = part.substring(spec.length + 1);
			var funcs = uriTemplateSubstitution(spec);
			substitutions.push(funcs.substitution);
			prefixes.push(funcs.prefix);
			textParts.push(remainder);
			varNames = varNames.concat(funcs.substitution.varNames);
		}
		this.fill = function (valueFunction) {
			var result = textParts[0];
			for (var i = 0; i < substitutions.length; i++) {
				var substitution = substitutions[i];
				result += substitution(valueFunction);
				result += textParts[i + 1];
			}
			return result;
		};
		this.varNames = varNames;
		this.template = template;
	}
	UriTemplate.prototype = {
		toString: function () {
			return this.template;
		},
		fillFromObject: function (obj) {
			return this.fill(function (varName) {
				return obj[varName];
			});
		}
	};
	var ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {
		this.missing = [];
		this.missingMap = {};
		this.formatValidators = parent ? Object.create(parent.formatValidators) : {};
		this.schemas = parent ? Object.create(parent.schemas) : {};
		this.collectMultiple = collectMultiple;
		this.errors = [];
		this.handleError = collectMultiple ? this.collectError : this.returnError;
		if (checkRecursive) {
			this.checkRecursive = true;
			this.scanned = [];
			this.scannedFrozen = [];
			this.scannedFrozenSchemas = [];
			this.scannedFrozenValidationErrors = [];
			this.validatedSchemasKey = 'tv4_validation_id';
			this.validationErrorsKey = 'tv4_validation_errors_id';
		}
		if (trackUnknownProperties) {
			this.trackUnknownProperties = true;
			this.knownPropertyPaths = {};
			this.unknownPropertyPaths = {};
		}
		this.errorReporter = errorReporter || defaultErrorReporter('en');
		if (typeof this.errorReporter === 'string') {
			throw new Error('debug');
		}
		this.definedKeywords = {};
		if (parent) {
			for (var key in parent.definedKeywords) {
				this.definedKeywords[key] = parent.definedKeywords[key].slice(0);
			}
		}
	};
	ValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {
		this.definedKeywords[keyword] = this.definedKeywords[keyword] || [];
		this.definedKeywords[keyword].push(keywordFunction);
	};
	ValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {
		var error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);
		error.message = this.errorReporter(error, data, schema);
		return error;
	};
	ValidatorContext.prototype.returnError = function (error) {
		return error;
	};
	ValidatorContext.prototype.collectError = function (error) {
		if (error) {
			this.errors.push(error);
		}
		return null;
	};
	ValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {
		for (var i = startIndex; i < this.errors.length; i++) {
			this.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);
		}
		return this;
	};
	ValidatorContext.prototype.banUnknownProperties = function (data, schema) {
		for (var unknownPath in this.unknownPropertyPaths) {
			var error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, "", null, data, schema);
			var result = this.handleError(error);
			if (result) {
				return result;
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.addFormat = function (format, validator) {
		if (typeof format === 'object') {
			for (var key in format) {
				this.addFormat(key, format[key]);
			}
			return this;
		}
		this.formatValidators[format] = validator;
	};
	ValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {
		if (schema['$ref'] !== undefined) {
			urlHistory = urlHistory || {};
			if (urlHistory[schema['$ref']]) {
				return this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '', null, undefined, schema);
			}
			urlHistory[schema['$ref']] = true;
			schema = this.getSchema(schema['$ref'], urlHistory);
		}
		return schema;
	};
	ValidatorContext.prototype.getSchema = function (url, urlHistory) {
		var schema;
		if (this.schemas[url] !== undefined) {
			schema = this.schemas[url];
			return this.resolveRefs(schema, urlHistory);
		}
		var baseUrl = url;
		var fragment = "";
		if (url.indexOf('#') !== -1) {
			fragment = url.substring(url.indexOf("#") + 1);
			baseUrl = url.substring(0, url.indexOf("#"));
		}
		if (typeof this.schemas[baseUrl] === 'object') {
			schema = this.schemas[baseUrl];
			var pointerPath = decodeURIComponent(fragment);
			if (pointerPath === "") {
				return this.resolveRefs(schema, urlHistory);
			} else if (pointerPath.charAt(0) !== "/") {
				return undefined;
			}
			var parts = pointerPath.split("/").slice(1);
			for (var i = 0; i < parts.length; i++) {
				var component = parts[i].replace(/~1/g, "/").replace(/~0/g, "~");
				if (schema[component] === undefined) {
					schema = undefined;
					break;
				}
				schema = schema[component];
			}
			if (schema !== undefined) {
				return this.resolveRefs(schema, urlHistory);
			}
		}
		if (this.missing[baseUrl] === undefined) {
			this.missing.push(baseUrl);
			this.missing[baseUrl] = baseUrl;
			this.missingMap[baseUrl] = baseUrl;
		}
	};
	ValidatorContext.prototype.searchSchemas = function (schema, url) {
		if (Array.isArray(schema)) {
			for (var i = 0; i < schema.length; i++) {
				this.searchSchemas(schema[i], url);
			}
		} else if (schema && typeof schema === "object") {
			if (typeof schema.id === "string") {
				if (isTrustedUrl(url, schema.id)) {
					if (this.schemas[schema.id] === undefined) {
						this.schemas[schema.id] = schema;
					}
				}
			}
			for (var key in schema) {
				if (key !== "enum") {
					if (typeof schema[key] === "object") {
						this.searchSchemas(schema[key], url);
					} else if (key === "$ref") {
						var uri = getDocumentUri(schema[key]);
						if (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {
							this.missingMap[uri] = uri;
						}
					}
				}
			}
		}
	};
	ValidatorContext.prototype.addSchema = function (url, schema) {
		//overload
		if (typeof url !== 'string' || typeof schema === 'undefined') {
			if (typeof url === 'object' && typeof url.id === 'string') {
				schema = url;
				url = schema.id;
			}
			else {
				return;
			}
		}
		if (url === getDocumentUri(url) + "#") {
			// Remove empty fragment
			url = getDocumentUri(url);
		}
		this.schemas[url] = schema;
		delete this.missingMap[url];
		normSchema(schema, url);
		this.searchSchemas(schema, url);
	};
	
	ValidatorContext.prototype.getSchemaMap = function () {
		var map = {};
		for (var key in this.schemas) {
			map[key] = this.schemas[key];
		}
		return map;
	};
	
	ValidatorContext.prototype.getSchemaUris = function (filterRegExp) {
		var list = [];
		for (var key in this.schemas) {
			if (!filterRegExp || filterRegExp.test(key)) {
				list.push(key);
			}
		}
		return list;
	};
	
	ValidatorContext.prototype.getMissingUris = function (filterRegExp) {
		var list = [];
		for (var key in this.missingMap) {
			if (!filterRegExp || filterRegExp.test(key)) {
				list.push(key);
			}
		}
		return list;
	};
	
	ValidatorContext.prototype.dropSchemas = function () {
		this.schemas = {};
		this.reset();
	};
	ValidatorContext.prototype.reset = function () {
		this.missing = [];
		this.missingMap = {};
		this.errors = [];
	};
	
	ValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {
		var topLevel;
		schema = this.resolveRefs(schema);
		if (!schema) {
			return null;
		} else if (schema instanceof ValidationError) {
			this.errors.push(schema);
			return schema;
		}
	
		var startErrorCount = this.errors.length;
		var frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;
		if (this.checkRecursive && data && typeof data === 'object') {
			topLevel = !this.scanned.length;
			if (data[this.validatedSchemasKey]) {
				var schemaIndex = data[this.validatedSchemasKey].indexOf(schema);
				if (schemaIndex !== -1) {
					this.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);
					return null;
				}
			}
			if (Object.isFrozen(data)) {
				frozenIndex = this.scannedFrozen.indexOf(data);
				if (frozenIndex !== -1) {
					var frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);
					if (frozenSchemaIndex !== -1) {
						this.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);
						return null;
					}
				}
			}
			this.scanned.push(data);
			if (Object.isFrozen(data)) {
				if (frozenIndex === -1) {
					frozenIndex = this.scannedFrozen.length;
					this.scannedFrozen.push(data);
					this.scannedFrozenSchemas.push([]);
				}
				scannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;
				this.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;
				this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];
			} else {
				if (!data[this.validatedSchemasKey]) {
					try {
						Object.defineProperty(data, this.validatedSchemasKey, {
							value: [],
							configurable: true
						});
						Object.defineProperty(data, this.validationErrorsKey, {
							value: [],
							configurable: true
						});
					} catch (e) {
						//IE 7/8 workaround
						data[this.validatedSchemasKey] = [];
						data[this.validationErrorsKey] = [];
					}
				}
				scannedSchemasIndex = data[this.validatedSchemasKey].length;
				data[this.validatedSchemasKey][scannedSchemasIndex] = schema;
				data[this.validationErrorsKey][scannedSchemasIndex] = [];
			}
		}
	
		var errorCount = this.errors.length;
		var error = this.validateBasic(data, schema, dataPointerPath)
			|| this.validateNumeric(data, schema, dataPointerPath)
			|| this.validateString(data, schema, dataPointerPath)
			|| this.validateArray(data, schema, dataPointerPath)
			|| this.validateObject(data, schema, dataPointerPath)
			|| this.validateCombinations(data, schema, dataPointerPath)
			|| this.validateHypermedia(data, schema, dataPointerPath)
			|| this.validateFormat(data, schema, dataPointerPath)
			|| this.validateDefinedKeywords(data, schema, dataPointerPath)
			|| null;
	
		if (topLevel) {
			while (this.scanned.length) {
				var item = this.scanned.pop();
				delete item[this.validatedSchemasKey];
			}
			this.scannedFrozen = [];
			this.scannedFrozenSchemas = [];
		}
	
		if (error || errorCount !== this.errors.length) {
			while ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {
				var dataPart = (dataPathParts && dataPathParts.length) ? "" + dataPathParts.pop() : null;
				var schemaPart = (schemaPathParts && schemaPathParts.length) ? "" + schemaPathParts.pop() : null;
				if (error) {
					error = error.prefixWith(dataPart, schemaPart);
				}
				this.prefixErrors(errorCount, dataPart, schemaPart);
			}
		}
	
		if (scannedFrozenSchemaIndex !== null) {
			this.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);
		} else if (scannedSchemasIndex !== null) {
			data[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);
		}
	
		return this.handleError(error);
	};
	ValidatorContext.prototype.validateFormat = function (data, schema) {
		if (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {
			return null;
		}
		var errorMessage = this.formatValidators[schema.format].call(null, data, schema);
		if (typeof errorMessage === 'string' || typeof errorMessage === 'number') {
			return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, '', '/format', null, data, schema);
		} else if (errorMessage && typeof errorMessage === 'object') {
			return this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || "?"}, errorMessage.dataPath || '', errorMessage.schemaPath || "/format", null, data, schema);
		}
		return null;
	};
	ValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {
		for (var key in this.definedKeywords) {
			if (typeof schema[key] === 'undefined') {
				continue;
			}
			var validationFunctions = this.definedKeywords[key];
			for (var i = 0; i < validationFunctions.length; i++) {
				var func = validationFunctions[i];
				var result = func(data, schema[key], schema, dataPointerPath);
				if (typeof result === 'string' || typeof result === 'number') {
					return this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}, '', '', null, data, schema).prefixWith(null, key);
				} else if (result && typeof result === 'object') {
					var code = result.code;
					if (typeof code === 'string') {
						if (!ErrorCodes[code]) {
							throw new Error('Undefined error code (use defineError): ' + code);
						}
						code = ErrorCodes[code];
					} else if (typeof code !== 'number') {
						code = ErrorCodes.KEYWORD_CUSTOM;
					}
					var messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || "?"};
					var schemaPath = result.schemaPath || ("/" + key.replace(/~/g, '~0').replace(/\//g, '~1'));
					return this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);
				}
			}
		}
		return null;
	};
	
	function recursiveCompare(A, B) {
		if (A === B) {
			return true;
		}
		if (A && B && typeof A === "object" && typeof B === "object") {
			if (Array.isArray(A) !== Array.isArray(B)) {
				return false;
			} else if (Array.isArray(A)) {
				if (A.length !== B.length) {
					return false;
				}
				for (var i = 0; i < A.length; i++) {
					if (!recursiveCompare(A[i], B[i])) {
						return false;
					}
				}
			} else {
				var key;
				for (key in A) {
					if (B[key] === undefined && A[key] !== undefined) {
						return false;
					}
				}
				for (key in B) {
					if (A[key] === undefined && B[key] !== undefined) {
						return false;
					}
				}
				for (key in A) {
					if (!recursiveCompare(A[key], B[key])) {
						return false;
					}
				}
			}
			return true;
		}
		return false;
	}
	
	ValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {
		var error;
		if (error = this.validateType(data, schema, dataPointerPath)) {
			return error.prefixWith(null, "type");
		}
		if (error = this.validateEnum(data, schema, dataPointerPath)) {
			return error.prefixWith(null, "type");
		}
		return null;
	};
	
	ValidatorContext.prototype.validateType = function validateType(data, schema) {
		if (schema.type === undefined) {
			return null;
		}
		var dataType = typeof data;
		if (data === null) {
			dataType = "null";
		} else if (Array.isArray(data)) {
			dataType = "array";
		}
		var allowedTypes = schema.type;
		if (!Array.isArray(allowedTypes)) {
			allowedTypes = [allowedTypes];
		}
	
		for (var i = 0; i < allowedTypes.length; i++) {
			var type = allowedTypes[i];
			if (type === dataType || (type === "integer" && dataType === "number" && (data % 1 === 0))) {
				return null;
			}
		}
		return this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join("/")}, '', '', null, data, schema);
	};
	
	ValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {
		if (schema["enum"] === undefined) {
			return null;
		}
		for (var i = 0; i < schema["enum"].length; i++) {
			var enumVal = schema["enum"][i];
			if (recursiveCompare(data, enumVal)) {
				return null;
			}
		}
		return this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data}, '', '', null, data, schema);
	};
	
	ValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {
		return this.validateMultipleOf(data, schema, dataPointerPath)
			|| this.validateMinMax(data, schema, dataPointerPath)
			|| this.validateNaN(data, schema, dataPointerPath)
			|| null;
	};
	
	var CLOSE_ENOUGH_LOW = Math.pow(2, -51);
	var CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;
	ValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {
		var multipleOf = schema.multipleOf || schema.divisibleBy;
		if (multipleOf === undefined) {
			return null;
		}
		if (typeof data === "number") {
			var remainder = (data/multipleOf)%1;
			if (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {
				return this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf}, '', '', null, data, schema);
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {
		if (typeof data !== "number") {
			return null;
		}
		if (schema.minimum !== undefined) {
			if (data < schema.minimum) {
				return this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}, '', '/minimum', null, data, schema);
			}
			if (schema.exclusiveMinimum && data === schema.minimum) {
				return this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}, '', '/exclusiveMinimum', null, data, schema);
			}
		}
		if (schema.maximum !== undefined) {
			if (data > schema.maximum) {
				return this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}, '', '/maximum', null, data, schema);
			}
			if (schema.exclusiveMaximum && data === schema.maximum) {
				return this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}, '', '/exclusiveMaximum', null, data, schema);
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {
		if (typeof data !== "number") {
			return null;
		}
		if (isNaN(data) === true || data === Infinity || data === -Infinity) {
			return this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, '', '/type', null, data, schema);
		}
		return null;
	};
	
	ValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {
		return this.validateStringLength(data, schema, dataPointerPath)
			|| this.validateStringPattern(data, schema, dataPointerPath)
			|| null;
	};
	
	ValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {
		if (typeof data !== "string") {
			return null;
		}
		if (schema.minLength !== undefined) {
			if (data.length < schema.minLength) {
				return this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}, '', '/minLength', null, data, schema);
			}
		}
		if (schema.maxLength !== undefined) {
			if (data.length > schema.maxLength) {
				return this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}, '', '/maxLength', null, data, schema);
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {
		if (typeof data !== "string" || (typeof schema.pattern !== "string" && !(schema.pattern instanceof RegExp))) {
			return null;
		}
		var regexp;
		if (schema.pattern instanceof RegExp) {
		  regexp = schema.pattern;
		}
		else {
		  var body, flags = '';
		  // Check for regular expression literals
		  // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5
		  var literal = schema.pattern.match(/^\/(.+)\/([img]*)$/);
		  if (literal) {
		    body = literal[1];
		    flags = literal[2];
		  }
		  else {
		    body = schema.pattern;
		  }
		  regexp = new RegExp(body, flags);
		}
		if (!regexp.test(data)) {
			return this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, '', '/pattern', null, data, schema);
		}
		return null;
	};
	
	ValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {
		if (!Array.isArray(data)) {
			return null;
		}
		return this.validateArrayLength(data, schema, dataPointerPath)
			|| this.validateArrayUniqueItems(data, schema, dataPointerPath)
			|| this.validateArrayItems(data, schema, dataPointerPath)
			|| null;
	};
	
	ValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {
		var error;
		if (schema.minItems !== undefined) {
			if (data.length < schema.minItems) {
				error = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems}, '', '/minItems', null, data, schema);
				if (this.handleError(error)) {
					return error;
				}
			}
		}
		if (schema.maxItems !== undefined) {
			if (data.length > schema.maxItems) {
				error = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems}, '', '/maxItems', null, data, schema);
				if (this.handleError(error)) {
					return error;
				}
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {
		if (schema.uniqueItems) {
			for (var i = 0; i < data.length; i++) {
				for (var j = i + 1; j < data.length; j++) {
					if (recursiveCompare(data[i], data[j])) {
						var error = this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j}, '', '/uniqueItems', null, data, schema);
						if (this.handleError(error)) {
							return error;
						}
					}
				}
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {
		if (schema.items === undefined) {
			return null;
		}
		var error, i;
		if (Array.isArray(schema.items)) {
			for (i = 0; i < data.length; i++) {
				if (i < schema.items.length) {
					if (error = this.validateAll(data[i], schema.items[i], [i], ["items", i], dataPointerPath + "/" + i)) {
						return error;
					}
				} else if (schema.additionalItems !== undefined) {
					if (typeof schema.additionalItems === "boolean") {
						if (!schema.additionalItems) {
							error = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema));
							if (this.handleError(error)) {
								return error;
							}
						}
					} else if (error = this.validateAll(data[i], schema.additionalItems, [i], ["additionalItems"], dataPointerPath + "/" + i)) {
						return error;
					}
				}
			}
		} else {
			for (i = 0; i < data.length; i++) {
				if (error = this.validateAll(data[i], schema.items, [i], ["items"], dataPointerPath + "/" + i)) {
					return error;
				}
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {
		if (typeof data !== "object" || data === null || Array.isArray(data)) {
			return null;
		}
		return this.validateObjectMinMaxProperties(data, schema, dataPointerPath)
			|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)
			|| this.validateObjectProperties(data, schema, dataPointerPath)
			|| this.validateObjectDependencies(data, schema, dataPointerPath)
			|| null;
	};
	
	ValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {
		var keys = Object.keys(data);
		var error;
		if (schema.minProperties !== undefined) {
			if (keys.length < schema.minProperties) {
				error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}, '', '/minProperties', null, data, schema);
				if (this.handleError(error)) {
					return error;
				}
			}
		}
		if (schema.maxProperties !== undefined) {
			if (keys.length > schema.maxProperties) {
				error = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}, '', '/maxProperties', null, data, schema);
				if (this.handleError(error)) {
					return error;
				}
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {
		if (schema.required !== undefined) {
			for (var i = 0; i < schema.required.length; i++) {
				var key = schema.required[i];
				if (data[key] === undefined) {
					var error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, '', '/required/' + i, null, data, schema);
					if (this.handleError(error)) {
						return error;
					}
				}
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {
		var error;
		for (var key in data) {
			var keyPointerPath = dataPointerPath + "/" + key.replace(/~/g, '~0').replace(/\//g, '~1');
			var foundMatch = false;
			if (schema.properties !== undefined && schema.properties[key] !== undefined) {
				foundMatch = true;
				if (error = this.validateAll(data[key], schema.properties[key], [key], ["properties", key], keyPointerPath)) {
					return error;
				}
			}
			if (schema.patternProperties !== undefined) {
				for (var patternKey in schema.patternProperties) {
					var regexp = new RegExp(patternKey);
					if (regexp.test(key)) {
						foundMatch = true;
						if (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], ["patternProperties", patternKey], keyPointerPath)) {
							return error;
						}
					}
				}
			}
			if (!foundMatch) {
				if (schema.additionalProperties !== undefined) {
					if (this.trackUnknownProperties) {
						this.knownPropertyPaths[keyPointerPath] = true;
						delete this.unknownPropertyPaths[keyPointerPath];
					}
					if (typeof schema.additionalProperties === "boolean") {
						if (!schema.additionalProperties) {
							error = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, '', '/additionalProperties', null, data, schema).prefixWith(key, null);
							if (this.handleError(error)) {
								return error;
							}
						}
					} else {
						if (error = this.validateAll(data[key], schema.additionalProperties, [key], ["additionalProperties"], keyPointerPath)) {
							return error;
						}
					}
				} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {
					this.unknownPropertyPaths[keyPointerPath] = true;
				}
			} else if (this.trackUnknownProperties) {
				this.knownPropertyPaths[keyPointerPath] = true;
				delete this.unknownPropertyPaths[keyPointerPath];
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {
		var error;
		if (schema.dependencies !== undefined) {
			for (var depKey in schema.dependencies) {
				if (data[depKey] !== undefined) {
					var dep = schema.dependencies[depKey];
					if (typeof dep === "string") {
						if (data[dep] === undefined) {
							error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
							if (this.handleError(error)) {
								return error;
							}
						}
					} else if (Array.isArray(dep)) {
						for (var i = 0; i < dep.length; i++) {
							var requiredKey = dep[i];
							if (data[requiredKey] === undefined) {
								error = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, "dependencies");
								if (this.handleError(error)) {
									return error;
								}
							}
						}
					} else {
						if (error = this.validateAll(data, dep, [], ["dependencies", depKey], dataPointerPath)) {
							return error;
						}
					}
				}
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {
		return this.validateAllOf(data, schema, dataPointerPath)
			|| this.validateAnyOf(data, schema, dataPointerPath)
			|| this.validateOneOf(data, schema, dataPointerPath)
			|| this.validateNot(data, schema, dataPointerPath)
			|| null;
	};
	
	ValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {
		if (schema.allOf === undefined) {
			return null;
		}
		var error;
		for (var i = 0; i < schema.allOf.length; i++) {
			var subSchema = schema.allOf[i];
			if (error = this.validateAll(data, subSchema, [], ["allOf", i], dataPointerPath)) {
				return error;
			}
		}
		return null;
	};
	
	ValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {
		if (schema.anyOf === undefined) {
			return null;
		}
		var errors = [];
		var startErrorCount = this.errors.length;
		var oldUnknownPropertyPaths, oldKnownPropertyPaths;
		if (this.trackUnknownProperties) {
			oldUnknownPropertyPaths = this.unknownPropertyPaths;
			oldKnownPropertyPaths = this.knownPropertyPaths;
		}
		var errorAtEnd = true;
		for (var i = 0; i < schema.anyOf.length; i++) {
			if (this.trackUnknownProperties) {
				this.unknownPropertyPaths = {};
				this.knownPropertyPaths = {};
			}
			var subSchema = schema.anyOf[i];
	
			var errorCount = this.errors.length;
			var error = this.validateAll(data, subSchema, [], ["anyOf", i], dataPointerPath);
	
			if (error === null && errorCount === this.errors.length) {
				this.errors = this.errors.slice(0, startErrorCount);
	
				if (this.trackUnknownProperties) {
					for (var knownKey in this.knownPropertyPaths) {
						oldKnownPropertyPaths[knownKey] = true;
						delete oldUnknownPropertyPaths[knownKey];
					}
					for (var unknownKey in this.unknownPropertyPaths) {
						if (!oldKnownPropertyPaths[unknownKey]) {
							oldUnknownPropertyPaths[unknownKey] = true;
						}
					}
					// We need to continue looping so we catch all the property definitions, but we don't want to return an error
					errorAtEnd = false;
					continue;
				}
	
				return null;
			}
			if (error) {
				errors.push(error.prefixWith(null, "" + i).prefixWith(null, "anyOf"));
			}
		}
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = oldUnknownPropertyPaths;
			this.knownPropertyPaths = oldKnownPropertyPaths;
		}
		if (errorAtEnd) {
			errors = errors.concat(this.errors.slice(startErrorCount));
			this.errors = this.errors.slice(0, startErrorCount);
			return this.createError(ErrorCodes.ANY_OF_MISSING, {}, "", "/anyOf", errors, data, schema);
		}
	};
	
	ValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {
		if (schema.oneOf === undefined) {
			return null;
		}
		var validIndex = null;
		var errors = [];
		var startErrorCount = this.errors.length;
		var oldUnknownPropertyPaths, oldKnownPropertyPaths;
		if (this.trackUnknownProperties) {
			oldUnknownPropertyPaths = this.unknownPropertyPaths;
			oldKnownPropertyPaths = this.knownPropertyPaths;
		}
		for (var i = 0; i < schema.oneOf.length; i++) {
			if (this.trackUnknownProperties) {
				this.unknownPropertyPaths = {};
				this.knownPropertyPaths = {};
			}
			var subSchema = schema.oneOf[i];
	
			var errorCount = this.errors.length;
			var error = this.validateAll(data, subSchema, [], ["oneOf", i], dataPointerPath);
	
			if (error === null && errorCount === this.errors.length) {
				if (validIndex === null) {
					validIndex = i;
				} else {
					this.errors = this.errors.slice(0, startErrorCount);
					return this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, "", "/oneOf", null, data, schema);
				}
				if (this.trackUnknownProperties) {
					for (var knownKey in this.knownPropertyPaths) {
						oldKnownPropertyPaths[knownKey] = true;
						delete oldUnknownPropertyPaths[knownKey];
					}
					for (var unknownKey in this.unknownPropertyPaths) {
						if (!oldKnownPropertyPaths[unknownKey]) {
							oldUnknownPropertyPaths[unknownKey] = true;
						}
					}
				}
			} else if (error) {
				errors.push(error);
			}
		}
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = oldUnknownPropertyPaths;
			this.knownPropertyPaths = oldKnownPropertyPaths;
		}
		if (validIndex === null) {
			errors = errors.concat(this.errors.slice(startErrorCount));
			this.errors = this.errors.slice(0, startErrorCount);
			return this.createError(ErrorCodes.ONE_OF_MISSING, {}, "", "/oneOf", errors, data, schema);
		} else {
			this.errors = this.errors.slice(0, startErrorCount);
		}
		return null;
	};
	
	ValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {
		if (schema.not === undefined) {
			return null;
		}
		var oldErrorCount = this.errors.length;
		var oldUnknownPropertyPaths, oldKnownPropertyPaths;
		if (this.trackUnknownProperties) {
			oldUnknownPropertyPaths = this.unknownPropertyPaths;
			oldKnownPropertyPaths = this.knownPropertyPaths;
			this.unknownPropertyPaths = {};
			this.knownPropertyPaths = {};
		}
		var error = this.validateAll(data, schema.not, null, null, dataPointerPath);
		var notErrors = this.errors.slice(oldErrorCount);
		this.errors = this.errors.slice(0, oldErrorCount);
		if (this.trackUnknownProperties) {
			this.unknownPropertyPaths = oldUnknownPropertyPaths;
			this.knownPropertyPaths = oldKnownPropertyPaths;
		}
		if (error === null && notErrors.length === 0) {
			return this.createError(ErrorCodes.NOT_PASSED, {}, "", "/not", null, data, schema);
		}
		return null;
	};
	
	ValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {
		if (!schema.links) {
			return null;
		}
		var error;
		for (var i = 0; i < schema.links.length; i++) {
			var ldo = schema.links[i];
			if (ldo.rel === "describedby") {
				var template = new UriTemplate(ldo.href);
				var allPresent = true;
				for (var j = 0; j < template.varNames.length; j++) {
					if (!(template.varNames[j] in data)) {
						allPresent = false;
						break;
					}
				}
				if (allPresent) {
					var schemaUrl = template.fillFromObject(data);
					var subSchema = {"$ref": schemaUrl};
					if (error = this.validateAll(data, subSchema, [], ["links", i], dataPointerPath)) {
						return error;
					}
				}
			}
		}
	};
	
	// parseURI() and resolveUrl() are from https://gist.github.com/1088850
	//   -  released as public domain by author ("Yaffle") - see comments on gist
	
	function parseURI(url) {
		var m = String(url).replace(/^\s+|\s+$/g, '').match(/^([^:\/?#]+:)?(\/\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\/?#]*)(?::(\d*))?))?([^?#]*)(\?[^#]*)?(#[\s\S]*)?/);
		// authority = '//' + user + ':' + pass '@' + hostname + ':' port
		return (m ? {
			href     : m[0] || '',
			protocol : m[1] || '',
			authority: m[2] || '',
			host     : m[3] || '',
			hostname : m[4] || '',
			port     : m[5] || '',
			pathname : m[6] || '',
			search   : m[7] || '',
			hash     : m[8] || ''
		} : null);
	}
	
	function resolveUrl(base, href) {// RFC 3986
	
		function removeDotSegments(input) {
			var output = [];
			input.replace(/^(\.\.?(\/|$))+/, '')
				.replace(/\/(\.(\/|$))+/g, '/')
				.replace(/\/\.\.$/, '/../')
				.replace(/\/?[^\/]*/g, function (p) {
					if (p === '/..') {
						output.pop();
					} else {
						output.push(p);
					}
			});
			return output.join('').replace(/^\//, input.charAt(0) === '/' ? '/' : '');
		}
	
		href = parseURI(href || '');
		base = parseURI(base || '');
	
		return !href || !base ? null : (href.protocol || base.protocol) +
			(href.protocol || href.authority ? href.authority : base.authority) +
			removeDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +
			(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +
			href.hash;
	}
	
	function getDocumentUri(uri) {
		return uri.split('#')[0];
	}
	function normSchema(schema, baseUri) {
		if (schema && typeof schema === "object") {
			if (baseUri === undefined) {
				baseUri = schema.id;
			} else if (typeof schema.id === "string") {
				baseUri = resolveUrl(baseUri, schema.id);
				schema.id = baseUri;
			}
			if (Array.isArray(schema)) {
				for (var i = 0; i < schema.length; i++) {
					normSchema(schema[i], baseUri);
				}
			} else {
				if (typeof schema['$ref'] === "string") {
					schema['$ref'] = resolveUrl(baseUri, schema['$ref']);
				}
				for (var key in schema) {
					if (key !== "enum") {
						normSchema(schema[key], baseUri);
					}
				}
			}
		}
	}
	
	function defaultErrorReporter(language) {
		language = language || 'en';
	
		var errorMessages = languages[language];
	
		return function (error) {
			var messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];
			if (typeof messageTemplate !== 'string') {
				return "Unknown error code " + error.code + ": " + JSON.stringify(error.messageParams);
			}
			var messageParams = error.params;
			// Adapted from Crockford's supplant()
			return messageTemplate.replace(/\{([^{}]*)\}/g, function (whole, varName) {
				var subValue = messageParams[varName];
				return typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;
			});
		};
	}
	
	var ErrorCodes = {
		INVALID_TYPE: 0,
		ENUM_MISMATCH: 1,
		ANY_OF_MISSING: 10,
		ONE_OF_MISSING: 11,
		ONE_OF_MULTIPLE: 12,
		NOT_PASSED: 13,
		// Numeric errors
		NUMBER_MULTIPLE_OF: 100,
		NUMBER_MINIMUM: 101,
		NUMBER_MINIMUM_EXCLUSIVE: 102,
		NUMBER_MAXIMUM: 103,
		NUMBER_MAXIMUM_EXCLUSIVE: 104,
		NUMBER_NOT_A_NUMBER: 105,
		// String errors
		STRING_LENGTH_SHORT: 200,
		STRING_LENGTH_LONG: 201,
		STRING_PATTERN: 202,
		// Object errors
		OBJECT_PROPERTIES_MINIMUM: 300,
		OBJECT_PROPERTIES_MAXIMUM: 301,
		OBJECT_REQUIRED: 302,
		OBJECT_ADDITIONAL_PROPERTIES: 303,
		OBJECT_DEPENDENCY_KEY: 304,
		// Array errors
		ARRAY_LENGTH_SHORT: 400,
		ARRAY_LENGTH_LONG: 401,
		ARRAY_UNIQUE: 402,
		ARRAY_ADDITIONAL_ITEMS: 403,
		// Custom/user-defined errors
		FORMAT_CUSTOM: 500,
		KEYWORD_CUSTOM: 501,
		// Schema structure
		CIRCULAR_REFERENCE: 600,
		// Non-standard validation options
		UNKNOWN_PROPERTY: 1000
	};
	var ErrorCodeLookup = {};
	for (var key in ErrorCodes) {
		ErrorCodeLookup[ErrorCodes[key]] = key;
	}
	var ErrorMessagesDefault = {
		INVALID_TYPE: "Invalid type: {type} (expected {expected})",
		ENUM_MISMATCH: "No enum match for: {value}",
		ANY_OF_MISSING: "Data does not match any schemas from \"anyOf\"",
		ONE_OF_MISSING: "Data does not match any schemas from \"oneOf\"",
		ONE_OF_MULTIPLE: "Data is valid against more than one schema from \"oneOf\": indices {index1} and {index2}",
		NOT_PASSED: "Data matches schema from \"not\"",
		// Numeric errors
		NUMBER_MULTIPLE_OF: "Value {value} is not a multiple of {multipleOf}",
		NUMBER_MINIMUM: "Value {value} is less than minimum {minimum}",
		NUMBER_MINIMUM_EXCLUSIVE: "Value {value} is equal to exclusive minimum {minimum}",
		NUMBER_MAXIMUM: "Value {value} is greater than maximum {maximum}",
		NUMBER_MAXIMUM_EXCLUSIVE: "Value {value} is equal to exclusive maximum {maximum}",
		NUMBER_NOT_A_NUMBER: "Value {value} is not a valid number",
		// String errors
		STRING_LENGTH_SHORT: "String is too short ({length} chars), minimum {minimum}",
		STRING_LENGTH_LONG: "String is too long ({length} chars), maximum {maximum}",
		STRING_PATTERN: "String does not match pattern: {pattern}",
		// Object errors
		OBJECT_PROPERTIES_MINIMUM: "Too few properties defined ({propertyCount}), minimum {minimum}",
		OBJECT_PROPERTIES_MAXIMUM: "Too many properties defined ({propertyCount}), maximum {maximum}",
		OBJECT_REQUIRED: "Missing required property: {key}",
		OBJECT_ADDITIONAL_PROPERTIES: "Additional properties not allowed",
		OBJECT_DEPENDENCY_KEY: "Dependency failed - key must exist: {missing} (due to key: {key})",
		// Array errors
		ARRAY_LENGTH_SHORT: "Array is too short ({length}), minimum {minimum}",
		ARRAY_LENGTH_LONG: "Array is too long ({length}), maximum {maximum}",
		ARRAY_UNIQUE: "Array items are not unique (indices {match1} and {match2})",
		ARRAY_ADDITIONAL_ITEMS: "Additional items not allowed",
		// Format errors
		FORMAT_CUSTOM: "Format validation failed ({message})",
		KEYWORD_CUSTOM: "Keyword failed: {key} ({message})",
		// Schema structure
		CIRCULAR_REFERENCE: "Circular $refs: {urls}",
		// Non-standard validation options
		UNKNOWN_PROPERTY: "Unknown property (not in schema)"
	};
	
	function ValidationError(code, params, dataPath, schemaPath, subErrors) {
		Error.call(this);
		if (code === undefined) {
			throw new Error ("No error code supplied: " + schemaPath);
		}
		this.message = '';
		this.params = params;
		this.code = code;
		this.dataPath = dataPath || "";
		this.schemaPath = schemaPath || "";
		this.subErrors = subErrors || null;
	
		var err = new Error(this.message);
		this.stack = err.stack || err.stacktrace;
		if (!this.stack) {
			try {
				throw err;
			}
			catch(err) {
				this.stack = err.stack || err.stacktrace;
			}
		}
	}
	ValidationError.prototype = Object.create(Error.prototype);
	ValidationError.prototype.constructor = ValidationError;
	ValidationError.prototype.name = 'ValidationError';
	
	ValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {
		if (dataPrefix !== null) {
			dataPrefix = dataPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
			this.dataPath = "/" + dataPrefix + this.dataPath;
		}
		if (schemaPrefix !== null) {
			schemaPrefix = schemaPrefix.replace(/~/g, "~0").replace(/\//g, "~1");
			this.schemaPath = "/" + schemaPrefix + this.schemaPath;
		}
		if (this.subErrors !== null) {
			for (var i = 0; i < this.subErrors.length; i++) {
				this.subErrors[i].prefixWith(dataPrefix, schemaPrefix);
			}
		}
		return this;
	};
	
	function isTrustedUrl(baseUrl, testUrl) {
		if(testUrl.substring(0, baseUrl.length) === baseUrl){
			var remainder = testUrl.substring(baseUrl.length);
			if ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === "/")
				|| remainder.charAt(0) === "#"
				|| remainder.charAt(0) === "?") {
				return true;
			}
		}
		return false;
	}
	
	var languages = {};
	function createApi(language) {
		var globalContext = new ValidatorContext();
		var currentLanguage;
		var customErrorReporter;
		var api = {
			setErrorReporter: function (reporter) {
				if (typeof reporter === 'string') {
					return this.language(reporter);
				}
				customErrorReporter = reporter;
				return true;
			},
			addFormat: function () {
				globalContext.addFormat.apply(globalContext, arguments);
			},
			language: function (code) {
				if (!code) {
					return currentLanguage;
				}
				if (!languages[code]) {
					code = code.split('-')[0]; // fall back to base language
				}
				if (languages[code]) {
					currentLanguage = code;
					return code; // so you can tell if fall-back has happened
				}
				return false;
			},
			addLanguage: function (code, messageMap) {
				var key;
				for (key in ErrorCodes) {
					if (messageMap[key] && !messageMap[ErrorCodes[key]]) {
						messageMap[ErrorCodes[key]] = messageMap[key];
					}
				}
				var rootCode = code.split('-')[0];
				if (!languages[rootCode]) { // use for base language if not yet defined
					languages[code] = messageMap;
					languages[rootCode] = messageMap;
				} else {
					languages[code] = Object.create(languages[rootCode]);
					for (key in messageMap) {
						if (typeof languages[rootCode][key] === 'undefined') {
							languages[rootCode][key] = messageMap[key];
						}
						languages[code][key] = messageMap[key];
					}
				}
				return this;
			},
			freshApi: function (language) {
				var result = createApi();
				if (language) {
					result.language(language);
				}
				return result;
			},
			validate: function (data, schema, checkRecursive, banUnknownProperties) {
				var def = defaultErrorReporter(currentLanguage);
				var errorReporter = customErrorReporter ? function (error, data, schema) {
					return customErrorReporter(error, data, schema) || def(error, data, schema);
				} : def;
				var context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);
				if (typeof schema === "string") {
					schema = {"$ref": schema};
				}
				context.addSchema("", schema);
				var error = context.validateAll(data, schema, null, null, "");
				if (!error && banUnknownProperties) {
					error = context.banUnknownProperties(data, schema);
				}
				this.error = error;
				this.missing = context.missing;
				this.valid = (error === null);
				return this.valid;
			},
			validateResult: function () {
				var result = {};
				this.validate.apply(result, arguments);
				return result;
			},
			validateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {
				var def = defaultErrorReporter(currentLanguage);
				var errorReporter = customErrorReporter ? function (error, data, schema) {
					return customErrorReporter(error, data, schema) || def(error, data, schema);
				} : def;
				var context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);
				if (typeof schema === "string") {
					schema = {"$ref": schema};
				}
				context.addSchema("", schema);
				context.validateAll(data, schema, null, null, "");
				if (banUnknownProperties) {
					context.banUnknownProperties(data, schema);
				}
				var result = {};
				result.errors = context.errors;
				result.missing = context.missing;
				result.valid = (result.errors.length === 0);
				return result;
			},
			addSchema: function () {
				return globalContext.addSchema.apply(globalContext, arguments);
			},
			getSchema: function () {
				return globalContext.getSchema.apply(globalContext, arguments);
			},
			getSchemaMap: function () {
				return globalContext.getSchemaMap.apply(globalContext, arguments);
			},
			getSchemaUris: function () {
				return globalContext.getSchemaUris.apply(globalContext, arguments);
			},
			getMissingUris: function () {
				return globalContext.getMissingUris.apply(globalContext, arguments);
			},
			dropSchemas: function () {
				globalContext.dropSchemas.apply(globalContext, arguments);
			},
			defineKeyword: function () {
				globalContext.defineKeyword.apply(globalContext, arguments);
			},
			defineError: function (codeName, codeNumber, defaultMessage) {
				if (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {
					throw new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');
				}
				if (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber < 10000) {
					throw new Error('Code number must be an integer > 10000');
				}
				if (typeof ErrorCodes[codeName] !== 'undefined') {
					throw new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);
				}
				if (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {
					throw new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);
				}
				ErrorCodes[codeName] = codeNumber;
				ErrorCodeLookup[codeNumber] = codeName;
				ErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;
				for (var langCode in languages) {
					var language = languages[langCode];
					if (language[codeName]) {
						language[codeNumber] = language[codeNumber] || language[codeName];
					}
				}
			},
			reset: function () {
				globalContext.reset();
				this.error = null;
				this.missing = [];
				this.valid = true;
			},
			missing: [],
			error: null,
			valid: true,
			normSchema: normSchema,
			resolveUrl: resolveUrl,
			getDocumentUri: getDocumentUri,
			errorCodes: ErrorCodes
		};
		api.language(language || 'en');
		return api;
	}
	
	var tv4 = createApi();
	tv4.addLanguage('en-gb', ErrorMessagesDefault);
	
	//legacy property
	tv4.tv4 = tv4;
	
	return tv4; // used by _header.js to globalise.
	
	}));

/***/ },
/* 43 */
/*!********************************************!*\
  !*** ../specification/schemas/vessel.json ***!
  \********************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/vessel.json#",
		"description": "An object describing an individual vessel. It should be an object in vessels, named using MMSI or a UUID",
		"title": "vessel",
		"anyOf": [
			{
				"required": [
					"mmsi"
				]
			},
			{
				"required": [
					"url"
				]
			},
			{
				"required": [
					"uuid"
				]
			}
		],
		"properties": {
			"url": {
				"description": "URL based identity of the vessel, if available.",
				"$ref": "definitions.json#/definitions/url"
			},
			"mmsi": {
				"description": "MMSI number of the vessel, if available.",
				"$ref": "definitions.json#/definitions/mmsi"
			},
			"uuid": {
				"description": "A unique Signal K flavoured maritime resource identifier, assigned by the server.",
				"$ref": "definitions.json#/definitions/uuid",
				"example": "urn:mrn:signalk:uuid:b7590868-1d62-47d9-989c-32321b349fb9"
			},
			"name": {
				"type": "string",
				"description": "The common name of the vessel"
			},
			"communication": {
				"description": "Communication data",
				"$ref": "groups/communication.json#"
			},
			"environment": {
				"description": "Environmental data",
				"$ref": "groups/environment.json#"
			},
			"navigation": {
				"description": "Navigation data",
				"$ref": "groups/navigation.json#"
			},
			"propulsion": {
				"type": "object",
				"id": "https://signalk.github.io/specification/schemas/groups/propulsion.json#",
				"title": "propulsion",
				"description": "Engine data",
				"required": false,
				"patternProperties": {
					"(^[A-Za-z0-9]+$)": {
						"description": "This regex pattern is used for validation UUID identifier for the tank",
						"$ref": "propulsion.json#"
					}
				}
			},
			"electrical": {
				"type": "object",
				"description": "Electrical data",
				"properties": {
					"ac": {
						"description": "AC electrical data",
						"$ref": "groups/electrical_ac.json#"
					}
				}
			},
			"alarms": {
				"type": "object",
				"id": "https://signalk.github.io/specification/schemas/groups/alarms.json#",
				"title": "alarms",
				"description": "Alarms currently raised",
				"required": false,
				"patternProperties": {
					"(^[A-Za-z0-9]+$)": {
						"description": "This regex pattern is used for validation of the path of the alarm",
						"$ref": "alarms.json#"
					}
				}
			},
			"steering": {
				"description": "Vessel steering data",
				"$ref": "groups/steering.json#"
			},
			"tanks": {
				"type": "object",
				"id": "https://signalk.github.io/specification/schemas/groups/tanks.json#",
				"title": "tanks",
				"description": "Tanks on this vessel",
				"required": false,
				"patternProperties": {
					"(^[A-Za-z0-9]+$)": {
						"description": "This regex pattern is used for validation UUID identifier for the tank",
						"$ref": "tanks.json#"
					}
				}
			},
			"design": {
				"description": "Design data of this vessel",
				"$ref": "groups/design.json#"
			},
			"sensors": {
				"type": "object",
				"id": "https://signalk.github.io/specification/schemas/groups/sensors.json#",
				"title": "sensors",
				"description": "Sensors, their state, and data.",
				"required": false,
				"patternProperties": {
					"(^[A-Za-z0-9]+$)": {
						"description": "This regex pattern is used for validation UUID identifier for the sensor",
						"$ref": "sensors.json#"
					}
				}
			},
			"performance": {
				"description": "Performance data",
				"$ref": "groups/performance.json#"
			}
		}
	};

/***/ },
/* 44 */
/*!*************************************************!*\
  !*** ../specification/schemas/definitions.json ***!
  \*************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/definitions.json#",
		"title": "definitions",
		"description": "Reusable definitions of core object types",
		"definitions": {
			"timestamp": {
				"type": "string",
				"required": false,
				"description": "ISO-8601 (UTC) string representing date and time.",
				"units": "ISO-8601 (UTC)",
				"example": "2014-04-10T08:33:53Z"
			},
			"source": {
				"type": "object",
				"description": "Source of data. An object containing at least the properties defined in 'properties', but can contain anything beyond that.",
				"required": [
					"label",
					"type"
				],
				"properties": {
					"label": {
						"type": "string"
					},
					"type": {
						"type": "string",
						"default": "NMEA2000"
					},
					"src": {
						"type": "string",
						"description": "NMEA2000 src value or any similar value for encapsulating the original source of the data"
					},
					"pgn": {
						"type": "number",
						"description": "NMEA2000 pgn of the source message"
					},
					"sentence": {
						"type": "string",
						"description": "Sentence type of the source NMEA0183 sentence"
					},
					"talker": {
						"type": "string",
						"description": "Talker id of the source NMEA0183 sentence"
					}
				}
			},
			"version": {
				"type": "string",
				"description": "Version of the Signal K root object.",
				"example": "1.0"
			},
			"units": {
				"type": "string",
				"description": "Allowed units of physical quantities. Units should be (derived) SI units where possible.",
				"properties": {
					"s": {
						"display": "s",
						"quantity": "Time",
						"quantityDisplay": "T",
						"description": "Elapsed time (interval) in seconds"
					},
					"Hz": {
						"display": "Hz",
						"quantity": "Frequency",
						"quantityDisplay": "F",
						"description": "Frequency in Herz"
					},
					"m3": {
						"display": "m³",
						"quantity": "Volume",
						"quantityDisplay": "V",
						"description": "Volume in cubic meters"
					},
					"m3/s": {
						"display": "m3/s",
						"quantity": "Flow",
						"quantityDisplay": "Q",
						"description": "Liquid or gas flow in cubic meters per second"
					},
					"deg": {
						"display": "°",
						"quantity": "Angle",
						"quantityDisplay": "∠",
						"description": "Latitude or longitude in decimal degrees"
					},
					"rad": {
						"display": "㎭",
						"quantity": "Angle",
						"quantityDisplay": "∠",
						"description": "Angular arc in radians"
					},
					"rad/s": {
						"display": "㎭/s",
						"quantity": "Rotation",
						"quantityDisplay": "ω",
						"description": "Angular rate in radians per second"
					},
					"A": {
						"display": "A",
						"quantity": "Current",
						"quantityDisplay": "i",
						"description": "Electrical current in ampere"
					},
					"C": {
						"display": "C",
						"quantity": "Charge",
						"quantityDisplay": "Q",
						"description": "Electrical charge in Coulomb"
					},
					"V": {
						"display": "V",
						"quantity": "Voltage",
						"quantityDisplay": "V",
						"description": "Electrical potential in volt"
					},
					"W": {
						"display": "W",
						"quantity": "Power",
						"quantityDisplay": "P",
						"description": "Electrical power in watt"
					},
					"J": {
						"display": "J",
						"quantity": "Energy",
						"quantityDisplay": "E",
						"description": "Electrical energy in joule"
					},
					"ohm": {
						"display": "Ω",
						"quantity": "Resistance",
						"quantityDisplay": "R",
						"description": "Electrical resistance in ohm"
					},
					"m": {
						"display": "m",
						"quantity": "Distance",
						"quantityDisplay": "d",
						"description": "Distance in meters"
					},
					"m/s": {
						"display": "m/s",
						"quantity": "Velocity",
						"quantityDisplay": "v",
						"description": "Velocity in meters per second"
					},
					"m2": {
						"display": "㎡",
						"quantity": "Area",
						"quantityDisplay": "A",
						"description": "(Surface) area in square meters"
					},
					"K": {
						"display": "K",
						"quantity": "Temperature",
						"quantityDisplay": "t",
						"description": "Temperature in kelvin"
					},
					"Pa": {
						"display": "Pa",
						"quantity": "Pressure",
						"quantityDisplay": "P",
						"description": "Pressure in pascal"
					},
					"kg": {
						"display": "kg",
						"quantity": "Mass",
						"quantityDisplay": "m",
						"description": "Mass in kilogram"
					},
					"ratio": {
						"display": "",
						"quantity": "Ratio",
						"quantityDisplay": "φ",
						"description": "Relative value compared to reference or normal value. 0 = 0%, 1 = 100%, 1e-3 = 1 ppt"
					},
					"m/s2": {
						"display": "m/s²",
						"quantity": "Acceleration",
						"quantityDisplay": "a",
						"description": "Acceleration in meters per second squared"
					},
					"rad/s2": {
						"display": "rad/s²",
						"quantity": "Angular acceleration",
						"quantityDisplay": "a",
						"description": "Angular acceleration in radians per second squared"
					},
					"N": {
						"display": "N",
						"quantity": "Force",
						"quantityDisplay": "F",
						"description": "Force in newton"
					},
					"T": {
						"display": "T",
						"quantity": "Magnetic field",
						"quantityDisplay": "B",
						"description": "Magnetic field strength in tesla"
					},
					"Pa/s": {
						"display": "Pa/s",
						"quantity": "Pressure rate",
						"quantityDisplay": "R",
						"description": "Pressure change rate in pascal per meter"
					}
				}
			},
			"mmsi": {
				"type": "string",
				"description": "Maritime Mobile Service Identity (MMSI). Has to be 9 digits. See http://en.wikipedia.org/wiki/Maritime_Mobile_Service_Identity for information.",
				"pattern": "^[2-7][0-9]{8,8}$",
				"required": false,
				"maxLength": 9,
				"minLength": 9
			},
			"uuid": {
				"type": "string",
				"description": "A unique Signal K flavoured maritime resource identifier (MRN). A MRN is a form of URN, following a specific format: urn:mrn:<issueing authority>:<id type>:<id>. In case of a Signal K uuid, that looks like this: urn:mrn:signalk:uuid:<uuid>, where Signal K is the issuing authority and UUID (v4) the ID type.",
				"pattern": "^urn:mrn:signalk:uuid:[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}$",
				"example": "urn:mrn:signalk:uuid:b7590868-1d62-47d9-989c-32321b349fb9"
			},
			"url": {
				"type": "string",
				"description": "A valid URL.",
				"pattern": "^(http(s?):.*|mailto:.*|tel:(\\+?)[0-9]{4,})$"
			},
			"sail": {
				"type": "object",
				"description": "'sail' data type.",
				"properties": {
					"name": {
						"type": "string",
						"required": true,
						"description": "An unique identifier by which the crew identifies a sail",
						"example": "J1"
					},
					"type": {
						"type": "string",
						"required": true,
						"description": "The type of sail",
						"example": "Genaker"
					},
					"material": {
						"type": "string",
						"required": false,
						"description": "The material the sail is made from (optional)",
						"example": "canvas"
					},
					"brand": {
						"type": "string",
						"required": false,
						"description": "The brand of the sail (optional)",
						"example": "North Sails"
					},
					"active": {
						"type": "boolean",
						"required": true,
						"description": "Indicates wether this sail is currently in use or not"
					},
					"area": {
						"type": "number",
						"required": true,
						"description": "The total area of this sail in square meters",
						"units": "m2"
					},
					"minimumWind": {
						"type": "number",
						"description": "The minimum wind speed this sail can be used with",
						"units": "m/s",
						"default": 0
					},
					"maximumWind": {
						"type": "number",
						"description": "The maximum wind speed this sail can be used with",
						"units": "m/s",
						"default": 666
					},
					"timestamp": {
						"$ref": "#/definitions/timestamp"
					},
					"source": {
						"$ref": "#/definitions/source"
					},
					"_attr": {
						"$ref": "#/definitions/_attr"
					},
					"meta": {
						"$ref": "#/definitions/meta"
					}
				}
			},
			"stringValue": {
				"type": "object",
				"description": "Data should be of type string.",
				"properties": {
					"value": {
						"type": "string"
					},
					"timestamp": {
						"$ref": "#/definitions/timestamp"
					},
					"source": {
						"$ref": "#/definitions/source"
					},
					"_attr": {
						"$ref": "#/definitions/_attr"
					},
					"meta": {
						"$ref": "#/definitions/meta"
					}
				}
			},
			"numberValue": {
				"type": "object",
				"description": "Data should be of type number.",
				"properties": {
					"value": {
						"type": "number"
					},
					"timestamp": {
						"$ref": "#/definitions/timestamp"
					},
					"source": {
						"$ref": "#/definitions/source"
					},
					"_attr": {
						"$ref": "#/definitions/_attr"
					},
					"meta": {
						"$ref": "#/definitions/meta"
					}
				}
			},
			"floatValue": {
				"type": "object",
				"description": "Data should be of type float/double.",
				"properties": {
					"value": {
						"type": "number"
					},
					"timestamp": {
						"$ref": "#/definitions/timestamp"
					},
					"source": {
						"$ref": "#/definitions/source"
					},
					"_attr": {
						"$ref": "#/definitions/_attr"
					},
					"meta": {
						"$ref": "#/definitions/meta"
					}
				}
			},
			"nullValue": {
				"type": "object",
				"description": "Data should be of type NULL.",
				"properties": {
					"value": {
						"type": "null"
					},
					"timestamp": {
						"$ref": "#/definitions/timestamp"
					},
					"source": {
						"$ref": "#/definitions/source"
					},
					"_attr": {
						"$ref": "#/definitions/_attr"
					},
					"meta": {
						"$ref": "#/definitions/meta"
					}
				}
			},
			"_attr": {
				"type": "object",
				"title": "_attr schema.",
				"description": "Filesystem specific data, e.g. security, possibly more later.",
				"properties": {
					"_mode": {
						"type": "integer",
						"title": "_mode schema.",
						"description": "Unix style permissions, often written in `owner:group:other` form, `-rw-r--r--`",
						"default": 644
					},
					"_owner": {
						"type": "string",
						"title": "_owner schema.",
						"description": "The owner of this resource.",
						"default": "self"
					},
					"_group": {
						"type": "string",
						"title": "_group schema.",
						"description": "The group owning this resource.",
						"default": "self"
					}
				}
			},
			"meta": {
				"type": "object",
				"title": "Meta schema.",
				"description": "Provides meta data to enable alarm and display configuration.",
				"properties": {
					"displayName": {
						"type": "string",
						"title": "DisplayName schema.",
						"description": "A display name for this value.",
						"example": "Tachometer, Engine 1"
					},
					"longName": {
						"type": "string",
						"title": "LongName schema.",
						"description": "A long name for this value.",
						"example": "Tachometer, Engine 1"
					},
					"shortName": {
						"type": "string",
						"title": "ShortName schema.",
						"description": "A short name for this value.",
						"example": "RPM"
					},
					"gaugeType": {
						"type": "string",
						"title": "gaugeType schema.",
						"description": "The type of gauge necessary to display this value.",
						"example": "sparkline"
					},
					"units": {
						"type": "string",
						"title": "units schema.",
						"description": "The (derived) SI unit of this value.",
						"example": "m/s"
					},
					"timeout": {
						"type": "number",
						"title": "Timeout",
						"description": "The timeout in (fractional) seconds after which this data is invalid.",
						"example": 2
					},
					"warnMethod": {
						"type": "string",
						"title": "WarnMethod schema.",
						"description": "The method to use to raise the warning.",
						"default": "visual",
						"enum": [
							"visual",
							"sound"
						]
					},
					"alarmMethod": {
						"type": "string",
						"title": "AlarmMethod schema.",
						"description": "The method to use to raise the alarm",
						"default": "sound",
						"enum": [
							"visual",
							"sound"
						]
					},
					"zones": {
						"type": "array",
						"title": "Zones schema.",
						"description": "The zones defining the range of values for this signalk value.",
						"items": [
							{
								"type": "array",
								"title": "zone",
								"description": "A zone used to define the display and alarm state when the value is in between bottom and top.",
								"items": [
									{
										"id": "bottom",
										"type": "number",
										"title": "Bottom",
										"description": "The lowest number in this zone",
										"name": "bottom",
										"example": 3500
									},
									{
										"id": "top",
										"type": "number",
										"title": "top",
										"description": "The highest value in this zone",
										"name": "1",
										"example": 4000
									},
									{
										"id": "alarmState",
										"type": "string",
										"title": "alarmState",
										"description": "The alarm state when the value is in this zone.",
										"name": "alarmState",
										"default": "normal",
										"enum": [
											"normal",
											"warn",
											"alarm"
										]
									},
									{
										"id": "message",
										"type": "string",
										"title": "message",
										"description": "The message to display for the alarm.",
										"default": "Warning"
									}
								]
							}
						]
					}
				}
			}
		}
	};

/***/ },
/* 45 */
/*!*********************************************!*\
  !*** ../specification/schemas/signalk.json ***!
  \*********************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/signalk.json#",
		"title": "SignalK",
		"description": "Root schema of Signal K. Contains the list of vessels plus a reference to the local boat (also contained in the vessels list).",
		"properties": {
			"self": {
				"type": "string",
				"description": "This holds the key (MMSI or other unique ID) of this vessel, the actual data is in the vessels array.",
				"required": true
			},
			"vessels": {
				"type": "object",
				"required": true,
				"description": "A wrapper object for vessel objects, each describing vessels in range, including this vessel.",
				"patternProperties": {
					"(^urn:mrn:(imo|signalk):(mmsi:[2-7][0-9]{8,8}|uuid:[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-4[0-9A-Fa-f]{3}-[89ABab][0-9A-Fa-f]{3}-[0-9A-Fa-f]{12}))|^(http(s?):.*|mailto:.*|tel:(\\+?)[0-9]{4,})$": {
						"description": "This regex pattern is used for validation of an MMSI or Signal K UUID identifier for the vessel",
						"$ref": "vessel.json#"
					}
				}
			},
			"resources": {
				"description": "resources to aid in navigation and operation of the vessel",
				"$ref": "groups/resources.json#"
			},
			"version": {
				"$ref": "definitions.json#/definitions/version"
			}
		}
	};

/***/ },
/* 46 */
/*!*******************************************!*\
  !*** ../specification/schemas/delta.json ***!
  \*******************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/delta.json#",
		"title": "SignalK Delta message schema",
		"description": "Schema for defining updates to parts of a SignalK data model, for example for communicating updates of data",
		"properties": {
			"context": {
				"type": "string",
				"description": "The context path of the updates, eg. the top level path plus object identifier."
			},
			"updates": {
				"type": "array",
				"description": "The updates",
				"items": {
					"type": "object",
					"properties": {
						"source": {
							"$ref": "./definitions.json#/definitions/source"
						},
						"timestamp": {
							"$ref": "./definitions.json#/definitions/timestamp"
						},
						"values": {
							"type": "array",
							"items": {
								"type": "object",
								"properties": {
									"path": {
										"type": "string",
										"required": true
									},
									"value": {
										"type": [
											"string",
											"number",
											"object",
											"boolean",
											"null"
										],
										"required": true,
										"additionalProperties": true
									}
								}
							}
						}
					}
				}
			}
		}
	};

/***/ },
/* 47 */
/*!*****************************************!*\
  !*** ../specification/schemas ^\.\/.*$ ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./def_loader": 48,
		"./def_loader.json": 48,
		"./def_loader_pre": 49,
		"./def_loader_pre.json": 49,
		"./definitions": 44,
		"./definitions.json": 44,
		"./delta": 46,
		"./delta.json": 46,
		"./groups/alarms": 30,
		"./groups/alarms.json": 30,
		"./groups/communication": 31,
		"./groups/communication.json": 31,
		"./groups/design": 32,
		"./groups/design.json": 32,
		"./groups/electrical_ac": 34,
		"./groups/electrical_ac.json": 34,
		"./groups/electrical_dc": 50,
		"./groups/electrical_dc.json": 50,
		"./groups/environment": 35,
		"./groups/environment.json": 35,
		"./groups/navigation": 33,
		"./groups/navigation.json": 33,
		"./groups/performance": 36,
		"./groups/performance.json": 36,
		"./groups/propulsion": 37,
		"./groups/propulsion.json": 37,
		"./groups/resources": 38,
		"./groups/resources.json": 38,
		"./groups/sails": 51,
		"./groups/sails.json": 51,
		"./groups/sensors": 39,
		"./groups/sensors.json": 39,
		"./groups/steering": 40,
		"./groups/steering.json": 40,
		"./groups/tanks": 41,
		"./groups/tanks.json": 41,
		"./messages/subscribe": 52,
		"./messages/subscribe.json": 52,
		"./messages/unsubscribe": 53,
		"./messages/unsubscribe.json": 53,
		"./signalk": 45,
		"./signalk.json": 45,
		"./vessel": 43,
		"./vessel.json": 43
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 47;


/***/ },
/* 48 */
/*!************************************************!*\
  !*** ../specification/schemas/def_loader.json ***!
  \************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/def_loader.json#",
		"title": "def_loader",
		"description": "Nasty hack to get the definitions loaded first, so they resolve nicely",
		"properties": {
			"stringValue": {
				"$ref": "definitions.json#/definitions/stringValue"
			},
			"floatValue": {
				"$ref": "definitions.json#/definitions/floatValue"
			},
			"nullValue": {
				"$ref": "definitions.json#/definitions/nullValue"
			},
			"alarmValue": {
				"$ref": "definitions.json#/definitions/alarmValue"
			},
			"alarmMethod": {
				"$ref": "definitions.json#/definitions/alarmMethod"
			}
		}
	};

/***/ },
/* 49 */
/*!****************************************************!*\
  !*** ../specification/schemas/def_loader_pre.json ***!
  \****************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/def_loader.json#",
		"title": "def_loader",
		"description": "Nasty hack to get the definitions loaded first, so they resolve nicely",
		"properties": {
			"source": {
				"$ref": "definitions.json#/definitions/source"
			},
			"timestamp": {
				"$ref": "definitions.json#/definitions/timestamp"
			},
			"version": {
				"$ref": "definitions.json#/definitions/version"
			},
			"number": {
				"$ref": "definitions.json#/definitions/numberValue"
			},
			"mmsi": {
				"$ref": "definitions.json#/definitions/mmsi"
			},
			"uuid": {
				"$ref": "definitions.json#/definitions/uuid"
			}
		}
	};

/***/ },
/* 50 */
/*!**********************************************************!*\
  !*** ../specification/schemas/groups/electrical_dc.json ***!
  \**********************************************************/
/***/ function(module, exports) {

	module.exports = {
		"$schema": "http://json-schema.org/draft-04/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/electrical_dc.json#",
		"description": "Schema describing the electrical child-object of a Vessel.",
		"title": "DC Electrical Properties",
		"type": "object",
		"properties": {
			"definitions": {
				"title": "definitions",
				"type": "object",
				"description": "DC related definitions",
				"properties": {
					"identity": {
						"type": "object",
						"title": "Electrical ID",
						"description": " Common ID items shared by electrical items",
						"required": [
							"name"
						],
						"properties": {
							"name": {
								"type": "string",
								"description": "Unique ID of device (houseBattery, alternator, Generator, solar1, inverterCharger, Combiner1, etc.)"
							},
							"location": {
								"type": "string",
								"description": "Installed location of device on vessel"
							},
							"manufacturerName": {
								"type": "string",
								"description": "Manufacturer's name"
							},
							"manufacturerModel": {
								"type": "string",
								"description": "Model or part number"
							},
							"dateInstalled": {
								"$ref": "../definitions.json#/definitions/timestamp",
								"description": "Date device was installed"
							},
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							}
						}
					},
					"dcSource": {
						"type": "object",
						"title": "DC Source",
						"description": "DC power source common values",
						"properties": {
							"associatedBus": {
								"type": "string",
								"description": "Name of BUS source is associated with (if applicable, may = NULL)"
							},
							"voltage": {
								"type": "object",
								"properties": {
									"measured": {
										"description": "Measured voltage of DC Source terminals",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "V"
									},
									"nominal": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "V",
										"description": "Designed 'voltage' of battery (12v, 24v, 32v, 36v, 42v, 48v, 144v, etc.)"
									},
									"warnUpper": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "V",
										"description": "Upper operational voltage limit"
									},
									"warnLower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "V",
										"description": "Lower operational voltage limit"
									},
									"faultUpper": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "V",
										"description": "Upper fault limit of battery voltage - BMS may disconnect battery"
									},
									"faultLower": {
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "V",
										"description": "Lower fault limit of battery voltage - BMS may disconnect battery"
									}
								}
							},
							"current": {
								"type": "object",
								"properties": {
									"measured": {
										"description": "Measured amperage being '+' provided (or '-' consumed) by DC source",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "A"
									},
									"warnUpper": {
										"description": "Upper operational current limit",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "A"
									},
									"warnLower": {
										"description": "Lower operational current limit",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "A"
									},
									"faultUpper": {
										"description": "Upper fault limit of battery current - BMS may disconnect battery",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "A"
									},
									"faultLower": {
										"description": "Lower fault limit of battery current - BMS may disconnect battery",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "A"
									}
								}
							},
							"temperature": {
								"type": "object",
								"title": "temperature",
								"properties": {
									"measured": {
										"description": "Temperature of device",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "K"
									},
									"warnUpper": {
										"description": "Upper operational temperature limit",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "K"
									},
									"warnLower": {
										"description": "Lower operational temperature limit",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "K"
									},
									"faultUpper": {
										"description": "Upper fault limit of temperature - device may disable",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "K"
									},
									"faultLower": {
										"description": "Lower fault limit of temperature  - device may disable",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "K"
									}
								}
							}
						}
					},
					"acSource": {
						"type": "object",
						"title": "AC Source",
						"description": "AC power source common values",
						"properties": {
							"associatedBus": {
								"type": "string",
								"description": "Name of BUS source is assocated with (if applicable, may = NULL)"
							},
							"voltage": {
								"type": "object",
								"properties": {
									"measured": {
										"description": "Measured voltage at AC Source terminals",
										"#ref": "../definitions.json#/definitions/numberValue",
										"units": "V"
									}
								}
							}
						}
					}
				}
			},
			"battery": {
				"type": "object",
				"title": "Battery",
				"description": "Batteries, one or many, within the vessel",
				"required": [
					"ID"
				],
				"properties": {
					"identity": {
						"$ref": "#/definitions/identity"
					},
					"dc": {
						"$ref": "#/definitions/dcSource"
					},
					"mode": {
						"type": "object",
						"description": "Operational mode of battery",
						"properties": {
							"value": {
								"type": "string",
								"enum": [
									"charging bulk",
									"charging acceptance",
									"charging overcharge",
									"charging float",
									"charging equalize",
									"discharging",
									"unknown",
									"other"
								]
							},
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							}
						}
					},
					"chemistry": {
						"$ref": "../definitions.json#/definitions/stringValue",
						"description": "Type of battery FLA, LiFePO4, etc."
					},
					"temperature": {
						"type": "object",
						"title": "temperature",
						"description": "Additional / unique temperatures associated with a battery",
						"properties": {
							"limitDischargeLower": {
								"type": "number",
								"description": "Operational minimum temperature limit for battery discharge",
								"units": "K"
							},
							"limitDischargeUpper": {
								"type": "number",
								"description": "Operational maximum temperature limit for battery discharge",
								"units": "K"
							},
							"limitRechargeLower": {
								"type": "number",
								"description": "Operational minimum temperature limit for battery recharging",
								"units": "K"
							},
							"limitRechargeUpper": {
								"type": "number",
								"description": "Operational maximum temperature limit for battery recharging",
								"units": "K"
							},
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							}
						}
					},
					"capacity": {
						"type": "object",
						"title": "capacity",
						"properties": {
							"nominal": {
								"type": "number",
								"description": "The capacity of battery as specified by the manufacturer",
								"units": "C"
							},
							"actual": {
								"type": "number",
								"description": "The measured capacity of battery. This may change over time and will likely deviate from the nominal capacity.",
								"units": "C"
							},
							"remaining": {
								"type": "number",
								"description": "Capacity remaining in battery",
								"units": "C"
							},
							"dischargeLimit": {
								"type": "number",
								"description": "Minimum capacity to be left in battery while discharging",
								"units": "C"
							}
						}
					},
					"lifetimeDischarge": {
						"type": "number",
						"description": "Cumulative capacity discharged from battery over operational lifetime of battery",
						"units": "C"
					},
					"lifetimeRecharge": {
						"type": "number",
						"description": "Cumulative capacity recharged into battery over operational lifetime of battery",
						"units": "C"
					}
				}
			},
			"inverter": {
				"type": "object",
				"title": "Inverter",
				"description": "DC to AC inverter, one or many, within the vessel",
				"required": [
					"ID"
				],
				"properties": {
					"identity": {
						"$ref": "#/definitions/identity"
					},
					"dc": {
						"$ref": "#/definitions/dcSource"
					},
					"ac": {
						"$ref": "#/definitions/acSource"
					},
					"mode": {
						"type": "object",
						"description": "Operational mode of battery",
						"properties": {
							"value": {
								"type": "string",
								"enum": [
									"idle",
									"inverting",
									"disabled",
									"standby",
									"faulted",
									"unknown",
									"other"
								]
							},
							"timestamp": {
								"$ref": "../definitions.json#/definitions/timestamp"
							},
							"source": {
								"$ref": "../definitions.json#/definitions/source"
							}
						}
					}
				}
			}
		}
	};

/***/ },
/* 51 */
/*!**************************************************!*\
  !*** ../specification/schemas/groups/sails.json ***!
  \**************************************************/
/***/ function(module, exports) {

	module.exports = {
		"type": "object",
		"$schema": "http://json-schema.org/draft-03/schema",
		"id": "https://signalk.github.io/specification/schemas/groups/sails.json#",
		"description": "An object describing the vessels sails if the vessel is a sailboat.",
		"title": "sails",
		"properties": {
			"available": {
				"type": "object",
				"description": "An object containing a description of each sail available to the vessel crew",
				"patternProperties": {
					"(^[a-zA-Z0-9]$)": {
						"description": "Each sail is identified by a unique name, containing only alphanumeric characters.",
						"$ref": "../definitions.json#/definitions/sail"
					}
				}
			},
			"area": {
				"type": "object",
				"description": "An object containing information about the vessels' sails.",
				"properties": {
					"total": {
						"description": "The total area of all sails on the vessel",
						"type": "number",
						"units": "m2"
					},
					"active": {
						"description": "The total area of the sails currently in use on the vessel",
						"type": "number",
						"units": "m2"
					},
					"timestamp": {
						"description": "timestamp of the last update to this data",
						"$ref": "#/definitions/timestamp"
					},
					"source": {
						"description": "Source of this data",
						"$ref": "#/definitions/source"
					}
				}
			}
		}
	};

/***/ },
/* 52 */
/*!********************************************************!*\
  !*** ../specification/schemas/messages/subscribe.json ***!
  \********************************************************/
/***/ function(module, exports) {

	module.exports = {
		"$schema": "http://json-schema.org/draft-04/schema#",
		"id": "/",
		"type": "object",
		"title": "Subscribe schema.",
		"description": "A message to allow a client to subscribe for data updates from a signalk server",
		"name": "/",
		"properties": {
			"context": {
				"id": "context",
				"type": "string",
				"title": "Context Path.",
				"description": "The root path for all subsequent paths, usually a vessel's path.",
				"name": "context",
				"example": "vessels.230099999"
			},
			"websocket.connectionkey": {
				"id": "websocket.connectionkey",
				"type": "string",
				"title": "Websocket.connectionkey.",
				"description": "An optional session key that is used in STOMP and MQTT messages where there are no session facilities",
				"name": "websocket.connectionkey",
				"example": "d2f691ac-a5ed-4cb7-b361-9072a24ce6bc"
			},
			"reply-to": {
				"id": "reply-to",
				"type": "string",
				"title": "Reply-to.",
				"description": "A reply queue that is used in STOMP and MQTT messages where there are no session facilities.",
				"name": "reply-to",
				"example": "signalk.3202a939-1681-4a74-ad4b-3a90212e4f33.vessels.motu.navigation"
			},
			"subscribe": {
				"id": "subscribe",
				"type": "array",
				"title": "Subscribe.",
				"description": "An array of paths to subscribe to, with optional criteria",
				"name": "subscribe",
				"items": [
					{
						"type": "object",
						"title": "Path object.",
						"description": "A path object with optional criteria to control output",
						"properties": {
							"path": {
								"id": "path",
								"type": "string",
								"title": "Path.",
								"description": "The path to subscribe to.",
								"name": "path",
								"example": "navigation.speedThroughWater"
							},
							"period": {
								"id": "period",
								"type": "integer",
								"title": "Period.",
								"description": "The subscription will be sent every period millisecs.",
								"name": "period",
								"default": 1000
							},
							"format": {
								"id": "format",
								"type": "string",
								"title": "Format.",
								"description": "The signal K format to use (full/delta) for the message.",
								"name": "format",
								"default": "delta"
							},
							"policy": {
								"id": "policy",
								"type": "string",
								"title": "Policy schema.",
								"description": "The policy for sending messages (instant/ideal/fixed).",
								"name": "policy",
								"default": "ideal"
							},
							"minPeriod": {
								"id": "minPeriod",
								"type": "integer",
								"title": "MinPeriod.",
								"description": "If policy=immediate or ideal, consequetive messages will be buffered until minPeriod has expired so the reciever is not swamped.",
								"name": "minPeriod",
								"default": 200
							}
						}
					}
				]
			}
		},
		"required": [
			"context",
			"subscribe"
		]
	};

/***/ },
/* 53 */
/*!**********************************************************!*\
  !*** ../specification/schemas/messages/unsubscribe.json ***!
  \**********************************************************/
/***/ function(module, exports) {

	module.exports = {
		"$schema": "http://json-schema.org/draft-04/schema#",
		"id": "/",
		"type": "object",
		"title": "Unsubscribe schema.",
		"description": "A message to allow a client to unsubscribe from data updates from a signalk server",
		"name": "/",
		"properties": {
			"context": {
				"id": "context",
				"type": "string",
				"title": "Context Path.",
				"description": "The root path for all subsequent paths, usually a vessel's path.",
				"name": "context",
				"example": "vessels.230099999"
			},
			"websocket.connectionkey": {
				"id": "websocket.connectionkey",
				"type": "string",
				"title": "Websocket.connectionkey.",
				"description": "An optional session key that is used in STOMP and MQTT messages where there are no session facilities",
				"name": "websocket.connectionkey",
				"example": "d2f691ac-a5ed-4cb7-b361-9072a24ce6bc"
			},
			"reply-to": {
				"id": "reply-to",
				"type": "string",
				"title": "Reply-to.",
				"description": "A reply queue that is used in STOMP and MQTT messages where there are no session facilities.",
				"name": "reply-to",
				"example": "signalk.3202a939-1681-4a74-ad4b-3a90212e4f33.vessels.motu.navigation"
			},
			"unsubscribe": {
				"id": "unsubscribe",
				"type": "array",
				"title": "Unsubscribe.",
				"description": "An array of paths to unsubscribe from.",
				"name": "unsubscribe",
				"items": [
					{
						"type": "object",
						"title": "Path object.",
						"description": "A path object with optional criteria to control output",
						"properties": {
							"path": {
								"id": "path",
								"type": "string",
								"title": "Path.",
								"description": "The path to subscribe to.",
								"name": "path",
								"example": "navigation.speedThroughWater"
							},
							"period": {
								"id": "period",
								"type": "integer",
								"title": "Period.",
								"description": "The subscription will be sent every period millisecs.",
								"name": "period",
								"default": 1000
							},
							"format": {
								"id": "format",
								"type": "string",
								"title": "Format.",
								"description": "The signal K format to use (full/delta) for the message.",
								"name": "format",
								"default": "delta"
							},
							"policy": {
								"id": "policy",
								"type": "string",
								"title": "Policy schema.",
								"description": "The policy for sending messages (instant/ideal/fixed).",
								"name": "policy",
								"default": "ideal"
							},
							"minPeriod": {
								"id": "minPeriod",
								"type": "integer",
								"title": "MinPeriod.",
								"description": "If policy=immediate or ideal, consequetive messages will be buffered until minPeriod has expired so the reciever is not swamped.",
								"name": "minPeriod",
								"default": 200
							}
						}
					}
				]
			}
		},
		"required": [
			"context",
			"unsubscribe"
		]
	};

/***/ },
/* 54 */
/*!**************************************!*\
  !*** ../specification/i18n/index.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports.en = __webpack_require__(/*! ./en.json */ 55);

/***/ },
/* 55 */
/*!*************************************!*\
  !*** ../specification/i18n/en.json ***!
  \*************************************/
/***/ function(module, exports) {

	module.exports = {
		"@metadata": {
			"locale": "en"
		},
		"alarms.anchorAlarmMethod": {
			"shortName": "Anchor Alarm Method",
			"longName": "Anchor Alarm Method"
		},
		"alarms.anchorAlarmState": {
			"shortName": "Anchor Alarm State",
			"longName": "Anchor Alarm State"
		},
		"alarms.autopilotAlarmMethod": {
			"shortName": "Autopilot Alarm Method",
			"longName": "Autopilot Alarm Method"
		},
		"alarms.autopilotAlarmState": {
			"shortName": "Autopilot Alarm State",
			"longName": "Autopilot Alarm State"
		},
		"alarms.engineAlarmMethod": {
			"shortName": "Engine Alarm Method",
			"longName": "Engine Alarm Method"
		},
		"alarms.engineAlarmState": {
			"shortName": "Engine Alarm State",
			"longName": "Engine Alarm State"
		},
		"alarms.fireAlarmMethod": {
			"shortName": "Fire Alarm Method",
			"longName": "Fire Alarm Method"
		},
		"alarms.fireAlarmState": {
			"shortName": "Fire Alarm State",
			"longName": "Fire Alarm State"
		},
		"alarms.gasAlarmMethod": {
			"shortName": "Gas Alarm Method",
			"longName": "Gas Alarm Method"
		},
		"alarms.gasAlarmState": {
			"shortName": "Gas Alarm State",
			"longName": "Gas Alarm State"
		},
		"alarms.gpsAlarmMethod": {
			"shortName": "GPS Alarm Method",
			"longName": "GPS Alarm Method"
		},
		"alarms.gpsAlarmState": {
			"shortName": "GPS Alarm State",
			"longName": "GPS Alarm State"
		},
		"alarms.maydayAlarmMethod": {
			"shortName": "Mayday Alarm Method",
			"longName": "Mayday Alarm Method"
		},
		"alarms.maydayAlarmState": {
			"shortName": "Mayday Alarm State",
			"longName": "Mayday Alarm State"
		},
		"alarms.panpanAlarmMethod": {
			"shortName": "Panpan Alarm Method",
			"longName": "Panpan Alarm Method"
		},
		"alarms.panpanAlarmState": {
			"shortName": "Panpan Alarm State",
			"longName": "Panpan Alarm State"
		},
		"alarms.powerAlarmMethod": {
			"shortName": "Power Alarm Method",
			"longName": "Power Alarm Method"
		},
		"alarms.powerAlarmState": {
			"shortName": "Power Alarm State",
			"longName": "Power Alarm State"
		},
		"alarms.silentInterval": {
			"shortName": "Silent Interval",
			"longName": "Silent Interval"
		},
		"alarms.windAlarmMethod": {
			"shortName": "Wind Alarm Method",
			"longName": "Wind Alarm Method"
		},
		"alarms.windAlarmState": {
			"shortName": "Wind Alarm State",
			"longName": "Wind Alarm State"
		},
		"communication.callsignDsc": {
			"shortName": "Callsign DSC",
			"longName": "Callsign Digital Selective Calling"
		},
		"communication.callsignHf": {
			"shortName": "Callsign HF",
			"longName": "Callsign HF Radio"
		},
		"communication.callsignVhf": {
			"shortName": "Callsign VHF",
			"longName": "Callsign VHF Radio"
		},
		"communication.cellPhone": {
			"shortName": "Cell Phone",
			"longName": "Cell Phone Number"
		},
		"communication.emailHf": {
			"shortName": "Email HF",
			"longName": "Email HF"
		},
		"communication.email": {
			"shortName": "Email",
			"longName": "Email Address"
		},
		"communication.satPhone": {
			"shortName": "Sat Phone",
			"longName": "Satellite Phone"
		},
		"communication.skipperName": {
			"shortName": "Skipper Name",
			"longName": "Skipper Name"
		},
		"communication.crewNames": {
			"shortName": "Crew Names",
			"longName": "Crew Names"
		},
		"design.name": {
			"shortName": "Name",
			"longName": "Common Name"
		},
		"design.displacement": {
			"shortName": "Displacement",
			"longName": "Displacement"
		},
		"design.draft": {
			"shortName": "Draft",
			"longName": "Draft in Meters"
		},
		"design.canoeDraft": {
			"shortName": "Canoe Draft",
			"longName": "Canoe Draft in Meters"
		},
		"design.loa": {
			"shortName": "LOA",
			"longName": "Length Overall in Meters"
		},
		"design.loh": {
			"shortName": "LOH",
			"longName": "Length Over Hull in Meters"
		},
		"design.lwl": {
			"shortName": "LWL",
			"longName": "Waterline Length in Meters"
		},
		"design.beam": {
			"shortName": "Beam",
			"longName": "Beam in Meters"
		},
		"design.sailArea": {
			"shortName": "Sail Area",
			"longName": "Sail Area in Square Meters"
		},
		"design.airHeight": {
			"shortName": "Air Height",
			"longName": "Air Height in Meters"
		},
		"environment.airPressureChangeRateAlarm": {
			"shortName": "Air Pressure Change Rate Alarm",
			"longName": "Air Pressure Change Rate Alarm in kPa"
		},
		"environment.airPressure": {
			"shortName": "Air Pressure",
			"longName": "Air Pressure in kPa"
		},
		"environment.airTemp": {
			"shortName": "Air Temperature",
			"longName": "Air Temperature in Celsius"
		},
		"environment.depth": {
			"shortName": "Depth",
			"longName": "Depth in Meters"
		},
		"environment.depth.belowKeel": {
			"shortName": "DBK",
			"longName": "Depth Below Keel",
			"unit": "m"
		},
		"environment.depth.belowTransducer": {
			"shortName": "DBT",
			"longName": "Depth Below Transducer",
			"unit": "m"
		},
		"environment.depth.belowSurface": {
			"shortName": "Depth Below Surface",
			"longName": "Depth Below Surface in Meters"
		},
		"environment.depth.transducerToKeel": {
			"shortName": "Depth Transducer to Keel",
			"longName": "Depth Transducer to Keel in Meters"
		},
		"environment.depth.surfaceToTransducer": {
			"shortName": "Depth Surface to Transducer",
			"longName": "Depth Surface to Transducer in Meters"
		},
		"environment.humidity": {
			"shortName": "Humidity",
			"longName": "Relative Humidity"
		},
		"environment.salinity": {
			"shortName": "Salinity",
			"longName": "Water Salinity"
		},
		"environment.tide": {
			"shortName": "Tide",
			"longName": "Tide Data"
		},
		"environment.tide.heightHigh": {
			"shortName": "High Tide Height",
			"longName": "High tide Height in Meters"
		},
		"environment.tide.heightNow": {
			"shortName": "Current Tide Height",
			"longName": "Current Tide Height in Meters"
		},
		"environment.tide.heightLow": {
			"shortName": "Low Tide Height",
			"longName": "Low tide Height in Meters"
		},
		"environment.tide.timeLow": {
			"shortName": "Low Tide Time",
			"longName": "Time of Next Low Tide"
		},
		"environment.tide.timeHigh": {
			"shortName": "High Tide Time",
			"longName": "Time of Next Low Tide"
		},
		"environment.waterTemp": {
			"shortName": "Water Temperature",
			"longName": "Water Temperature in Celsius"
		},
		"environment.wind": {
			"shortName": "Wind",
			"longName": "Wind Data"
		},
		"environment.wind.angleApparent": {
			"shortName": "Angle Apparent",
			"longName": "Apparent Wind Angle"
		},
		"environment.wind.angleTrue": {
			"shortName": "Angle True",
			"longName": "True Wind Angle"
		},
		"environment.wind.directionChangeAlarm": {
			"shortName": "Direction Change Alarm",
			"longName": "Wind Direction Change to Raise Alarm"
		},
		"environment.wind.directionTrue": {
			"shortName": "Direction True",
			"longName": "True Wind Direction"
		},
		"environment.wind.directionMagnetic": {
			"shortName": "Direction Magnetic",
			"longName": "Wind Direction Magnetic"
		},
		"environment.wind.speedAlarm": {
			"shortName": "Speed Alarm",
			"longName": "Wind Speed Alarm in Meters/Second"
		},
		"environment.wind.speedTrue": {
			"shortName": "Speed True",
			"longName": "True Wind Speed in Meters/Second"
		},
		"environment.wind.speedOverGround": {
			"shortName": "TWS",
			"longName": "Wind Speed Over Ground in Meters/Second"
		},
		"environment.wind.speedApparent": {
			"shortName": "AWS",
			"longName": "Apparent Wind Speed in Meters/Second"
		},
		"navigation.courseOverGroundTrue": {
			"shortName": "COG(t)",
			"longName": "Course Over Ground, True"
		},
		"navigation.courseOverGroundMagnetic": {
			"shortName": "COG(m)",
			"longName": "Course Over Ground, Magnetic"
		},
		"navigation.activeRoute": {
			"shortName": "Active Route",
			"longName": "Active Route"
		},
		"navigation.activeRoute.timestamp": {
			"shortName": "Timestamp",
			"longName": "Active Route Timestamp"
		},
		"navigation.activeRoute.source": {
			"shortName": "Source",
			"longName": "Active Route Source"
		},
		"navigation.activeRoute.bearingActual": {
			"shortName": "Actual Bearing",
			"longName": "Active Route Actual Bearing"
		},
		"navigation.activeRoute.bearingDirect": {
			"shortName": "Direct Bearing",
			"longName": "Active Route Direct Bearing"
		},
		"navigation.activeRoute.courseRequired": {
			"shortName": "Required Course",
			"longName": "Active Route Required Course"
		},
		"navigation.activeRoute.eta": {
			"shortName": "ETA",
			"longName": "Active Route Estimated Time of Arrival"
		},
		"navigation.activeRoute.route": {
			"shortName": "Route",
			"longName": "Active Route - Route From Route List"
		},
		"navigation.activeRoute.startTime": {
			"shortName": "Start Time",
			"longName": "Active Route Start Time"
		},
		"navigation.activeRoute.waypoint": {
			"shortName": "Waypoint",
			"longName": "Active Route Waypoint"
		},
		"navigation.activeRoute.waypoint.lastTime": {
			"shortName": "AR Waypoint TLR",
			"longName": "Active Route Waypoint Time Last Reached"
		},
		"navigation.activeRoute.waypoint.last": {
			"shortName": "Waypoint Last",
			"longName": "Active Route Waypoint Last"
		},
		"navigation.activeRoute.waypoint.nextEta": {
			"shortName": "Waypoint Next ETA",
			"longName": "Active Route Waypoint Next Estimated Time of Arrival"
		},
		"navigation.activeRoute.waypoint.next": {
			"shortName": "Waypoint Next",
			"longName": "Active Route Next Waypoint"
		},
		"navigation.activeRoute.waypoint.xte": {
			"shortName": "Waypoint XTE",
			"longName": "Active Route Waypoint Cross Track Error in Meters"
		},
		"navigation.magneticVariation": {
			"shortName": "Magnetic Variation",
			"longName": "Magnetic Variation at Current Position"
		},
		"navigation.destination": {
			"shortName": "Destination",
			"longName": "Trip Destination"
		},
		"navigation.destination.eta": {
			"shortName": "ETA",
			"longName": "Estimated Time of Arrival"
		},
		"navigation.destination.source": {
			"shortName": "Source",
			"longName": "Source of Data"
		},
		"navigation.destination.timestamp": {
			"shortName": "Timestamp",
			"longName": "Timestamp of Last Update"
		},
		"navigation.destination.longitude": {
			"shortName": "Longitude",
			"longName": "Longitude od Destination"
		},
		"navigation.destination.latitude": {
			"shortName": "Latitude",
			"longName": "Latitude of Destination"
		},
		"navigation.destination.altitude": {
			"shortName": "Altitude",
			"longName": "Altitude of Destination"
		},
		"navigation.current": {
			"shortName": "Current",
			"longName": "Current"
		},
		"navigation.current.timestamp": {
			"shortName": "Timestamp",
			"longName": "Timestamp"
		},
		"navigation.current.drift": {
			"shortName": "Drift",
			"longName": "Current Drift"
		},
		"navigation.current.setTrue": {
			"shortName": "Set True",
			"longName": "Current Set True"
		},
		"navigation.current.setMagnetic": {
			"shortName": "Set Magnetic",
			"longName": "Current Set Magnetic"
		},
		"navigation.gnss": {
			"shortName": "GNSS",
			"longName": "Global Navigation Satellite System"
		},
		"navigation.gnss.timestamp": {
			"shortName": "Timestamp",
			"longName": "Timestamp"
		},
		"navigation.gnss.quality": {
			"shortName": "Quality",
			"longName": "Quality of Fix"
		},
		"navigation.gnss.satellites": {
			"shortName": "Number",
			"longName": "Number of Satellites"
		},
		"navigation.gnss.antennaAltitude": {
			"shortName": "Antenna Altitude",
			"longName": "Altitude of Antenna"
		},
		"navigation.gnss.horizontalDilution": {
			"shortName": "Horizontal Dilution",
			"longName": "Horizontal Position Error"
		},
		"navigation.gnss.geoidalSeparation": {
			"shortName": "Geoidal Separation",
			"longName": "Geoidal Separation"
		},
		"navigation.gnss.differentialAge": {
			"shortName": "DGPS Age",
			"longName": "DGPS Age in Seconds"
		},
		"navigation.gnss.differentialReference": {
			"shortName": "Differential Reference",
			"longName": "DGPS Base Station ID"
		},
		"navigation.headingMagnetic": {
			"shortName": "Heading Magnetic",
			"longName": "Heading Magnetic in Degrees"
		},
		"navigation.headingTrue": {
			"shortName": "Heading True",
			"longName": "Heading True in Degrees"
		},
		"navigation.position": {
			"shortName": "Position 3D",
			"longName": "Position in 3 Dimensions"
		},
		"navigation.position.source": {
			"shortName": "Source",
			"longName": "Source of Data"
		},
		"navigation.position.timestamp": {
			"shortName": "Timestamp",
			"longName": "Timestamp of Last Update"
		},
		"navigation.position.longitude": {
			"shortName": "Longitude",
			"longName": "Current Longitude"
		},
		"navigation.position.latitude": {
			"shortName": "Latitude",
			"longName": "Current Latitude"
		},
		"navigation.position.altitude": {
			"shortName": "Altitude",
			"longName": "Current Altitude"
		},
		"navigation.pitch": {
			"shortName": "Pitch",
			"longName": "Pitch in Degrees"
		},
		"navigation.yaw": {
			"shortName": "Yaw",
			"longName": "Yaw in Degrees"
		},
		"navigation.rateOfTurn": {
			"shortName": "Rate of Turn",
			"longName": "Rate of Turn in Degrees/Second"
		},
		"navigation.roll": {
			"shortName": "Roll",
			"longName": "Roll in Degrees"
		},
		"navigation.speedOverGround": {
			"shortName": "SOG",
			"longName": "Speed Over Ground",
			"unit": "mps"
		},
		"navigation.speedThroughWater": {
			"shortName": "STW",
			"longName": "Speed Through Water",
			"unit": "mps"
		},
		"navigation.log": {
			"shortName": "Log",
			"longName": "Log in Nautical Miles"
		},
		"navigation.logTrip": {
			"shortName": "Trip Log",
			"longName": "Trip Log in Nautical Miles"
		},
		"navigation.state": {
			"shortName": "State",
			"longName": "Navigational State of Vessel"
		},
		"navigation.state.source": {
			"shortName": "Source",
			"longName": "Source of Data"
		},
		"navigation.state.timestamp": {
			"shortName": "Timestamp",
			"longName": "Timestamp"
		},
		"navigation.state.value": {
			"shortName": "Value",
			"longName": "Value"
		},
		"navigation.anchor": {
			"shortName": "Anchor",
			"longName": "Anchor Data"
		},
		"navigation.anchor.source": {
			"shortName": "Source",
			"longName": "Source of Data"
		},
		"navigation.anchor.timestamp": {
			"shortName": "Timestamp",
			"longName": "Timestamp"
		},
		"navigation.anchor.maxRadius": {
			"shortName": "Max Radius",
			"longName": "Maximum Anchor Radius in Meters"
		},
		"navigation.anchor.currentRadius": {
			"shortName": "Current Radius",
			"longName": "Distance to Anchor in Meters"
		},
		"navigation.anchor.position": {
			"shortName": "Anchor Position",
			"longName": "Anchor Position 3D"
		},
		"navigation.anchor.position.source": {
			"shortName": "Source",
			"longName": "Source of Data"
		},
		"navigation.anchor.position.timestamp": {
			"shortName": "Timestamp",
			"longName": "Timestamp"
		},
		"navigation.anchor.position.longitude": {
			"shortName": "Longitude",
			"longName": "Longitude of Anchor Position"
		},
		"navigation.anchor.position.latitude": {
			"shortName": "Latitude",
			"longName": "Latitude of Anchor Position"
		},
		"navigation.anchor.position.altitude": {
			"shortName": "Altitude",
			"longName": "Altitude of Anchor Position"
		},
		"propulsion.engineType": {
			"shortName": "Engine Type",
			"longName": "Type of Engine"
		},
		"propulsion.state": {
			"shortName": "State",
			"longName": "State of Engine"
		},
		"propulsion.rpm": {
			"shortName": "RPM",
			"longName": "Revolutions Per Minute"
		},
		"propulsion.rpmAlarm": {
			"shortName": "RPM Alarm",
			"longName": "RPM Limit to Raise Alarm"
		},
		"propulsion.engineTemperature": {
			"shortName": "Engine Temperature",
			"longName": "Engine Temperature in Degrees Celsius"
		},
		"propulsion.engineTemperatureAlarm": {
			"shortName": "Engine Temperature Alarm",
			"longName": "Engine Temperature in Degrees Celsius to Raise Alarm"
		},
		"propulsion.oilTemperature": {
			"shortName": "Oil Temperature",
			"longName": "Oil Temperature in Degrees Celsius"
		},
		"propulsion.oilTemperatureAlarm": {
			"shortName": "Oil Temperature Alarm",
			"longName": "Oil Temperature in Degrees Celsius to Raise Alarm"
		},
		"propulsion.oilPressure": {
			"shortName": "Oil Pressure",
			"longName": "Oil Pressure in kPa"
		},
		"propulsion.oilPressureAlarm": {
			"shortName": "Oil Pressure Alarm",
			"longName": "Oil Pressure Alarm in kPa to Raise Alarm"
		},
		"propulsion.waterTemp": {
			"shortName": "Water Temperature",
			"longName": "Water Temperature in Degrees Celsius"
		},
		"propulsion.waterTempAlarm": {
			"shortName": "Water Temperature Alarm",
			"longName": "Water Temperature in Degrees Celsius to Raise Alarm"
		},
		"propulsion.exhaustTemp": {
			"shortName": "Exhaust Temperature",
			"longName": "Exhaust Temperature in Degrees Celsius"
		},
		"propulsion.exhaustTempAlarm": {
			"shortName": "Exhaust Temperature Alarm",
			"longName": "Exhaust Temperature in Degrees Celsius to Raise Alarm"
		},
		"propulsion.fuelUsageRate": {
			"shortName": "Fuel Usage Rate",
			"longName": "Fuel Usage Rate in Liters/Hour"
		},
		"resources.charts": {
			"shortName": "Charts",
			"longName": "Charts"
		},
		"resources.charts.name": {
			"shortName": "Name",
			"longName": "Chart Name"
		},
		"resources.charts.identifier": {
			"shortName": "Identifier",
			"longName": "Chart Number"
		},
		"resources.charts.description": {
			"shortName": "Description",
			"longName": "Chart Description"
		},
		"resources.charts.tilemapUrl": {
			"shortName": "Tile Map URL",
			"longName": "Tile Map URL"
		},
		"resources.charts.chartUrl": {
			"shortName": "Chart URL",
			"longName": "URL to Chart Storage Location"
		},
		"resources.charts.chartFormat": {
			"shortName": "Chart Format",
			"longName": "Chart Format"
		},
		"resources.routes": {
			"shortName": "Routes",
			"longName": "Routes"
		},
		"resources.routes.name": {
			"shortName": "Route Name",
			"longName": "Route Common Name"
		},
		"resources.routes.description": {
			"shortName": "Description",
			"longName": "Route Description"
		},
		"resources.routes.distance": {
			"shortName": "Distance",
			"longName": "Distance of Route "
		},
		"resources.routes.waypoints": {
			"shortName": "Waypoints",
			"longName": "Route Waypoints"
		},
		"resources.notes": {
			"shortName": "Notes",
			"longName": "Notes"
		},
		"resources.notes.title": {
			"shortName": "Title",
			"longName": "Common Name of Area"
		},
		"resources.notes.description": {
			"shortName": "Description",
			"longName": "Description of Notes"
		},
		"resources.notes.region": {
			"shortName": "Region",
			"longName": "Region UUID"
		},
		"resources.notes.mimeType": {
			"shortName": "MIME Type",
			"longName": "MIME Type"
		},
		"resources.notes.url": {
			"shortName": "URL",
			"longName": "URL"
		},
		"resources.regions": {
			"shortName": "Regions",
			"longName": "Regions"
		},
		"resources.regions.name": {
			"shortName": "Name",
			"longName": "Common Name of Region"
		},
		"resources.regions.description": {
			"shortName": "Description",
			"longName": "Description"
		},
		"resources.regions.waypoints": {
			"shortName": "Waypoints",
			"longName": "Set of Waypoints Describing Boundary of Region"
		},
		"resources.waypoints": {
			"shortName": "Waypoints",
			"longName": "Waypoints"
		},
		"resources.waypoints.name": {
			"shortName": "Name",
			"longName": "Name of Waypoint"
		},
		"resources.waypoints.position": {
			"shortName": "Position",
			"longName": "Position of Waypoint in 3D"
		},
		"resources.waypoints.position.source": {
			"shortName": "Source",
			"longName": "Source of Waypoint Position Data"
		},
		"resources.waypoints.position.timestamp": {
			"shortName": "Timestamp",
			"longName": "Timestamp of Last Update"
		},
		"resources.waypoints.position.longitude": {
			"shortName": "Longitude",
			"longName": "Longitude of Waypoint"
		},
		"resources.waypoints.position.latitude": {
			"shortName": "Latitude",
			"longName": "Latitude of Waypoint"
		},
		"resources.waypoints.position.altitude": {
			"shortName": "Altitude",
			"longName": "Altitude of Waypoint"
		},
		"resources.waypoints.description": {
			"shortName": "Description",
			"longName": "Description of Waypoint"
		},
		"resources.waypoints.type": {
			"shortName": "Type",
			"longName": "Type of Waypoint"
		},
		"sensors.name": {
			"shortName": "Name",
			"longName": "Name of Sensor"
		},
		"sensors.sensorType": {
			"shortName": "Sensor Type",
			"longName": "Sensor Type"
		},
		"sensors.sensorData": {
			"shortName": "Sensor Data",
			"longName": "Sensor Data"
		},
		"sensors.fromBow": {
			"shortName": "From Bow",
			"longName": "Distance From Bow in Meters"
		},
		"sensors.fromCenter": {
			"shortName": "From Center",
			"longName": "Distance From Center in Meters"
		},
		"steering.rudderAngle": {
			"shortName": "Rudder Angle",
			"longName": "Rudder Angle in Degrees"
		},
		"steering.rudderAngleTarget": {
			"shortName": "Rudder Angle Target",
			"longName": "Rudder Angle Target in Degrees"
		},
		"steering.autopilot": {
			"shortName": "Autopilot",
			"longName": "Autopilot Data"
		},
		"steering.autopilot.state": {
			"shortName": "State",
			"longName": "Autopilot State"
		},
		"steering.autopilot.mode": {
			"shortName": "Mode",
			"longName": "Operational Mode of Autopilot"
		},
		"steering.autopilot.targetHeadingNorth": {
			"shortName": "Target Heading North",
			"longName": "Target Heading North in Degrees True"
		},
		"steering.autopilot.targetHeadingMagnetic": {
			"shortName": "Target Heading Magnetic",
			"longName": "Target Heading Magnetic in Degrees True"
		},
		"steering.autopilot.alarmHeadingXte": {
			"shortName": "Alarm Heading XTE",
			"longName": "Heading Cross Track Error in Meters to Raise Alarm"
		},
		"steering.autopilot.headingSource": {
			"shortName": "Heading Source",
			"longName": "Current Source of Heading"
		},
		"steering.autopilot.deadZone": {
			"shortName": "Dead Zone",
			"longName": "Dead Zone for Rudder Corrections in Degrees"
		},
		"steering.autopilot.backlash": {
			"shortName": "Backlash",
			"longName": "Rudder Slack in Degrees"
		},
		"steering.autopilot.gain": {
			"shortName": "Gain",
			"longName": "Autopilot Gain"
		},
		"steering.autopilot.maxDriveAmps": {
			"shortName": "Max Drive Amps",
			"longName": "Maximum Amperage to Drive Servo"
		},
		"steering.autopilot.maxDriveRate": {
			"shortName": "Max Drive Rate",
			"longName": "Maximum Degrees/Second to Turn Rudder"
		},
		"steering.autopilot.portLock": {
			"shortName": "Port Lock",
			"longName": "Position of Servo on Port Lock"
		},
		"steering.autopilot.starboardLock": {
			"shortName": "Starboard Lock",
			"longName": "Position of Servo on Starboard Lock"
		}
	};

/***/ },
/* 56 */
/*!**********************************************!*\
  !*** ../specification/keyswithmetadata.json ***!
  \**********************************************/
/***/ function(module, exports) {

	module.exports = {
		"design.displacement": {
			"description": "The displacement of the vessel",
			"units": "kg"
		},
		"design.draft.minimum": {
			"description": "The minimum draft of the vessel",
			"units": "m"
		},
		"design.draft.maximum": {
			"description": "The maximum draft of the vessel",
			"units": "m"
		},
		"design.draft.canoe": {
			"description": "The draft of the vessel without protrusions such as keel, centerboard, rudder",
			"units": "m"
		},
		"design.length.overall": {
			"description": "Length overall",
			"units": "m"
		},
		"design.length.hull": {
			"description": "Length of hull",
			"units": "m"
		},
		"design.length.waterline": {
			"description": "Length at waterline",
			"units": "m"
		},
		"design.keel.angle": {
			"description": "A number indicating at which angle the keel currently is (in case of a canting keel), negative to port.",
			"units": "rad"
		},
		"design.keel.lift": {
			"description": "In the case of a lifting keel, centreboard or daggerboard, the part of the keel which is extended. 0 is 'all the way up' and 1 is 'all the way down'. 0.8 would be 80% down.",
			"units": "ratio"
		},
		"design.beam": {
			"description": "Beam length",
			"units": "m"
		},
		"design.airHeight": {
			"description": "Total height of the vessel",
			"units": "m"
		},
		"navigation.courseOverGroundMagnetic": {
			"description": "Course over ground (magnetic)",
			"units": "rad"
		},
		"navigation.courseOverGroundTrue": {
			"description": "Course over ground (true)",
			"units": "rad"
		},
		"navigation.activeRoute.bearingActual": {
			"description": "The current bearing of the next waypoint relative to true North",
			"units": "rad"
		},
		"navigation.activeRoute.distanceActual": {
			"description": "The current distance to the next waypoint",
			"units": "m"
		},
		"navigation.activeRoute.bearingDirect": {
			"description": "The bearing relative to true North from last waypoint to the next waypoint",
			"units": "rad"
		},
		"navigation.activeRoute.courseRequired": {
			"description": "The course relative to true North towards the next waypoint",
			"units": "rad"
		},
		"navigation.activeRoute.waypoint.xte": {
			"description": "Cross track error",
			"units": "m"
		},
		"navigation.magneticVariation": {
			"description": "The magnetic variation (declination) at the current position",
			"units": "rad"
		},
		"navigation.destination.longitude": {
			"description": "Longitude of the destination",
			"units": "deg"
		},
		"navigation.destination.latitude": {
			"description": "Latitude of the destination",
			"units": "deg"
		},
		"navigation.destination.altitude": {
			"description": "Altitude of the destination",
			"units": "m"
		},
		"navigation.gnss.antennaAltitude": {
			"description": "Altitude of antenna",
			"units": "m"
		},
		"navigation.gnss.differentialAge": {
			"description": "Age of DGPS data",
			"units": "s"
		},
		"navigation.headingMagnetic": {
			"description": "Current magnetic heading of the vessels",
			"units": "rad"
		},
		"navigation.headingTrue": {
			"description": "The current true heading of the vessel",
			"units": "rad"
		},
		"navigation.position.longitude": {
			"description": "Longitude of boat",
			"units": "deg"
		},
		"navigation.position.latitude": {
			"description": "Latitude of boat",
			"units": "deg"
		},
		"navigation.position.altitude": {
			"description": "Altitude of boat",
			"units": "m"
		},
		"navigation.attitude.roll": {
			"description": "Vessel roll, +ve is list to starboard",
			"units": "rad"
		},
		"navigation.attitude.pitch": {
			"description": "Pitch, +ve is bow up",
			"units": "rad"
		},
		"navigation.attitude.yaw": {
			"description": "Yaw, +ve is heading change to starboard",
			"units": "rad"
		},
		"navigation.rateOfTurn": {
			"description": "Rate of turn",
			"units": "rad/s"
		},
		"navigation.speedOverGround": {
			"description": "Vessel speed over ground",
			"units": "m/s"
		},
		"navigation.speedThroughWater": {
			"description": "Vessel speed through the water",
			"units": "m/s"
		},
		"navigation.log": {
			"description": "Log value",
			"units": "m"
		},
		"navigation.logTrip": {
			"description": "Trip log value",
			"units": "m"
		},
		"navigation.anchor.maxRadius": {
			"description": "Radius of anchor alarm boundary. The distance from anchor to the center of the boat",
			"units": "m"
		},
		"navigation.anchor.currentRadius": {
			"description": "Current distance to anchor",
			"units": "m"
		},
		"navigation.anchor.position.longitude": {
			"description": "Longitude of the anchor",
			"units": "deg"
		},
		"navigation.anchor.position.latitude": {
			"description": "Latitude of the anchor",
			"units": "deg"
		},
		"navigation.anchor.position.altitude": {
			"description": "Altitude of the anchor",
			"units": "m"
		},
		"electrical_ac.bus1.phaseA.lineLineVoltage": {
			"description": "RMS voltage measured between bus phase A and phase B.",
			"units": "V"
		},
		"electrical_ac.bus1.phaseA.lineNeutralVoltage": {
			"description": "RMS voltage measured between bus phase A and neutral.",
			"units": "V"
		},
		"electrical_ac.bus1.phaseA.frequency": {
			"description": "Bus phase A frequency.",
			"units": "Hz"
		},
		"electrical_ac.bus1.phaseB.lineLineVoltage": {
			"description": "RMS voltage measured between bus phase B and phase C.",
			"units": "V"
		},
		"electrical_ac.bus1.phaseB.lineNeutralVoltage": {
			"description": "RMS voltage measured between bus phase B and neutral.",
			"units": "V"
		},
		"electrical_ac.bus1.phaseB.frequency": {
			"description": "Bus phase B frequency.",
			"units": "Hz"
		},
		"electrical_ac.bus1.phaseC.lineLineVoltage": {
			"description": "RMS voltage measured between bus phase C and phase A.",
			"units": "V"
		},
		"electrical_ac.bus1.phaseC.lineNeutralVoltage": {
			"description": "RMS voltage measured between bus phase C and neutral.",
			"units": "V"
		},
		"electrical_ac.bus1.phaseC.frequency": {
			"description": "Bus phase C frequency.",
			"units": "Hz"
		},
		"electrical_ac.bus1.average.lineLineVoltage": {
			"description": "Average RMS voltage measured between two hot legs of a 3-phase or split-phase bus.",
			"units": "V"
		},
		"electrical_ac.bus1.average.lineNeutralVoltage": {
			"description": "Average RMS voltage measured between any hot leg and neutral in a 3-phase, split-phase, or single phase bus.",
			"units": "V"
		},
		"electrical_ac.bus1.average.frequency": {
			"description": "Average frequency of the bus.",
			"units": "Hz"
		},
		"electrical_ac.utility.phaseA.lineLineVoltage": {
			"description": "RMS voltage measured between utility phase A and phase B.",
			"units": "V"
		},
		"electrical_ac.utility.phaseA.lineNeutralVoltage": {
			"description": "RMS voltage measured between utility phase A and neutral.",
			"units": "V"
		},
		"electrical_ac.utility.phaseA.frequency": {
			"description": "Utility phase A frequency.",
			"units": "Hz"
		},
		"electrical_ac.utility.phaseA.reactivePower.reactivePower": {
			"description": "Utility phase A reactive power",
			"units": "W"
		},
		"electrical_ac.utility.phaseA.realPower.realPower": {
			"description": "Utility phase A real power.",
			"units": "W"
		},
		"electrical_ac.utility.phaseA.realPower.apparentPower": {
			"description": "Utility phase A apparent power.",
			"units": "W"
		},
		"electrical_ac.utility.phaseB.lineLineVoltage": {
			"description": "RMS voltage measured between utility phase B and phase C.",
			"units": "V"
		},
		"electrical_ac.utility.phaseB.lineNeutralVoltage": {
			"description": "RMS voltage measured between utility phase B and neutral.",
			"units": "V"
		},
		"electrical_ac.utility.phaseB.frequency": {
			"description": "Utility phase B frequency.",
			"units": "Hz"
		},
		"electrical_ac.utility.phaseB.reactivePower.reactivePower": {
			"description": "Utility phase B reactive power",
			"units": "W"
		},
		"electrical_ac.utility.phaseB.realPower.realPower": {
			"description": "Utility phase B real power.",
			"units": "W"
		},
		"electrical_ac.utility.phaseB.realPower.apparentPower": {
			"description": "Utility phase B apparent power.",
			"units": "W"
		},
		"electrical_ac.utility.phaseC.lineLineVoltage": {
			"description": "RMS voltage measured between utility phase C and phase A.",
			"units": "V"
		},
		"electrical_ac.utility.phaseC.lineNeutralVoltage": {
			"description": "RMS voltage measured between utility phase C and neutral.",
			"units": "V"
		},
		"electrical_ac.utility.phaseC.frequency": {
			"description": "Utility phase C frequency.",
			"units": "Hz"
		},
		"electrical_ac.utility.phaseC.reactivePower.reactivePower": {
			"description": "Utility phase C reactive power",
			"units": "W"
		},
		"electrical_ac.utility.phaseC.realPower.realPower": {
			"description": "Utility phase C real power.",
			"units": "W"
		},
		"electrical_ac.utility.phaseC.realPower.apparentPower": {
			"description": "Utility phase C apparent power.",
			"units": "W"
		},
		"electrical_ac.utility.average.lineLineVoltage": {
			"description": "Average RMS voltage measured between two hot legs of a 3-phase or split-phase utility connection.",
			"units": "V"
		},
		"electrical_ac.utility.average.lineNeutralVoltage": {
			"description": "Average RMS voltage measured between any hot leg and neutral in a 3-phase, split-phase, or single phase utility connection.",
			"units": "V"
		},
		"electrical_ac.utility.average.frequency": {
			"description": "Average frequency of the utility connection.",
			"units": "Hz"
		},
		"electrical_ac.utility.energy.totalExport": {
			"description": "Total watt hours exported by the utility",
			"units": "J"
		},
		"electrical_ac.utility.energy.totalImport": {
			"description": "Total watt hours imported by the utility",
			"units": "J"
		},
		"electrical_ac.utility.reactivePower.reactivePower": {
			"description": "In a normally operating system, the reactive power will be less than half the real power. In order to allow for fault conditions, it is desirable to have the same range for reactive power as for real power. Reactive power is a signed quantity, like real power.",
			"units": "W"
		},
		"electrical_ac.utility.realPower.realPower": {
			"description": "Total real power delivered by the utility",
			"units": "W"
		},
		"electrical_ac.utility.realPower.apparentPower": {
			"description": "Total apparent power delivered by the utility. This is an unsigned quantity, but is delivered signed in order to have an equivalent range to real power.",
			"units": "W"
		},
		"electrical_ac.generator.phaseA.lineLineVoltage": {
			"description": "RMS voltage measured between generator phase A and phase B.",
			"units": "V"
		},
		"electrical_ac.generator.phaseA.lineNeutralVoltage": {
			"description": "RMS voltage measured between generator phase A and neutral.",
			"units": "V"
		},
		"electrical_ac.generator.phaseA.frequency": {
			"description": "Generator phase A frequency.",
			"units": "Hz"
		},
		"electrical_ac.generator.phaseA.reactivePower.reactivePower": {
			"description": "Generator phase A reactive power",
			"units": "W"
		},
		"electrical_ac.generator.phaseA.realPower.realPower": {
			"description": "Generator phase A real power.",
			"units": "W"
		},
		"electrical_ac.generator.phaseA.realPower.apparentPower": {
			"description": "Generator phase A apparent power.",
			"units": "W"
		},
		"electrical_ac.generator.phaseB.lineLineVoltage": {
			"description": "RMS voltage measured between generator phase B and phase C.",
			"units": "V"
		},
		"electrical_ac.generator.phaseB.lineNeutralVoltage": {
			"description": "RMS voltage measured between generator phase B and neutral.",
			"units": "V"
		},
		"electrical_ac.generator.phaseB.frequency": {
			"description": "Generator phase B frequency.",
			"units": "Hz"
		},
		"electrical_ac.generator.phaseB.reactivePower.reactivePower": {
			"description": "Generator phase B reactive power",
			"units": "W"
		},
		"electrical_ac.generator.phaseB.realPower.realPower": {
			"description": "Generator phase B real power.",
			"units": "W"
		},
		"electrical_ac.generator.phaseB.realPower.apparentPower": {
			"description": "Generator phase B apparent power.",
			"units": "W"
		},
		"electrical_ac.generator.phaseC.lineLineVoltage": {
			"description": "RMS voltage measured between generator phase C and phase A.",
			"units": "V"
		},
		"electrical_ac.generator.phaseC.lineNeutralVoltage": {
			"description": "RMS voltage measured between generator phase C and neutral.",
			"units": "V"
		},
		"electrical_ac.generator.phaseC.frequency": {
			"description": "Generator phase C frequency.",
			"units": "Hz"
		},
		"electrical_ac.generator.phaseC.reactivePower.reactivePower": {
			"description": "Generator phase C reactive power",
			"units": "W"
		},
		"electrical_ac.generator.phaseC.realPower.realPower": {
			"description": "Generator phase C real power.",
			"units": "W"
		},
		"electrical_ac.generator.phaseC.realPower.apparentPower": {
			"description": "Generator phase C apparent power.",
			"units": "W"
		},
		"electrical_ac.generator.average.lineLineVoltage": {
			"description": "Average RMS voltage measured between two hot legs of a 3-phase or split-phase generator.",
			"units": "V"
		},
		"electrical_ac.generator.average.lineNeutralVoltage": {
			"description": "Average RMS voltage measured between any hot leg and neutral in a 3-phase, split-phase, or single phase generator.",
			"units": "V"
		},
		"electrical_ac.generator.average.frequency": {
			"description": "Average frequency of the generator output.",
			"units": "Hz"
		},
		"electrical_ac.generator.energy.totalExport": {
			"description": "Total energy exported by the generator",
			"units": "J"
		},
		"electrical_ac.generator.energy.totalImport": {
			"description": "Total energy imported by the generator",
			"units": "J"
		},
		"electrical_ac.generator.reactivePower.reactivePower": {
			"description": "Reactive power",
			"units": "W"
		},
		"electrical_ac.generator.realPower.realPower": {
			"description": "Total real power delivered by the generator. Real power must be signed since power may flow in both directions.",
			"units": "W"
		},
		"electrical_ac.generator.realPower.apparentPower": {
			"description": "Total apparent power delivered by the generator. This is an unsigned quantity, but is delivered signed in order to have an equivalent range to real power.",
			"units": "W"
		},
		"environment.airPressureChangeRateAlarm": {
			"description": "Change per hour which will cause an alarm",
			"units": "Pa"
		},
		"environment.airPressure": {
			"description": "Current air pressure",
			"units": "Pa"
		},
		"environment.airTemp": {
			"description": "Current air temperature",
			"units": "K"
		},
		"environment.depth.belowKeel": {
			"description": "Depth below keel",
			"units": "m"
		},
		"environment.depth.belowTransducer": {
			"description": "Depth below Transducer",
			"units": "m"
		},
		"environment.depth.belowSurface": {
			"description": "Depth from surface",
			"units": "m"
		},
		"environment.depth.transducerToKeel": {
			"description": "Depth from the transducer to the bottom of the keel",
			"units": "m"
		},
		"environment.depth.surfaceToTransducer": {
			"description": "Depth transducer is below the water",
			"units": "m"
		},
		"environment.humidity": {
			"description": "Current relative humidity",
			"units": "ratio"
		},
		"environment.salinity": {
			"description": "Water salinity",
			"units": "ratio"
		},
		"environment.current.drift": {
			"description": "The speed component of the water current vector",
			"units": "m/s"
		},
		"environment.current.setTrue": {
			"description": "The direction component of the water current vector referenced to true (geographic) north",
			"units": "rad"
		},
		"environment.current.setMagnetic": {
			"description": "The direction component of the water current vector referenced to magnetic north",
			"units": "rad"
		},
		"environment.tide.heightHigh": {
			"description": "Next high tide",
			"units": "m"
		},
		"environment.tide.heightNow": {
			"description": "The current tide height",
			"units": "m"
		},
		"environment.tide.heightLow": {
			"description": "The next low tide height",
			"units": "m"
		},
		"environment.waterTemp": {
			"description": "Current water temperature",
			"units": "K"
		},
		"environment.wind.angleApparent": {
			"description": "Apparent wind angle, negative to port",
			"units": "rad"
		},
		"environment.wind.angleTrueGround": {
			"description": "True wind angle based on speed over ground, negative to port",
			"units": "rad"
		},
		"environment.wind.angleTrueWater": {
			"description": "True wind angle based on speed through water, negative to port",
			"units": "rad"
		},
		"environment.wind.directionChangeAlarm": {
			"description": "The angle the wind needs to shift to raise an alarm",
			"units": "rad"
		},
		"environment.wind.directionTrue": {
			"description": "The wind direction relative to true north",
			"units": "rad"
		},
		"environment.wind.directionMagnetic": {
			"description": "The wind direction relative to magnetic north",
			"units": "rad"
		},
		"environment.wind.speedAlarm": {
			"description": "The speed above which a wind alarm will be raised",
			"units": "m/s"
		},
		"environment.wind.speedTrue": {
			"description": "Wind speed over water (as calculated from speedApparent and vessel's speed through water)",
			"units": "m/s"
		},
		"environment.wind.speedOverGround": {
			"description": "Wind speed over ground (as calculated from speedApparent and vessel's speed over ground)",
			"units": "m/s"
		},
		"environment.wind.speedApparent": {
			"description": "Apparent wind speed",
			"units": "m/s"
		},
		"performance.polarSpeed": {
			"description": "The current polar speed based on current polar, trueWindSpeed and truewindAngle.",
			"units": "m/s"
		},
		"performance.polarSpeedRatio": {
			"description": "The ratio of current speed through water to the polar speed.",
			"units": "ratio"
		},
		"performance.velocityMadeGood": {
			"description": "The current velocity made good derived from the speed through water and appearant wind angle. A positive value is heading to upwind, negative to downwind.",
			"units": "m/s"
		},
		"performance.velocityMadeGoodToWaypoint": {
			"description": "The current velocity made good to the next waypoint derived from the speedOverGround, courseOverGround.",
			"units": "m/s"
		},
		"performance.beatAngle": {
			"description": "The true wind beat angle for the best velocity made good based on current current polar and trueWindSpeed.",
			"units": "rad"
		},
		"performance.beatAngleVelocityMadeGood": {
			"description": "The velocity made good for the beat angle.",
			"units": "m/s"
		},
		"performance.beatAngleTargetSpeed": {
			"description": "The target speed for the beat angle.",
			"units": "m/s"
		},
		"performance.gybeAngle": {
			"description": "The true wind gybe angle for the best velocity made good downwind based on current polar and trueWindSpeed.",
			"units": "rad"
		},
		"performance.gybeAngleVelocityMadeGood": {
			"description": "The velocity made good for the gybe angle",
			"units": "m/s"
		},
		"performance.gybeAngleTargetSpeed": {
			"description": "The target speed for the gybe angle.",
			"units": "m/s"
		},
		"performance.leeway": {
			"description": "Current leeway",
			"units": "rad"
		},
		"performance.tackMagnetic": {
			"description": "Magnetic heading on opposite tack.",
			"units": "rad"
		},
		"performance.tackTrue": {
			"description": "True heading on opposite tack.",
			"units": "rad"
		},
		"propulsion.revolutions": {
			"description": "Engine revolutions",
			"units": "Hz"
		},
		"propulsion.temperature": {
			"description": "Engine temperature",
			"units": "K"
		},
		"propulsion.oilTemperature": {
			"description": "Oil temperature",
			"units": "K"
		},
		"propulsion.oilPressure": {
			"description": "Oil pressure",
			"units": "Pa"
		},
		"propulsion.waterTemperature": {
			"description": "Water temperature",
			"units": "K"
		},
		"propulsion.exhaustTemperature": {
			"description": "Exhaust temperature",
			"units": "K"
		},
		"propulsion.fuelRate": {
			"description": "Fuel consumption rate",
			"units": "m3/s"
		},
		"resources.routes.patternProperties.(^[2-7][0-9]{8,8}$|^[A-F0-9]{8,8}$).distance": {
			"description": "Total distance from start to end",
			"units": "m"
		},
		"resources.waypoints.patternProperties.(^[2-7][0-9]{8,8}$|^[A-F0-9]{8,8}$).position.longitude": {
			"description": "Longitude",
			"units": "deg"
		},
		"resources.waypoints.patternProperties.(^[2-7][0-9]{8,8}$|^[A-F0-9]{8,8}$).position.latitude": {
			"description": "Latitude",
			"units": "deg"
		},
		"resources.waypoints.patternProperties.(^[2-7][0-9]{8,8}$|^[A-F0-9]{8,8}$).position.altitude": {
			"description": "Altitude",
			"units": "m"
		},
		"steering.rudderAngle": {
			"description": "Current rudder angle, +ve is rudder to Starboard",
			"units": "rad"
		},
		"steering.rudderAngleTarget": {
			"description": "The angle the rudder should move to, +ve is rudder to Starboard",
			"units": "rad"
		},
		"steering.autopilot.targetHeadingNorth": {
			"description": "Target heading for autopilot, relative to true North",
			"units": "rad"
		},
		"steering.autopilot.targetHeadingMagnetic": {
			"description": "Target heading for autopilot, relative to magnetic North",
			"units": "rad"
		},
		"steering.autopilot.deadZone": {
			"description": "Dead zone to ignore for rudder corrections",
			"units": "rad"
		},
		"steering.autopilot.backlash": {
			"description": "Slack in the rudder drive mechanism",
			"units": "rad"
		},
		"steering.autopilot.maxDriveCurrent": {
			"description": "Maximum current to use to drive servo",
			"units": "A"
		},
		"steering.autopilot.maxDriveRate": {
			"description": "Maximum rudder rotation speed",
			"units": "rad/s"
		},
		"steering.autopilot.portLock": {
			"description": "Position of servo on port lock",
			"units": "rad"
		},
		"steering.autopilot.starboardLock": {
			"description": "Position of servo on starboard lock",
			"units": "rad"
		},
		"tanks.capacity": {
			"description": "Total capacity",
			"units": "m3"
		},
		"tanks.level": {
			"description": "Amount of fluid in tank",
			"units": "m3"
		}
	};

/***/ },
/* 57 */
/*!****************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/util/util.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ 58);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(/*! inherits */ 59);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 22)))

/***/ },
/* 58 */
/*!***********************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/util/support/isBufferBrowser.js ***!
  \***********************************************************************/
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 59 */
/*!***************************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/util/~/inherits/inherits_browser.js ***!
  \***************************************************************************/
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 60 */
/*!***********************************************!*\
  !*** ../signalk-js-client/~/mdns/lib/mdns.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var dns_sd  = __webpack_require__(/*! ./dns_sd */ 61)
	  , ad      = __webpack_require__(/*! ./advertisement */ 64)
	  , browser = __webpack_require__(/*! ./browser */ 76)
	  , st      = __webpack_require__(/*! ./service_type */ 74)
	  , nif     = __webpack_require__(/*! ./network_interface */ 69)
	  ;
	
	exports.dns_sd = dns_sd;
	
	exports.Advertisement       = ad.Advertisement;
	exports.createAdvertisement = ad.Advertisement.create;
	
	exports.Browser       = browser.Browser;
	exports.createBrowser = browser.Browser.create;
	exports.browseThemAll = browser.browseThemAll;
	exports.resolve       = browser.resolve;
	
	exports.MDNSService = __webpack_require__(/*! ./mdns_service */ 71).MDNSService;
	
	exports.ServiceType = st.ServiceType;
	exports.makeServiceType = st.makeServiceType;
	exports.tcp = st.protocolHelper('tcp');
	exports.udp = st.protocolHelper('udp');
	
	exports.loopbackInterface = nif.loopbackInterface;
	
	exports.dns_sd.exportConstants(exports);
	
	exports.rst = __webpack_require__(/*! ./resolver_sequence_tasks */ 77);
	
	exports.isAvahi = __webpack_require__(/*! ./avahi.js */ 75);
	


/***/ },
/* 61 */
/*!*************************************************!*\
  !*** ../signalk-js-client/~/mdns/lib/dns_sd.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(/*! path */ 62);
	var major, minor, patch;
	
	if (process.version.match(/^v(\d+)\.(\d+)\.(\d+).*$/)) {
	  major = parseInt(RegExp.$1);
	  minor = parseInt(RegExp.$2);
	  patch = parseInt(RegExp.$3);
	}
	
	var default_dir = major === 0 && minor <= 4 ? 'default' : 'Release'
	  , buildtype = process.env.BUILDTYPE || default_dir
	  ;
	
	//console.log(major, minor, patch, default_dir, buildtype);
	
	function product(type) { 
	  if (type === 'Coverage') {
	    return path.join('..', 'dns_sd_bindings') 
	  }
	  return path.join('..', 'build', type, 'dns_sd_bindings') 
	}
	
	try {
	  module.exports = __webpack_require__(/*! . */ 63)(product(buildtype));
	} catch (ex) {
	  if (! ex.code) {
	    if (/not find/.test(ex)) {
	      ex.code = 'MODULE_NOT_FOUND';
	    }
	  }
	  if (ex.code === 'MODULE_NOT_FOUND') {
	    module.exports = __webpack_require__(/*! . */ 63)(product(default_dir));
	    console.warn('dns_sd: failed to load requested ', buildtype, 'build. using', default_dir, 'instead.');
	  } else {
	    throw ex;
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 22)))

/***/ },
/* 62 */
/*!****************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/path-browserify/index.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};
	
	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;
	
	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();
	
	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }
	
	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }
	
	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)
	
	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');
	
	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};
	
	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';
	
	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');
	
	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }
	
	  return (isAbsolute ? '/' : '') + path;
	};
	
	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};
	
	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};
	
	
	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);
	
	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }
	
	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }
	
	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }
	
	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));
	
	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }
	
	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }
	
	  outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	  return outputParts.join('/');
	};
	
	exports.sep = '/';
	exports.delimiter = ':';
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}
	
	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 22)))

/***/ },
/* 63 */
/*!************************************************!*\
  !*** ../signalk-js-client/~/mdns/lib ^\.\/.*$ ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./advertisement": 64,
		"./advertisement.js": 64,
		"./avahi": 75,
		"./avahi.js": 75,
		"./browser": 76,
		"./browser.js": 76,
		"./dns_sd": 61,
		"./dns_sd.js": 61,
		"./io_watcher": 73,
		"./io_watcher.js": 73,
		"./mdns": 60,
		"./mdns.js": 60,
		"./mdns_service": 71,
		"./mdns_service.js": 71,
		"./network_interface": 69,
		"./network_interface.js": 69,
		"./resolver_sequence_tasks": 77,
		"./resolver_sequence_tasks.js": 77,
		"./service_type": 74,
		"./service_type.js": 74
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 63;


/***/ },
/* 64 */
/*!********************************************************!*\
  !*** ../signalk-js-client/~/mdns/lib/advertisement.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var dns_sd = __webpack_require__(/*! ./dns_sd */ 61)
	  , nif = __webpack_require__(/*! ./network_interface */ 69)
	  , util = __webpack_require__(/*! util */ 57)
	  ;
	
	var MDNSService = __webpack_require__(/*! ./mdns_service */ 71).MDNSService
	  , makeServiceType = __webpack_require__(/*! ./service_type */ 74).makeServiceType
	  ;
	
	function Advertisement(serviceType, port, options, callback) {
	  MDNSService.call(this);
	  var self = this;
	
	  if ( ! callback) {
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    }
	  }
	  options = options || {};
	
	  serviceType = makeServiceType(serviceType);
	
	  var flags     = options.flags          || 0
	    , ifaceIdx  = nif.interfaceIndex(options)
	    , name      = options.name           || null
	    , domain    = options.domain         || null
	    , host      = options.host           || null
	    , txtRecord = options.txtRecord      || null
	    , context   = options.context        || null
	    ;
	
	  if (txtRecord && typeof txtRecord === 'object' &&
	      ! (txtRecord instanceof dns_sd.TXTRecordRef || Buffer.isBuffer(txtRecord)))
	  {
	    txtRecord = objectToTXTRecord(txtRecord);
	  }
	
	  function on_service_registered(serviceRef, flags, errorCode, name,
	      serviceType, domain, context)
	  {
	    var error = dns_sd.buildException(errorCode);
	    if (callback) {
	      callback.call(self, error, {
	          name:    name
	        , type:    makeServiceType(serviceType)
	        , domain:  domain
	        , flags:   flags
	      }, context);
	    }
	    if (error) {
	      self.emit('error', error);
	    }
	  }
	
	  dns_sd.DNSServiceRegister(self.serviceRef, flags, ifaceIdx, name,
	      '' + serviceType, domain, host, port, txtRecord, on_service_registered,
	      context);
	}
	util.inherits(Advertisement, MDNSService)
	exports.Advertisement = Advertisement;
	
	Advertisement.create = function create(serviceType, port, options, callback) {
	  return new Advertisement(serviceType, port, options, callback);
	}
	
	function objectToTXTRecord(o) {
	  var record = new dns_sd.TXTRecordRef()
	    , value
	    ;
	  record.buffer = new Buffer(256);
	  dns_sd.TXTRecordCreate(record, record.buffer);
	  for (var p in o) {
	    ensure_legal_key(p);
	    if (o[p] === undefined || o[p] === null || Buffer.isBuffer(o[p])) {
	      value = o[p];
	    } else {
	      value = '' + o[p];
	    }
	    dns_sd.TXTRecordSetValue(record, p, value);
	  }
	  return record;
	}
	
	function ensure_legal_key(string) {
	  var i, c;
	  for (i = 0; i < string.length; ++i) {
	    c = string.charCodeAt(i);
	    if (c < 0x20 || c > 0x7e || c === 0x3d) {
	      throw new Error("key must be all printable ascii characters exluding '='");
	    }
	  }
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/buffer/index.js */ 65).Buffer))

/***/ },
/* 65 */
/*!*******************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/buffer/index.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	var base64 = __webpack_require__(/*! base64-js */ 66)
	var ieee754 = __webpack_require__(/*! ieee754 */ 67)
	var isArray = __webpack_require__(/*! is-array */ 68)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	Buffer.poolSize = 8192 // not used by this implementation
	
	var rootParent = {}
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
	 *     on objects.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	function typedArraySupport () {
	  function Bar () {}
	  try {
	    var arr = new Uint8Array(1)
	    arr.foo = function () { return 42 }
	    arr.constructor = Bar
	    return arr.foo() === 42 && // typed array instances can be augmented
	        arr.constructor === Bar && // constructor can be set
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	/**
	 * Class: Buffer
	 * =============
	 *
	 * The Buffer constructor returns instances of `Uint8Array` that are augmented
	 * with function properties for all the node `Buffer` API functions. We use
	 * `Uint8Array` so that square bracket notation works as expected -- it returns
	 * a single octet.
	 *
	 * By augmenting the instances, we can avoid modifying the `Uint8Array`
	 * prototype.
	 */
	function Buffer (arg) {
	  if (!(this instanceof Buffer)) {
	    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
	    if (arguments.length > 1) return new Buffer(arg, arguments[1])
	    return new Buffer(arg)
	  }
	
	  this.length = 0
	  this.parent = undefined
	
	  // Common case.
	  if (typeof arg === 'number') {
	    return fromNumber(this, arg)
	  }
	
	  // Slightly less common case.
	  if (typeof arg === 'string') {
	    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
	  }
	
	  // Unusual.
	  return fromObject(this, arg)
	}
	
	function fromNumber (that, length) {
	  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < length; i++) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'
	
	  // Assumption: byteLength() return value is always < kMaxLength.
	  var length = byteLength(string, encoding) | 0
	  that = allocate(that, length)
	
	  that.write(string, encoding)
	  return that
	}
	
	function fromObject (that, object) {
	  if (Buffer.isBuffer(object)) return fromBuffer(that, object)
	
	  if (isArray(object)) return fromArray(that, object)
	
	  if (object == null) {
	    throw new TypeError('must start with number, buffer, array or string')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined') {
	    if (object.buffer instanceof ArrayBuffer) {
	      return fromTypedArray(that, object)
	    }
	    if (object instanceof ArrayBuffer) {
	      return fromArrayBuffer(that, object)
	    }
	  }
	
	  if (object.length) return fromArrayLike(that, object)
	
	  return fromJsonObject(that, object)
	}
	
	function fromBuffer (that, buffer) {
	  var length = checked(buffer.length) | 0
	  that = allocate(that, length)
	  buffer.copy(that, 0, 0, length)
	  return that
	}
	
	function fromArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Duplicate of fromArray() to keep fromArray() monomorphic.
	function fromTypedArray (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  // Truncating the elements is probably not what people expect from typed
	  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
	  // of the old Buffer constructor.
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    array.byteLength
	    that = Buffer._augment(new Uint8Array(array))
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromTypedArray(that, new Uint8Array(array))
	  }
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = checked(array.length) | 0
	  that = allocate(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
	// Returns a zero-length buffer for inputs that don't conform to the spec.
	function fromJsonObject (that, object) {
	  var array
	  var length = 0
	
	  if (object.type === 'Buffer' && isArray(object.data)) {
	    array = object.data
	    length = checked(array.length) | 0
	  }
	  that = allocate(that, length)
	
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	}
	
	function allocate (that, length) {
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = Buffer._augment(new Uint8Array(length))
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that.length = length
	    that._isBuffer = true
	  }
	
	  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
	  if (fromPool) that.parent = rootParent
	
	  return that
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (subject, encoding) {
	  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)
	
	  var buf = new Buffer(subject, encoding)
	  delete buf.parent
	  return buf
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  var i = 0
	  var len = Math.min(x, y)
	  while (i < len) {
	    if (a[i] !== b[i]) break
	
	    ++i
	  }
	
	  if (i !== len) {
	    x = a[i]
	    y = b[i]
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'binary':
	    case 'base64':
	    case 'raw':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')
	
	  if (list.length === 0) {
	    return new Buffer(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; i++) {
	      length += list[i].length
	    }
	  }
	
	  var buf = new Buffer(length)
	  var pos = 0
	  for (i = 0; i < list.length; i++) {
	    var item = list[i]
	    item.copy(buf, pos)
	    pos += item.length
	  }
	  return buf
	}
	
	function byteLength (string, encoding) {
	  if (typeof string !== 'string') string = '' + string
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'binary':
	      // Deprecated
	      case 'raw':
	      case 'raws':
	        return len
	      case 'utf8':
	      case 'utf-8':
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	// pre-set for values that may exist in the future
	Buffer.prototype.length = undefined
	Buffer.prototype.parent = undefined
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  start = start | 0
	  end = end === undefined || end === Infinity ? this.length : end | 0
	
	  if (!encoding) encoding = 'utf8'
	  if (start < 0) start = 0
	  if (end > this.length) end = this.length
	  if (end <= start) return ''
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'binary':
	        return binarySlice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return 0
	  return Buffer.compare(this, b)
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
	  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
	  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
	  byteOffset >>= 0
	
	  if (this.length === 0) return -1
	  if (byteOffset >= this.length) return -1
	
	  // Negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)
	
	  if (typeof val === 'string') {
	    if (val.length === 0) return -1 // special case: looking for empty string always fails
	    return String.prototype.indexOf.call(this, val, byteOffset)
	  }
	  if (Buffer.isBuffer(val)) {
	    return arrayIndexOf(this, val, byteOffset)
	  }
	  if (typeof val === 'number') {
	    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
	      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
	    }
	    return arrayIndexOf(this, [ val ], byteOffset)
	  }
	
	  function arrayIndexOf (arr, val, byteOffset) {
	    var foundIndex = -1
	    for (var i = 0; byteOffset + i < arr.length; i++) {
	      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
	      } else {
	        foundIndex = -1
	      }
	    }
	    return -1
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	// `get` is deprecated
	Buffer.prototype.get = function get (offset) {
	  console.log('.get() is deprecated. Access using array indexes instead.')
	  return this.readUInt8(offset)
	}
	
	// `set` is deprecated
	Buffer.prototype.set = function set (v, offset) {
	  console.log('.set() is deprecated. Access using array indexes instead.')
	  return this.writeUInt8(v, offset)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new Error('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; i++) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) throw new Error('Invalid hex string')
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function binaryWrite (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    var swap = encoding
	    encoding = offset
	    offset = length | 0
	    length = swap
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'binary':
	        return binaryWrite(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function binarySlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; i++) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; i++) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = Buffer._augment(this.subarray(start, end))
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; i++) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  if (newBuf.length) newBuf.parent = this.parent || this
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = value < 0 ? 1 : 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (value > max || value < min) throw new RangeError('value is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('index out of range')
	  if (offset < 0) throw new RangeError('index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; i--) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; i++) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    target._set(this.subarray(start, start + len), targetStart)
	  }
	
	  return len
	}
	
	// fill(value, start=0, end=buffer.length)
	Buffer.prototype.fill = function fill (value, start, end) {
	  if (!value) value = 0
	  if (!start) start = 0
	  if (!end) end = this.length
	
	  if (end < start) throw new RangeError('end < start')
	
	  // Fill 0 bytes; we're done
	  if (end === start) return
	  if (this.length === 0) return
	
	  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
	  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')
	
	  var i
	  if (typeof value === 'number') {
	    for (i = start; i < end; i++) {
	      this[i] = value
	    }
	  } else {
	    var bytes = utf8ToBytes(value.toString())
	    var len = bytes.length
	    for (i = start; i < end; i++) {
	      this[i] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	/**
	 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
	 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
	 */
	Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
	  if (typeof Uint8Array !== 'undefined') {
	    if (Buffer.TYPED_ARRAY_SUPPORT) {
	      return (new Buffer(this)).buffer
	    } else {
	      var buf = new Uint8Array(this.length)
	      for (var i = 0, len = buf.length; i < len; i += 1) {
	        buf[i] = this[i]
	      }
	      return buf.buffer
	    }
	  } else {
	    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
	  }
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var BP = Buffer.prototype
	
	/**
	 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
	 */
	Buffer._augment = function _augment (arr) {
	  arr.constructor = Buffer
	  arr._isBuffer = true
	
	  // save reference to original Uint8Array set method before overwriting
	  arr._set = arr.set
	
	  // deprecated
	  arr.get = BP.get
	  arr.set = BP.set
	
	  arr.write = BP.write
	  arr.toString = BP.toString
	  arr.toLocaleString = BP.toString
	  arr.toJSON = BP.toJSON
	  arr.equals = BP.equals
	  arr.compare = BP.compare
	  arr.indexOf = BP.indexOf
	  arr.copy = BP.copy
	  arr.slice = BP.slice
	  arr.readUIntLE = BP.readUIntLE
	  arr.readUIntBE = BP.readUIntBE
	  arr.readUInt8 = BP.readUInt8
	  arr.readUInt16LE = BP.readUInt16LE
	  arr.readUInt16BE = BP.readUInt16BE
	  arr.readUInt32LE = BP.readUInt32LE
	  arr.readUInt32BE = BP.readUInt32BE
	  arr.readIntLE = BP.readIntLE
	  arr.readIntBE = BP.readIntBE
	  arr.readInt8 = BP.readInt8
	  arr.readInt16LE = BP.readInt16LE
	  arr.readInt16BE = BP.readInt16BE
	  arr.readInt32LE = BP.readInt32LE
	  arr.readInt32BE = BP.readInt32BE
	  arr.readFloatLE = BP.readFloatLE
	  arr.readFloatBE = BP.readFloatBE
	  arr.readDoubleLE = BP.readDoubleLE
	  arr.readDoubleBE = BP.readDoubleBE
	  arr.writeUInt8 = BP.writeUInt8
	  arr.writeUIntLE = BP.writeUIntLE
	  arr.writeUIntBE = BP.writeUIntBE
	  arr.writeUInt16LE = BP.writeUInt16LE
	  arr.writeUInt16BE = BP.writeUInt16BE
	  arr.writeUInt32LE = BP.writeUInt32LE
	  arr.writeUInt32BE = BP.writeUInt32BE
	  arr.writeIntLE = BP.writeIntLE
	  arr.writeIntBE = BP.writeIntBE
	  arr.writeInt8 = BP.writeInt8
	  arr.writeInt16LE = BP.writeInt16LE
	  arr.writeInt16BE = BP.writeInt16BE
	  arr.writeInt32LE = BP.writeInt32LE
	  arr.writeInt32BE = BP.writeInt32BE
	  arr.writeFloatLE = BP.writeFloatLE
	  arr.writeFloatBE = BP.writeFloatBE
	  arr.writeDoubleLE = BP.writeDoubleLE
	  arr.writeDoubleBE = BP.writeDoubleBE
	  arr.fill = BP.fill
	  arr.inspect = BP.inspect
	  arr.toArrayBuffer = BP.toArrayBuffer
	
	  return arr
	}
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; i++) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; i++) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; i++) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/buffer/index.js */ 65).Buffer, (function() { return this; }())))

/***/ },
/* 66 */
/*!*********************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/buffer/~/base64-js/lib/b64.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	
	;(function (exports) {
		'use strict';
	
	  var Arr = (typeof Uint8Array !== 'undefined')
	    ? Uint8Array
	    : Array
	
		var PLUS   = '+'.charCodeAt(0)
		var SLASH  = '/'.charCodeAt(0)
		var NUMBER = '0'.charCodeAt(0)
		var LOWER  = 'a'.charCodeAt(0)
		var UPPER  = 'A'.charCodeAt(0)
		var PLUS_URL_SAFE = '-'.charCodeAt(0)
		var SLASH_URL_SAFE = '_'.charCodeAt(0)
	
		function decode (elt) {
			var code = elt.charCodeAt(0)
			if (code === PLUS ||
			    code === PLUS_URL_SAFE)
				return 62 // '+'
			if (code === SLASH ||
			    code === SLASH_URL_SAFE)
				return 63 // '/'
			if (code < NUMBER)
				return -1 //no match
			if (code < NUMBER + 10)
				return code - NUMBER + 26 + 26
			if (code < UPPER + 26)
				return code - UPPER
			if (code < LOWER + 26)
				return code - LOWER + 26
		}
	
		function b64ToByteArray (b64) {
			var i, j, l, tmp, placeHolders, arr
	
			if (b64.length % 4 > 0) {
				throw new Error('Invalid string. Length must be a multiple of 4')
			}
	
			// the number of equal signs (place holders)
			// if there are two placeholders, than the two characters before it
			// represent one byte
			// if there is only one, then the three characters before it represent 2 bytes
			// this is just a cheap hack to not do indexOf twice
			var len = b64.length
			placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0
	
			// base64 is 4/3 + up to two characters of the original data
			arr = new Arr(b64.length * 3 / 4 - placeHolders)
	
			// if there are placeholders, only get up to the last complete 4 chars
			l = placeHolders > 0 ? b64.length - 4 : b64.length
	
			var L = 0
	
			function push (v) {
				arr[L++] = v
			}
	
			for (i = 0, j = 0; i < l; i += 4, j += 3) {
				tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
				push((tmp & 0xFF0000) >> 16)
				push((tmp & 0xFF00) >> 8)
				push(tmp & 0xFF)
			}
	
			if (placeHolders === 2) {
				tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
				push(tmp & 0xFF)
			} else if (placeHolders === 1) {
				tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
				push((tmp >> 8) & 0xFF)
				push(tmp & 0xFF)
			}
	
			return arr
		}
	
		function uint8ToBase64 (uint8) {
			var i,
				extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
				output = "",
				temp, length
	
			function encode (num) {
				return lookup.charAt(num)
			}
	
			function tripletToBase64 (num) {
				return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
			}
	
			// go through the array every three bytes, we'll deal with trailing stuff later
			for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
				temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
				output += tripletToBase64(temp)
			}
	
			// pad the end with zeros, but make sure to not forget the extra bytes
			switch (extraBytes) {
				case 1:
					temp = uint8[uint8.length - 1]
					output += encode(temp >> 2)
					output += encode((temp << 4) & 0x3F)
					output += '=='
					break
				case 2:
					temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
					output += encode(temp >> 10)
					output += encode((temp >> 4) & 0x3F)
					output += encode((temp << 2) & 0x3F)
					output += '='
					break
			}
	
			return output
		}
	
		exports.toByteArray = b64ToByteArray
		exports.fromByteArray = uint8ToBase64
	}( false ? (this.base64js = {}) : exports))


/***/ },
/* 67 */
/*!*****************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/buffer/~/ieee754/index.js ***!
  \*****************************************************************/
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 68 */
/*!******************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/buffer/~/is-array/index.js ***!
  \******************************************************************/
/***/ function(module, exports) {

	
	/**
	 * isArray
	 */
	
	var isArray = Array.isArray;
	
	/**
	 * toString
	 */
	
	var str = Object.prototype.toString;
	
	/**
	 * Whether or not the given `val`
	 * is an array.
	 *
	 * example:
	 *
	 *        isArray([]);
	 *        // > true
	 *        isArray(arguments);
	 *        // > false
	 *        isArray('');
	 *        // > false
	 *
	 * @param {mixed} val
	 * @return {bool}
	 */
	
	module.exports = isArray || function (val) {
	  return !! val && '[object Array]' == str.call(val);
	};


/***/ },
/* 69 */
/*!************************************************************!*\
  !*** ../signalk-js-client/~/mdns/lib/network_interface.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var net = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"net\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , os = __webpack_require__(/*! os */ 70)
	  , dns_sd = __webpack_require__(/*! ./dns_sd */ 61)
	  , interfaceIndexDeprecatedWarningPrinted = false
	  ;
	
	var have_if_nametoindex = typeof dns_sd.if_nametoindex !== 'undefined';
	
	exports.interfaceIndex = function interfaceIndex(options) {
	  var networkInterface
	    , index = 0;
	  if (typeof options.interfaceIndex !== 'undefined') {
	    if( ! interfaceIndexDeprecatedWarningPrinted) {
	      console.warn("WARNING: 'interfaceIndex' is deprecated and will be " +
	          "removed. Please use 'networkInterface' instead and see the " +
	          "documentation on why it's cool.");
	      interfaceIndexDeprecatedWarningPrinted = true;
	    }
	    networkInterface = options.interfaceIndex;
	  } else {
	    networkInterface = options.networkInterface;
	  }
	  if (typeof networkInterface !== 'undefined') {
	    if (net.isIP(networkInterface)) {
	      if ( ! have_if_nametoindex) {
	        throw new Error('IP address to interface index conversion is not ' +
	            'supported on this platform');
	      }
	      index = dns_sd.if_nametoindex(addressToName(networkInterface));
	      //console.log('got IP', networkInterface, '->', index);
	    } else if (isString(networkInterface)) {
	      if ( ! have_if_nametoindex) {
	        throw new Error('interface name to index conversion is not supported ' +
	            'on this platform');
	      }
	      index = dns_sd.if_nametoindex(networkInterface);
	      //console.log('got if name', networkInterface, '->', index);
	    } else {
	      //console.log('got index', networkInterface);
	      index = networkInterface;
	    }
	  }
	  //console.log('interface index:', index);
	  return index;
	}
	
	exports.loopbackInterface = function loopbackInterface() {
	  if (typeof dns_sd.kDNSServiceInterfaceIndexLocalOnly !== 'undefined') {
	    return dns_sd.kDNSServiceInterfaceIndexLocalOnly;
	  } else {
	    return loopbackName();
	  }
	}
	
	var loopbackName = exports.loopbackName = function loopbackName() {
	  var interfaces = os.networkInterfaces();
	  for (var name in interfaces) {
	    for (var i = 0; i < interfaces[name].length; ++i) {
	      if (interfaces[name][i].address === '127.0.0.1') {
	        return name;
	      }
	    }
	  }
	  throw new Error('failed to find loopback interface');
	}
	
	function addressToName(address) {
	  if (typeof os.networkInterfaces === 'undefined') {
	    throw new Error('IP address to interface index conversion is not ' +
	        'supported with this version of node');
	  }
	  var addresses = os.networkInterfaces();
	  for (var name in addresses) {
	    for (var i = 0; i < addresses[name].length; ++i) {
	      if (addresses[name][i].address === address) {
	        return name;
	      }
	    }
	  }
	  throw new Error('interface with address ' + address + ' does not exist');
	}
	
	function isString(s) {
	  return toString.call(s) == '[object String]';
	}
	


/***/ },
/* 70 */
/*!****************************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/os-browserify/browser.js ***!
  \****************************************************************/
/***/ function(module, exports) {

	exports.endianness = function () { return 'LE' };
	
	exports.hostname = function () {
	    if (typeof location !== 'undefined') {
	        return location.hostname
	    }
	    else return '';
	};
	
	exports.loadavg = function () { return [] };
	
	exports.uptime = function () { return 0 };
	
	exports.freemem = function () {
	    return Number.MAX_VALUE;
	};
	
	exports.totalmem = function () {
	    return Number.MAX_VALUE;
	};
	
	exports.cpus = function () { return [] };
	
	exports.type = function () { return 'Browser' };
	
	exports.release = function () {
	    if (typeof navigator !== 'undefined') {
	        return navigator.appVersion;
	    }
	    return '';
	};
	
	exports.networkInterfaces
	= exports.getNetworkInterfaces
	= function () { return {} };
	
	exports.arch = function () { return 'javascript' };
	
	exports.platform = function () { return 'browser' };
	
	exports.tmpdir = exports.tmpDir = function () {
	    return '/tmp';
	};
	
	exports.EOL = '\n';


/***/ },
/* 71 */
/*!*******************************************************!*\
  !*** ../signalk-js-client/~/mdns/lib/mdns_service.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var dns_sd    = __webpack_require__(/*! ./dns_sd */ 61)
	  , util      = __webpack_require__(/*! util */ 57)
	  , events    = __webpack_require__(/*! events */ 72)
	  , IOWatcher = __webpack_require__(/*! ./io_watcher */ 73).IOWatcher;
	  ;
	
	function MDNSService() {
	  events.EventEmitter.call(this);
	  var self = this;
	
	  self._watcherStarted = false;
	  self.serviceRef = new dns_sd.DNSServiceRef();
	  self.watcher = new IOWatcher();
	  self.watcher.host = self; // TODO: Find out what this is for ...
	  self.watcher.callback = function() {
	    if (self._watcherStarted) {
	      try {
	        dns_sd.DNSServiceProcessResult.call(self, self.serviceRef);
	      } catch (error) {
	        self.emit("error", error);
	      }
	    }
	  };
	}
	util.inherits(MDNSService, events.EventEmitter);
	exports.MDNSService = MDNSService;
	
	MDNSService.prototype.start = function start() {
	  if (this._watcherStarted) {
	    throw new Error("mdns service already started");
	  }
	  this.watcher.set(this.serviceRef.fd, true, false);
	  this.watcher.start();
	  this._watcherStarted = true;
	}
	
	MDNSService.prototype.stop = function stop() {
	  if (this._watcherStarted) {
	    this.watcher.stop();
	    dns_sd.DNSServiceRefDeallocate(this.serviceRef);
	    this.serviceRef = null;
	    this._watcherStarted = false;
	  }
	}


/***/ },
/* 72 */
/*!********************************************************!*\
  !*** (webpack)/~/node-libs-browser/~/events/events.js ***!
  \********************************************************/
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      }
	      throw TypeError('Uncaught, unspecified "error" event.');
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 73 */
/*!*****************************************************!*\
  !*** ../signalk-js-client/~/mdns/lib/io_watcher.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var dns_sd = __webpack_require__(/*! ./dns_sd */ 61);
	exports.IOWatcher = typeof dns_sd.SocketWatcher !== 'undefined' ?
	    dns_sd.SocketWatcher : process.binding('io_watcher').IOWatcher;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 22)))

/***/ },
/* 74 */
/*!*******************************************************!*\
  !*** ../signalk-js-client/~/mdns/lib/service_type.js ***!
  \*******************************************************/
/***/ function(module, exports) {

	var ServiceType = exports.ServiceType = function ServiceType(/* ... */) {
	  this.name = '';
	  this.protocol = '';
	  this.subtypes = [];
	
	  var args;
	  if (arguments.length === 1) {
	    args = Array.isArray(arguments[0]) ? arguments[0] : [arguments[0]];
	  } else if (arguments.length > 1) {
	    args = Array.prototype.slice.call(arguments);
	  }
	  if (args) {
	    if (args.length === 1) {
	      if (typeof args[0] === 'string') {
	        this.fromString(args[0]);
	      } else if (Array.isArray(args[0])) {
	        this.fromArray(args[0]);
	      } else if (typeof args[0] === 'object') {
	        this.fromJSON(args[0]);
	      } else {
	        throw new Error('argument must be a string, array or object');
	      }
	    } else if (args.length >= 2) {
	      this.fromArray(args);
	    } else { // zero arguments
	      // uninitialized ServiceType ... fine with me
	    }
	  }
	}
	
	ServiceType.wildcard = '_services._dns-sd._udp.';
	ServiceType.prototype.isWildcard = function isWildcard() {
	  return this.toString() === ServiceType.wildcard;
	}
	
	ServiceType.prototype.toString = function() {
	  var type_string = _u(this.name) + "." + _u(this.protocol);
	  if (this.fullyQualified) {
	    type_string += '.'
	  }
	  if (this.subtypes.length > 0) {
	    var subtypes = this.subtypes.map(function(t) { return _u(t) });
	    subtypes.unshift(type_string);
	    type_string = subtypes.join(',');
	  }
	  return type_string;
	}
	
	ServiceType.prototype.fromString = function fromString(string) {
	  var is_wildcard = string === ServiceType.wildcard
	    , subtypes = string.split(',')
	    , primary_string = subtypes.shift()
	    , service_tokens = primary_string.split('.')
	    , service_type = service_tokens.shift()
	    , protocol
	    ;
	  if (is_wildcard) {
	    service_type += '.' + service_tokens.shift();
	  }
	  protocol = service_tokens.shift()
	
	  checkProtocolU(protocol);
	  if ( ! is_wildcard) {
	    checkFormat(service_type);
	  }
	  subtypes.forEach(function(t) { checkFormat(t) });
	  if (service_tokens.length === 1 && service_tokens[0] === '') {
	    // trailing dot
	    this.fullyQualified = true
	  } else if (service_tokens.length > 0) {
	    throw new Error("trailing tokens '" + service_tokens.join('.') + "' in " +
	        "service type string '" + string + "'");
	  }
	
	  this.name = service_type.substr(1);
	  this.protocol = protocol.substr(1);
	  this.subtypes = subtypes.map(function(t) { return t.substr(1) });
	}
	
	ServiceType.prototype.toArray = function toArray() {
	  return [this.name, this.protocol].concat(this.subtypes);
	}
	
	ServiceType.prototype.fromArray = function fromArray(array) {
	  var service_type = _uu(array.shift())
	    , protocol = _uu(array.shift())
	    , subtypes = array.map(function(t) { return _uu(t) })
	    ;
	  checkLengthAndCharset(service_type);
	  checkProtocol(protocol);
	  subtypes.forEach(function(t) { checkLengthAndCharset(t) });
	
	  this.name = service_type;
	  this.protocol = protocol;
	  this.subtypes = subtypes
	}
	
	ServiceType.prototype.fromJSON = function fromJSON(obj) {
	  if ( ! ('name' in obj)) {
	    throw new Error('required property name is missing');
	  }
	  if ( ! ('protocol' in obj)) {
	    throw new Error('required property protocol is missing');
	  }
	
	  var service_type   = _uu(obj.name)
	    , protocol       = _uu(obj.protocol)
	    , subtypes       = 'subtypes' in obj ?
	                        obj.subtypes.map(function(t) { return _uu(t) }) : []
	    ;
	
	  checkLengthAndCharset(service_type);
	  checkProtocol(protocol);
	  subtypes.forEach(function(t) { checkLengthAndCharset(t) });
	
	  this.name = service_type;
	  this.protocol = protocol;
	  this.subtypes = subtypes;
	  if ('fullyQualified' in obj) {
	    this.fullyQualified = obj.fullyQualified;
	  }
	}
	
	ServiceType.prototype.matches = function matches(other) {
	  return this.name === other.name && this.protocol === other.protocol;
	  // XXX handle subtypes
	}
	
	exports.makeServiceType = function makeServiceType() {
	  if (arguments.length === 1 && arguments[0] instanceof ServiceType) {
	    return arguments[0];
	  }
	  return new ServiceType(Array.prototype.slice.call(arguments));
	}
	
	exports.protocolHelper = function protocolHelper(protocol) {
	  return function() {
	    var args = Array.prototype.slice.call(arguments);
	    if (isProtocol(args[1])) {
	      throw new Error("duplicate protocol '" + args[1] + "' in arguments");
	    }
	    args.splice(1,0, protocol);
	    return exports.makeServiceType.apply(this, args);
	  }
	}
	
	function isProtocol(str) {
	  return str === 'tcp' || str === '_tcp' || str === 'udp' || str === '_udp';
	}
	
	function _u(str) { return "_" + str; }
	function _uu(str) { return str[0] === '_' ? str.substr(1) : str; }
	
	var charset_regex = /[^-a-zA-Z0-9]/;
	function checkLengthAndCharset(str) {
	  if (str.length === 0) {
	    throw new Error('type ' + str + ' must not be empty');
	  }
	  if (str.length > 15) {
	    throw new Error('type ' + str + ' has more than 15 characters');
	  }
	  if (str.match(charset_regex)) {
	    throw new Error('type ' + str + ' may only contain alphanumeric ' +
	        'characters and hyphens');
	  }
	}
	
	var format_regex = /_[-a-zA-Z0-9]+/;
	function checkFormat(str) {
	  if (str.length === 0) {
	    throw new Error('type string must not be empty');
	  }
	  if (str.length > 16) { // 16 is correct because we have a leading underscore
	    throw new Error('type ' + _uu(str) + ' has more than 15 characters');
	  }
	  if ( ! str.match(format_regex)) {
	    throw new Error('type ' + str + ' must start with an underscore ' +
	        'followed by alphanumeric characters and hyphens only');
	  }
	}
	
	function checkProtocolU(str) {
	  if ( ! (str === '_tcp' || str === '_udp')) {
	    throw new Error("protocol must be either '_tcp' or '_udp' but is '" +
	        str + "'");
	  }
	}
	
	function checkProtocol(str) {
	  if ( ! (str === 'tcp' || str === 'udp')) {
	    throw new Error("protocol must be either '_tcp' or '_udp' but is '" +
	        str + "'");
	  }
	}
	


/***/ },
/* 75 */
/*!************************************************!*\
  !*** ../signalk-js-client/~/mdns/lib/avahi.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var dns_sd = __webpack_require__(/*! ./dns_sd */ 61);
	
	function supportsInterfaceIndexLocalOnly() {
	  try {
	    var sr = new dns_sd.DNSServiceRef()
	      , flags  = 0
	      , iface  = dns_sd.kDNSServiceInterfaceIndexLocalOnly
	      , name   = null
	      , type   = '_http._tcp'
	      , domain = null
	      , host   = null
	      , port   = 4321
	      , txtRec = null
	      , cb     = null
	      , ctx    = null
	      ;
	    dns_sd.DNSServiceRegister( sr, flags, iface, name, type, domain,
	          host, port, txtRec, cb, ctx);
	  } catch (ex) {
	    if (ex.errorCode === dns_sd.kDNSServiceErr_Unsupported) {
	      if (sr && sr.initialized) {
	        dns_sd.DNSServiceRefDeallocate(sr);
	      }
	      return false;
	    }
	    console.warn('Unexpected result while probing for avahi:', ex);
	  }
	  dns_sd.DNSServiceRefDeallocate(sr);
	  return true;
	}
	
	module.exports = ! supportsInterfaceIndexLocalOnly();


/***/ },
/* 76 */
/*!**************************************************!*\
  !*** ../signalk-js-client/~/mdns/lib/browser.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var dns_sd = __webpack_require__(/*! ./dns_sd */ 61)
	  , nif = __webpack_require__(/*! ./network_interface */ 69)
	  , util = __webpack_require__(/*! util */ 57)
	  , rst = __webpack_require__(/*! ./resolver_sequence_tasks */ 77)
	  , st = __webpack_require__(/*! ./service_type */ 74)
	  , MDNSService = __webpack_require__(/*! ./mdns_service */ 71).MDNSService
	  ;
	
	var Browser = exports.Browser = function Browser(serviceType, options) {
	  MDNSService.call(this);
	  var self = this;
	
	  options = options || {};
	  var flags = options.flags             || 0
	    , ifaceIdx  = nif.interfaceIndex(options)
	    , domain = options.domain           || null
	    , context = options.context         || null
	    , requested_type = st.makeServiceType( serviceType );
	    ;
	
	  var interfaceNames = [];
	
	  function on_service_changed(sdRef, flags, ifaceIdx, errorCode, serviceName,
	      serviceType, replyDomain, context)
	  {
	    function on_resolver_done(error, service) {
	      if (error) {
	        self.emit('error', error, service);
	      } else {
	        self.emit('serviceChanged', service, context);
	        self.emit('serviceUp', service, context);
	      }
	    }
	    if (errorCode == dns_sd.kDNSServiceErr_NoError) {
	      if (requested_type.isWildcard()) {
	        serviceType = serviceName + '.' + serviceType.split('.').shift();
	        serviceName = null;
	      }
	
	      var type;
	
	      try {
	        type = st.makeServiceType(serviceType);
	      } catch(e) {
	        self.emit('error', e);
	        return;
	      }
	
	      var service = {
	          interfaceIndex: ifaceIdx
	        , type: type
	        , replyDomain: replyDomain
	        , flags: flags
	      };
	      if (serviceName) service.name    = serviceName;
	
	      if (dns_sd.kDNSServiceInterfaceIndexLocalOnly === ifaceIdx) {
	        service.networkInterface = nif.loopbackName();
	      } else if (typeof dns_sd.if_indextoname !== 'undefined' && ifaceIdx > 0) {
	        try {
	          service.networkInterface = dns_sd.if_indextoname(ifaceIdx);
	
	          interfaceNames[ifaceIdx] = service.networkInterface;
	        } catch(e) {
	          if(typeof interfaceNames[ifaceIdx] !== "undefined") {
	            service.networkInterface = interfaceNames[ifaceIdx];
	          } else {
	            self.emit('error', e);
	          }
	        }
	      }
	
	      if (flags & dns_sd.kDNSServiceFlagsAdd) {
	        resolve(service,
	            options.resolverSequence || Browser.defaultResolverSequence,
	            on_resolver_done);
	      } else {
	        self.emit('serviceChanged', service, context);
	        self.emit('serviceDown', service, context);
	      }
	    } else {
	      self.emit('error', dns_sd.buildException(errorCode));
	    }
	  }
	
	  dns_sd.DNSServiceBrowse(self.serviceRef, flags, ifaceIdx, '' + requested_type,
	      domain, on_service_changed, context);
	}
	util.inherits(Browser, MDNSService);
	
	var resolve = exports.resolve = function resolve(service, sequence, callback) {
	  var step = 0;
	  if ( ! callback) {
	    callback = sequence;
	    sequence = Browser.defaultResolverSequence;
	  }
	
	  function next(error) {
	    if (error) {
	      callback(error, service);
	      return;
	    }
	    if (sequence.length === step) {
	      callback(undefined, service);
	      return;
	    }
	    sequence[step++](service, next);
	  }
	
	  next();
	}
	
	Browser.create = function create(serviceType, options) {
	  return new Browser(serviceType, options);
	}
	
	Browser.defaultResolverSequence = [
	  rst.DNSServiceResolve()
	, 'DNSServiceGetAddrInfo' in dns_sd ? rst.DNSServiceGetAddrInfo() : rst.getaddrinfo()
	, rst.makeAddressesUnique()
	];
	
	exports.browseThemAll = function browseThemAll(options) {
	  options = options || {}
	  options.resolverSequence = options.resolverSequence || [];
	  return Browser.create(st.ServiceType.wildcard, options);
	}
	


/***/ },
/* 77 */
/*!******************************************************************!*\
  !*** ../signalk-js-client/~/mdns/lib/resolver_sequence_tasks.js ***!
  \******************************************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {var dns_sd = __webpack_require__(/*! ./dns_sd */ 61)
	  , util = __webpack_require__(/*! util */ 57)
	  , MDNSService = __webpack_require__(/*! ./mdns_service */ 71).MDNSService
	  ;
	
	exports.DNSServiceResolve = function DNSServiceResolve(options) {
	  options = options || {};
	  options.flags = options.flags || 0;
	  options.unwrapTxtRecord =
	    'unwrapTxtRecord' in options ? options.unwrapTxtRecord : true;
	  return function DNSServiceResolve(service, next) {
	    try {
	      var resolver = new MDNSService();
	
	      function on_resolver_done(sdRef, flags, iface, errorCode, fullname,
	          hosttarget, port, txtRecord, context)
	      {
	        try {
	          var error = dns_sd.buildException(errorCode);
	          if ( ! error && service.interfaceIndex === iface) {
	            if (fullname)       service.fullname = fullname;
	            if (hosttarget)     service.host = hosttarget;
	            if (port)           service.port = port;
	            // all services have a TXT record. ignore the empty ones.
	            if (txtRecord.length > 1) {
	              service.rawTxtRecord = txtRecord;
	              if (options.unwrapTxtRecord) {
	                service.txtRecord = dns_sd.txtRecordBufferToObject(txtRecord)
	              }
	            }
	          }
	          resolver.stop();
	          next(error);
	        } catch (ex) {
	          resolver.stop();
	          next(ex);
	        }
	      }
	
	      dns_sd.DNSServiceResolve(resolver.serviceRef, options.flags,
	          service.interfaceIndex, service.name, '' + service.type,
	          service.replyDomain, on_resolver_done, null);
	      resolver.start();
	    } catch (ex) { 
	      resolver.stop();
	      next(ex);
	    }
	  };
	}
	
	exports.DNSServiceGetAddrInfo = function DNSServiceGetAddrInfo(options) {
	  options = options || {};
	  var family_flags = 0;
	  if ('families' in options) {
	    if (options.families.indexOf(4) !== -1) {
	      family_flags |= dns_sd.kDNSServiceProtocol_IPv4;
	    }
	    if (options.families.indexOf(6) !== -1) {
	      family_flags |= dns_sd.kDNSServiceProtocol_IPv6;
	    }
	  }
	  return function DNSServiceGetAddrInfo(service, next) {
	    try {
	      var adr_getter = new MDNSService()
	        , addresses = []
	        ;
	
	      function on_get_addr_info_done(sdRef, flags, iface, errorCode, hostname,
	          address, context)
	      {
	        try {
	          var error = dns_sd.buildException(errorCode);
	          if (error) {
	            adr_getter.stop()
	            next(error);
	          } else {
	            if (iface === service.interfaceIndex) {
	              addresses.push(address);
	            }
	            if ( ! (dns_sd.kDNSServiceFlagsMoreComing & flags)) {
	              service.addresses = addresses;
	              adr_getter.stop()
	              next();
	            }
	          }
	        } catch (ex) {
	          adr_getter.stop();
	          next(ex);
	        }
	      }
	
	      dns_sd.DNSServiceGetAddrInfo(
	          adr_getter.serviceRef, 0, service.interfaceIndex, family_flags,
	          service.host, on_get_addr_info_done, null);
	      adr_getter.start();
	    } catch (ex) {
	      adr_getter.stop();
	      next(ex);
	    }
	  }
	}
	
	var _getaddrinfo;
	try {
	  var cares = process.binding('cares_wrap');
	  function getaddrinfo_complete(err, addresses, cb) {
	    if (addresses) {
	      cb(undefined, addresses);
	    } else if (err === 'ENOENT') {
	      cb(undefined, []);
	    } else {
	      cb(errnoException(err, 'getaddrinfo'));
	    }
	  }
	  function getaddrinfo_0_11(host, family, cb) {
	    var req = new cares.GetAddrInfoReqWrap()
	      , err = cares.getaddrinfo(req, host, family)
	      ;
	    req.oncomplete = function oncomplete(err, addresses) {
	        getaddrinfo_complete(err, addresses, cb);
	    }
	    if (err) throw errnoException(err, 'getaddrinfo', host);
	  }
	  function getaddrinfo_0_10(host, family, cb) {
	    var wrap = cares.getaddrinfo(host, family);
	    if ( ! wrap) {
	      throw errnoException(process._errno || global.errno, 'getaddrinfo');
	    }
	    wrap.oncomplete = function (addresses) {
	      getaddrinfo_complete((process._errno || global.errno), addresses, cb);
	    }
	  }
	  // node 0.11+ cares.getaddrinfo function uses request object.
	  // use appropriate version based on node version number
	  if (Number(process.version.match(/^v(\d+\.\d+)/)[1]) > 0.1) {
	    _getaddrinfo = getaddrinfo_0_11;
	  } else {
	    _getaddrinfo = getaddrinfo_0_10;
	  }
	} catch (ex) {
	  _getaddrinfo = process.binding('net').getaddrinfo;
	}
	
	exports.getaddrinfo = function getaddrinfo(options) {
	  options = options || {};
	  var families = options.families || [4, 6];
	  return function getaddrinfo(service, next) {
	    var last_error
	      , counter = 0
	      ;
	    // XXX in older versions of node a zero family value is not supported
	    families.forEach(function(family) {
	      _getaddrinfo(service.host, family, function(error, addresses) {
	        if (error) {
	          last_error = error
	        } else {
	          service.addresses = (service.addresses || []).concat(addresses);
	        }
	        if (++counter === families.length) {
	          next(last_error);
	        }
	      });
	    });
	  }
	}
	
	function unique(array) {
	  var o = {} , p , r = [] ;
	  array.forEach(function(e) { o[e] = undefined });
	  for (p in o) { r.push(p) }
	  return r;
	}
	
	exports.makeAddressesUnique = function makeAddressesUnique() {
	  return function makeAddressesUnique(service, next) {
	    service.addresses = unique(service.addresses);
	    next();
	  }
	}
	
	exports.filterAddresses = function filterAddresses(filter_function) {
	  return function filterAddresses(service, next) {
	    service.addresses = (service.addresses || []).filter(filter_function);
	    next();
	  }
	}
	
	exports.logService = function logService() {
	  return function logService(service, next) {
	    console.log(service);
	    next();
	  }
	}
	
	function errnoException(errorno, syscall) {
	  // TODO make this more compatible with ErrnoException from src/node.cc
	  // Once all of Node is using this function the ErrnoException from
	  // src/node.cc should be removed.
	  var e = new Error(syscall + ' ' + errorno);
	
	  // For backwards compatibility. libuv returns ENOENT on NXDOMAIN.
	  if (errorno == 'ENOENT') {
	    errorno = 'ENOTFOUND'
	  }
	
	  e.errno = e.code = errorno;
	  e.syscall = syscall;
	  return e;
	}
	
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! (webpack)/~/node-libs-browser/~/process/browser.js */ 22), (function() { return this; }())))

/***/ }
/******/ ]);
//# sourceMappingURL=sailgauge.js.map